<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Manual de Usuario</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Manual de Usuario</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#editorial">Editorial</a></li>
<li><a href="#prólogo">Prólogo</a></li>
<li><a href="#qué-es-un-msxvr">¿Qué es un MSXVR?</a></li>
<li><a href="#concepto-y-términos">Concepto y Términos</a>
<ul>
<li><a href="#vr-basic">VR-BASIC</a></li>
<li><a href="#qué-es-vr-basic">¿Qué es VR-BASIC?</a></li>
<li><a href="#texto">Texto</a></li>
<li><a href="#constantes-y-variables">Constantes y Variables</a></li>
<li><a href="#expresiones">Expresiones</a></li>
<li><a href="#matemáticas">Matemáticas</a></li>
<li><a href="#crear-programas">Crear programas</a></li>
<li><a href="#comentar-código">Comentar código</a></li>
<li><a href="#bucles">Bucles</a></li>
<li><a href="#condiciones">Condiciones</a></li>
<li><a href="#tablas-arrays">Tablas (Arrays)</a></li>
<li><a href="#algunos-ejemplos-en-vr-basic">Algunos ejemplos en VR-BASIC</a></li>
<li><a href="#tabla-de-multiplicar">Tabla de multiplicar</a></li>
<li><a href="#tabla-de-multiplicar-optimizada-con-un-bucle">Tabla de multiplicar optimizada con un bucle</a></li>
<li><a href="#adivina-mi-número">Adivina mi número</a></li>
<li><a href="#jugando-con-bucles">Jugando con bucles</a></li>
<li><a href="#jugando-a-tabular-la-salida-de-datos">Jugando a tabular la salida de datos</a></li>
<li><a href="#textos-que-se-mueven">Textos que se mueven</a></li>
<li><a href="#atrapa-el-número">Atrapa el número</a></li>
<li><a href="#slot-machine">Slot machine</a></li>
<li><a href="#moviendo-un-carácter-con-el-teclado">Moviendo un carácter con el teclado</a></li>
<li><a href="#creando-un-menú-de-acciones">Creando un menú de acciones</a></li>
<li><a href="#gráficos">Gráficos</a>
<ul>
<li><a href="#comandos-vr-basic">Comandos VR-BASIC</a></li>
<li><a href="#vdp-en-los-distintos-msx">VDP en los distintos MSX</a></li>
<li><a href="#vram">VRAM</a></li>
<li><a href="#modos-de-pantalla">Modos de Pantalla</a></li>
<li><a href="#páginas-de-vídeo">Páginas de vídeo</a></li>
<li><a href="#página-visible">Página visible</a></li>
<li><a href="#entrelazado">Entrelazado</a></li>
<li><a href="#pixeles-y-puntos">Pixeles y puntos</a></li>
<li><a href="#paleta-de-colores">Paleta de colores</a></li>
<li><a href="#sprites">Sprites</a></li>
</ul></li>
<li><a href="#música-y-sonido">Música y Sonido</a>
<ul>
<li><a href="#lenguaje-mml">Lenguaje MML</a></li>
<li><a href="#chips-de-audio">Chips de audio</a></li>
<li><a href="#instrumentos-o-voces-fm-msx-music-y-msx-audio">Instrumentos o voces FM (MSX-MUSIC y MSX-AUDIO)</a></li>
<li><a href="#instrumentos-de-percusión">Instrumentos de percusión</a></li>
<li><a href="#formato-del-array-de-voz">Formato del array de voz</a></li>
<li><a href="#midi">MIDI</a></li>
</ul></li>
<li><a href="#puertos-de-entrada-y-salida">Puertos de entrada y salida</a></li>
<li><a href="#dispositivos-de-archivo">Dispositivos de archivo</a></li>
<li><a href="#función-de-las-teclas-y-su-utilización">Función de las teclas y su utilización</a></li>
<li><a href="#funcionalidades-adicionales">Funcionalidades adicionales</a></li>
<li><a href="#lista-de-comandos-y-funciones">Lista de comandos y funciones</a></li>
<li><a href="#abs">ABS</a>
<ul>
<li><a href="#versión">Versión</a></li>
<li><a href="#formato">Formato</a></li>
<li><a href="#parámetros">Parámetros</a></li>
<li><a href="#retorno">Retorno</a></li>
<li><a href="#ejemplos">Ejemplos</a></li>
</ul></li>
<li><a href="#asc">ASC</a>
<ul>
<li><a href="#versión-1">Versión</a></li>
<li><a href="#formato-1">Formato</a></li>
<li><a href="#parámetros-1">Parámetros</a></li>
<li><a href="#retorno-1">Retorno</a></li>
<li><a href="#ejemplos-1">Ejemplos</a></li>
</ul></li>
<li><a href="#atn">ATN</a>
<ul>
<li><a href="#versión-2">Versión</a></li>
<li><a href="#formato-2">Formato</a></li>
<li><a href="#parámetros-2">Parámetros</a></li>
<li><a href="#retorno-2">Retorno</a></li>
<li><a href="#ejemplos-2">Ejemplos</a></li>
</ul></li>
<li><a href="#auto">AUTO</a>
<ul>
<li><a href="#versión-3">Versión</a></li>
<li><a href="#formato-3">Formato</a></li>
<li><a href="#parámetros-3">Parámetros</a></li>
<li><a href="#ejemplos-3">Ejemplos</a></li>
</ul></li>
<li><a href="#base">BASE</a>
<ul>
<li><a href="#versión-4">Versión</a></li>
<li><a href="#formato-4">Formato</a></li>
<li><a href="#parámetros-4">Parámetros</a></li>
</ul></li>
<li><a href="#beep">BEEP</a>
<ul>
<li><a href="#versión-5">Versión</a></li>
<li><a href="#formato-5">Formato</a></li>
<li><a href="#ejemplos-4">Ejemplos</a></li>
</ul></li>
<li><a href="#bin">BIN$</a>
<ul>
<li><a href="#versión-6">Versión</a></li>
<li><a href="#formato-6">Formato</a></li>
<li><a href="#parámetros-5">Parámetros</a></li>
<li><a href="#retorno-3">Retorno</a></li>
<li><a href="#ejemplos-5">Ejemplos</a></li>
</ul></li>
<li><a href="#bload">BLOAD</a>
<ul>
<li><a href="#versión-7">Versión</a></li>
<li><a href="#formato-7">Formato</a></li>
<li><a href="#parámetros-6">Parámetros</a></li>
<li><a href="#ejemplos-6">Ejemplos</a></li>
</ul></li>
<li><a href="#bsave">BSAVE</a>
<ul>
<li><a href="#versión-8">Versión</a></li>
<li><a href="#formato-8">Formato</a></li>
<li><a href="#parámetros-7">Parámetros</a></li>
<li><a href="#ejemplo">Ejemplo</a></li>
</ul></li>
<li><a href="#call">CALL</a>
<ul>
<li><a href="#versión-9">Versión</a></li>
<li><a href="#formato-9">Formato</a></li>
<li><a href="#parámetros-8">Parámetros</a></li>
</ul></li>
<li><a href="#call-audio">CALL AUDIO</a>
<ul>
<li><a href="#versión-10">Versión</a></li>
<li><a href="#formato-10">Formato</a></li>
<li><a href="#parámetros-9">Parámetros</a></li>
<li><a href="#ejemplos-7">Ejemplos</a></li>
</ul></li>
<li><a href="#call-audiodriverbaseport">CALL AUDIODRIVERBASEPORT</a>
<ul>
<li><a href="#versión-11">Versión</a></li>
<li><a href="#formato-11">Formato</a></li>
<li><a href="#parámetros-10">Parámetros</a></li>
<li><a href="#ejemplos-8">Ejemplos</a></li>
</ul></li>
<li><a href="#call-audreg">CALL AUDREG</a>
<ul>
<li><a href="#versión-12">Versión</a></li>
<li><a href="#formato-12">Formato</a></li>
<li><a href="#parámetros-11">Parámetros</a></li>
</ul></li>
<li><a href="#call-bgm">CALL BGM</a>
<ul>
<li><a href="#versión-13">Versión</a></li>
<li><a href="#formato-13">Formato</a></li>
<li><a href="#parámetros-12">Parámetros</a></li>
<li><a href="#ejemplos-9">Ejemplos</a></li>
</ul></li>
<li><a href="#call-chdir">CALL CHDIR</a>
<ul>
<li><a href="#versión-14">Versión</a></li>
<li><a href="#formato-14">Formato</a></li>
<li><a href="#parámetros-13">Parámetros</a></li>
</ul></li>
<li><a href="#call-chdrv">CALL CHDRV</a>
<ul>
<li><a href="#versión-15">Versión</a></li>
<li><a href="#formato-15">Formato</a></li>
<li><a href="#parámetros-14">Parámetros</a></li>
</ul></li>
<li><a href="#call-debug">CALL DEBUG</a>
<ul>
<li><a href="#versión-16">Versión</a></li>
<li><a href="#formato-16">Formato</a></li>
</ul></li>
<li><a href="#call-edit">CALL EDIT</a>
<ul>
<li><a href="#versión-17">Versión</a></li>
<li><a href="#formato-17">Formato</a></li>
</ul></li>
<li><a href="#call-format">CALL FORMAT</a>
<ul>
<li><a href="#versión-18">Versión</a></li>
<li><a href="#formato-18">Formato</a></li>
<li><a href="#parámetros-15">Parámetros:</a></li>
</ul></li>
<li><a href="#call-mdr">CALL MDR</a>
<ul>
<li><a href="#versión-19">Versión</a></li>
<li><a href="#formato-19">Formato</a></li>
<li><a href="#parámetros-16">Parámetros</a></li>
<li><a href="#ejemplos-10">Ejemplos</a></li>
</ul></li>
<li><a href="#call-memini">CALL MEMINI</a>
<ul>
<li><a href="#versión-20">Versión</a></li>
<li><a href="#formato-20">Formato</a></li>
<li><a href="#parámetros-17">Parámetros</a></li>
<li><a href="#ejemplos-11">Ejemplos</a></li>
</ul></li>
<li><a href="#call-mfiles">CALL MFILES</a>
<ul>
<li><a href="#versión-21">Versión</a></li>
<li><a href="#formato-21">Formato</a></li>
</ul></li>
<li><a href="#call-mkdir">CALL MKDIR</a>
<ul>
<li><a href="#versión-22">Versión</a></li>
<li><a href="#formato-22">Formato</a></li>
<li><a href="#parámetros-18">Parámetros</a></li>
</ul></li>
<li><a href="#call-mkill">CALL MKILL</a>
<ul>
<li><a href="#versión-23">Versión</a></li>
<li><a href="#formato-23">Formato</a></li>
<li><a href="#parámetros-19">Parámetros</a></li>
<li><a href="#ejemplos-12">Ejemplos</a></li>
</ul></li>
<li><a href="#call-mname">CALL MNAME</a>
<ul>
<li><a href="#versión-24">Versión</a></li>
<li><a href="#formato-24">Formato</a></li>
<li><a href="#parámetros-20">Parámetros</a></li>
</ul></li>
<li><a href="#call-music">CALL MUSIC</a>
<ul>
<li><a href="#versión-25">Versión</a></li>
<li><a href="#formato-25">Formato</a></li>
<li><a href="#parámetros-21">Parámetros</a></li>
<li><a href="#ejemplos-13">Ejemplos</a></li>
</ul></li>
<li><a href="#call-pcmplay">CALL PCMPLAY</a>
<ul>
<li><a href="#versión-26">Versión</a></li>
<li><a href="#formato-26">Formato</a></li>
<li><a href="#parámetros-22">Parámetros</a></li>
<li><a href="#ejemplos-14">Ejemplos</a></li>
</ul></li>
<li><a href="#call-pcmrec">CALL PCMREC</a>
<ul>
<li><a href="#versión-27">Versión</a></li>
<li><a href="#formato-27">Formato</a></li>
<li><a href="#parámetros-23">Parámetros</a></li>
<li><a href="#ejemplos-15">Ejemplos</a></li>
</ul></li>
<li><a href="#call-pitch">CALL PITCH</a>
<ul>
<li><a href="#versión-28">Versión</a></li>
<li><a href="#formato-28">Formato</a></li>
<li><a href="#parámetros-24">Parámetros</a></li>
<li><a href="#ejemplos-16">Ejemplos</a></li>
</ul></li>
<li><a href="#call-play">CALL PLAY</a>
<ul>
<li><a href="#versión-29">Versión</a></li>
<li><a href="#formato-29">Formato</a></li>
<li><a href="#parámetros-25">Parámetros</a></li>
<li><a href="#ejemplos-17">Ejemplos</a></li>
</ul></li>
<li><a href="#call-ramdisk">CALL RAMDISK</a>
<ul>
<li><a href="#versión-30">Versión</a></li>
<li><a href="#formato-30">Formato</a></li>
<li><a href="#parámetros-26">Parámetros</a></li>
</ul></li>
<li><a href="#call-rmdir">CALL RMDIR</a>
<ul>
<li><a href="#versión-31">Versión</a></li>
<li><a href="#formato-31">Formato</a></li>
<li><a href="#parámetros-27">Parámetros</a></li>
</ul></li>
<li><a href="#call-sleep">CALL SLEEP</a>
<ul>
<li><a href="#versión-32">Versión</a></li>
<li><a href="#formato-32">Formato</a></li>
<li><a href="#parámetros-28">Parámetros</a></li>
</ul></li>
<li><a href="#call-speed">CALL SPEED</a>
<ul>
<li><a href="#versión-33">Versión</a></li>
<li><a href="#formato-33">Formato</a></li>
<li><a href="#parámetros-29">Parámetros</a></li>
</ul></li>
<li><a href="#call-stopm">CALL STOPM</a>
<ul>
<li><a href="#versión-34">Versión</a></li>
<li><a href="#formato-34">Formato</a></li>
<li><a href="#ejemplos-18">Ejemplos</a></li>
</ul></li>
<li><a href="#call-system">CALL SYSTEM</a>
<ul>
<li><a href="#versión-35">Versión</a></li>
<li><a href="#formato-35">Formato</a></li>
</ul></li>
<li><a href="#call-temper">CALL TEMPER</a>
<ul>
<li><a href="#versión-36">Versión</a></li>
<li><a href="#formato-36">Formato</a></li>
<li><a href="#parámetros-30">Parámetros</a></li>
<li><a href="#ejemplos-19">Ejemplos</a></li>
</ul></li>
<li><a href="#call-transpose">CALL TRANSPOSE</a>
<ul>
<li><a href="#versión-37">Versión</a></li>
<li><a href="#formato-37">Formato</a></li>
<li><a href="#parámetros-31">Parámetros</a></li>
<li><a href="#ejemplos-20">Ejemplos</a></li>
</ul></li>
<li><a href="#call-vmachine">CALL VMACHINE</a>
<ul>
<li><a href="#versión-38">Versión</a></li>
<li><a href="#formato-38">Formato</a></li>
<li><a href="#parámetros-32">Parámetros</a></li>
<li><a href="#ejemplos-21">Ejemplos</a></li>
</ul></li>
<li><a href="#call-voice">CALL VOICE</a>
<ul>
<li><a href="#versión-39">Versión</a></li>
<li><a href="#formato-39">Formato</a></li>
<li><a href="#parámetros-33">Parámetros</a></li>
<li><a href="#ejemplos-22">Ejemplos</a></li>
</ul></li>
<li><a href="#call-voice-copy">CALL VOICE COPY</a>
<ul>
<li><a href="#versión-40">Versión</a></li>
<li><a href="#formato-40">Formato</a></li>
<li><a href="#parámetros-34">Parámetros</a></li>
<li><a href="#ejemplos-23">Ejemplos</a></li>
</ul></li>
<li><a href="#cdbl">CDBL</a>
<ul>
<li><a href="#versión-41">Versión</a></li>
<li><a href="#formato-41">Formato</a></li>
<li><a href="#parámetros-35">Parámetros</a></li>
<li><a href="#retorno-4">Retorno</a></li>
</ul></li>
<li><a href="#chr">CHR$</a>
<ul>
<li><a href="#versión-42">Versión</a></li>
<li><a href="#formato-42">Formato</a></li>
<li><a href="#parámetros-36">Parámetros</a></li>
<li><a href="#retorno-5">Retorno</a></li>
<li><a href="#ejemplos-24">Ejemplos</a></li>
</ul></li>
<li><a href="#international-codes">International Codes</a></li>
<li><a href="#cint">CINT</a>
<ul>
<li><a href="#versión-43">Versión</a></li>
<li><a href="#formato-43">Formato</a></li>
<li><a href="#parámetros-37">Parámetros</a></li>
<li><a href="#retorno-6">Retorno</a></li>
<li><a href="#ejemplos-25">Ejemplos</a></li>
</ul></li>
<li><a href="#circle">CIRCLE</a>
<ul>
<li><a href="#versión-44">Versión</a></li>
<li><a href="#formato-44">Formato</a></li>
<li><a href="#parámetros-38">Parámetros</a></li>
<li><a href="#ejemplos-26">Ejemplos</a></li>
</ul></li>
<li><a href="#clear">CLEAR</a>
<ul>
<li><a href="#versión-45">Versión</a></li>
<li><a href="#formato-45">Formato</a></li>
<li><a href="#parámetros-39">Parámetros</a></li>
<li><a href="#ejemplos-27">Ejemplos</a></li>
</ul></li>
<li><a href="#cload">CLOAD</a>
<ul>
<li><a href="#versión-46">Versión</a></li>
<li><a href="#formato-46">Formato</a></li>
<li><a href="#parámetros-40">Parámetros</a></li>
<li><a href="#ejemplos-28">Ejemplos</a></li>
</ul></li>
<li><a href="#cload-1">CLOAD?</a>
<ul>
<li><a href="#versión-47">Versión</a></li>
<li><a href="#formato-47">Formato</a></li>
<li><a href="#parámetros-41">Parámetros</a></li>
<li><a href="#ejemplos-29">Ejemplos</a></li>
</ul></li>
<li><a href="#close">CLOSE</a>
<ul>
<li><a href="#versión-48">Versión</a></li>
<li><a href="#formato-48">Formato</a></li>
<li><a href="#parámetros-42">Parámetros</a></li>
<li><a href="#ejemplos-30">Ejemplos</a></li>
</ul></li>
<li><a href="#cls">CLS</a>
<ul>
<li><a href="#versión-49">Versión</a></li>
<li><a href="#formato-49">Formato</a></li>
</ul></li>
<li><a href="#color">COLOR</a>
<ul>
<li><a href="#versión-50">Versión</a></li>
<li><a href="#formato-50">Formato</a></li>
<li><a href="#parámetros-43">Parámetros</a></li>
<li><a href="#ejemplos-31">Ejemplos</a></li>
</ul></li>
<li><a href="#color-pal-r-g-b">COLOR = (pal, r, g, b)</a>
<ul>
<li><a href="#versión-51">Versión</a></li>
<li><a href="#formato-51">Formato</a></li>
<li><a href="#parámetros-44">Parámetros</a></li>
<li><a href="#ejemplos-32">Ejemplos</a></li>
</ul></li>
<li><a href="#color-new">COLOR [= NEW]</a>
<ul>
<li><a href="#versión-52">Versión</a></li>
<li><a href="#formato-52">Formato</a></li>
<li><a href="#parámetros-45">Parámetros</a></li>
</ul></li>
<li><a href="#color-restore">COLOR = RESTORE</a>
<ul>
<li><a href="#versión-53">Versión</a></li>
<li><a href="#formato-53">Formato</a></li>
<li><a href="#ejemplos-33">Ejemplos</a></li>
</ul></li>
<li><a href="#color-sprite">COLOR SPRITE</a>
<ul>
<li><a href="#versión-54">Versión</a></li>
<li><a href="#formato-54">Formato</a></li>
<li><a href="#parámetros-46">Parámetros</a></li>
</ul></li>
<li><a href="#color-sprite-1">COLOR SPRITE$</a>
<ul>
<li><a href="#versión-55">Versión</a></li>
<li><a href="#formato-55">Formato</a></li>
<li><a href="#parámetros-47">Parámetros</a></li>
<li><a href="#ejemplos-34">Ejemplos</a></li>
</ul></li>
<li><a href="#cont">CONT</a>
<ul>
<li><a href="#versión-56">Versión</a></li>
<li><a href="#formato-56">Formato</a></li>
</ul></li>
<li><a href="#copy">COPY</a>
<ul>
<li><a href="#versión-57">Versión</a></li>
<li><a href="#formato-57">Formato</a></li>
<li><a href="#parámetros-48">Parámetros</a></li>
<li><a href="#ejemplos-35">Ejemplos</a></li>
</ul></li>
<li><a href="#copy-1">COPY</a>
<ul>
<li><a href="#versión-58">Versión</a></li>
<li><a href="#formato-58">Formato</a></li>
<li><a href="#parámetros-49">Parámetros</a></li>
<li><a href="#ejemplos-36">Ejemplos</a></li>
</ul></li>
<li><a href="#copy-screen">COPY SCREEN</a>
<ul>
<li><a href="#versión-59">Versión</a></li>
<li><a href="#formato-59">Formato</a></li>
<li><a href="#parámetros-50">Parámetros</a></li>
<li><a href="#ejemplo-1">Ejemplo</a></li>
</ul></li>
<li><a href="#cos">COS</a>
<ul>
<li><a href="#versión-60">Versión</a></li>
<li><a href="#formato-60">Formato</a></li>
<li><a href="#parámetros-51">Parámetros</a></li>
<li><a href="#retorno-7">Retorno</a></li>
<li><a href="#ejemplos-37">Ejemplos</a></li>
</ul></li>
<li><a href="#csave">CSAVE</a>
<ul>
<li><a href="#versión-61">Versión</a></li>
<li><a href="#formato-61">Formato</a></li>
<li><a href="#parámetros-52">Parámetros</a></li>
<li><a href="#ejemplos-38">Ejemplos</a></li>
</ul></li>
<li><a href="#csng">CSNG</a>
<ul>
<li><a href="#versión-62">Versión</a></li>
<li><a href="#formato-62">Formato</a></li>
<li><a href="#parámetros-53">Parámetros</a></li>
<li><a href="#retorno-8">Retorno</a></li>
<li><a href="#ejemplos-39">Ejemplos</a></li>
</ul></li>
<li><a href="#csrlin">CSRLIN</a>
<ul>
<li><a href="#versión-63">Versión</a></li>
<li><a href="#formato-63">Formato</a></li>
<li><a href="#ejemplos-40">Ejemplos</a></li>
</ul></li>
<li><a href="#cvicvscvd">CVI/CVS/CVD</a>
<ul>
<li><a href="#versión-64">Versión</a></li>
<li><a href="#formato-64">Formato</a></li>
<li><a href="#parámetros-54">Parámetros</a></li>
<li><a href="#retorno-9">Retorno</a></li>
</ul></li>
<li><a href="#data">DATA</a>
<ul>
<li><a href="#versión-65">Versión</a></li>
<li><a href="#formato-65">Formato</a></li>
<li><a href="#parámetros-55">PARÁMETROS</a></li>
<li><a href="#ejemplos-41">EJEMPLOS</a></li>
</ul></li>
<li><a href="#def-fn">DEF FN</a>
<ul>
<li><a href="#versión-66">Versión</a></li>
<li><a href="#formato-66">Formato</a></li>
<li><a href="#parámetros-56">Parámetros</a></li>
<li><a href="#ejemplos-42">Ejemplos</a></li>
</ul></li>
<li><a href="#defint-defsngdefdbldefstr">DEFINT/ DEFSNG/DEFDBL/DEFSTR</a>
<ul>
<li><a href="#versión-67">Versión</a></li>
<li><a href="#formato-67">Formato</a></li>
<li><a href="#parámetros-57">Parámetros</a></li>
<li><a href="#ejemplos-43">Ejemplos</a></li>
</ul></li>
<li><a href="#defusr">DEFUSR</a>
<ul>
<li><a href="#versión-68">Versión</a></li>
<li><a href="#formato-68">Formato</a></li>
<li><a href="#parámetros-58">Parámetros</a></li>
<li><a href="#ejemplos-44">Ejemplos</a></li>
</ul></li>
<li><a href="#delete">DELETE</a>
<ul>
<li><a href="#versión-69">Versión</a></li>
<li><a href="#formato-69">Formato</a></li>
<li><a href="#parámetros-59">Parámetros</a></li>
<li><a href="#ejemplos-45">Ejemplos</a></li>
</ul></li>
<li><a href="#dim">DIM</a>
<ul>
<li><a href="#versión-70">Versión</a></li>
<li><a href="#formato-70">Formato</a></li>
<li><a href="#parámetros-60">Parámetros</a></li>
<li><a href="#ejemplos-46">Ejemplos</a></li>
</ul></li>
<li><a href="#draw">DRAW</a>
<ul>
<li><a href="#versión-71">Versión</a></li>
<li><a href="#formato-71">Formato</a></li>
<li><a href="#parámetros-61">Parámetros</a></li>
<li><a href="#ejemplo-1-1">Ejemplo 1</a></li>
<li><a href="#ejemplo-2">Ejemplo 2</a></li>
<li><a href="#ejemplo-3">Ejemplo 3</a></li>
<li><a href="#ejemplo-4">Ejemplo 4</a></li>
</ul></li>
<li><a href="#dskf">DSKF</a>
<ul>
<li><a href="#versión-72">Versión</a></li>
<li><a href="#formato-72">Formato</a></li>
<li><a href="#parámetros-62">Parámetros</a></li>
<li><a href="#retorno-10">Retorno</a></li>
</ul></li>
<li><a href="#end">END</a>
<ul>
<li><a href="#versión-73">Versión</a></li>
<li><a href="#formato-73">Formato</a></li>
<li><a href="#ejemplos-47">Ejemplos</a></li>
</ul></li>
<li><a href="#eof">EOF</a>
<ul>
<li><a href="#versión-74">Versión</a></li>
<li><a href="#formato-74">Formato</a></li>
<li><a href="#parámetros-63">Parámetros</a></li>
<li><a href="#retorno-11">Retorno</a></li>
<li><a href="#ejemplos-48">Ejemplos</a></li>
</ul></li>
<li><a href="#erase">ERASE</a>
<ul>
<li><a href="#versión-75">Versión</a></li>
<li><a href="#formato-75">Formato</a></li>
<li><a href="#parámetros-64">Parámetros</a></li>
<li><a href="#ejemplos-49">Ejemplos</a></li>
</ul></li>
<li><a href="#erl">ERL</a>
<ul>
<li><a href="#versión-76">Versión</a></li>
<li><a href="#formato-76">Formato</a></li>
<li><a href="#retorno-12">Retorno</a></li>
<li><a href="#ejemplos-50">Ejemplos</a></li>
</ul></li>
<li><a href="#err">ERR</a>
<ul>
<li><a href="#versión-77">Versión</a></li>
<li><a href="#formato-77">Formato</a></li>
<li><a href="#retorno-13">Retorno</a></li>
<li><a href="#ejemplos-51">Ejemplos</a></li>
</ul></li>
<li><a href="#error">ERROR</a>
<ul>
<li><a href="#versión-78">Versión</a></li>
<li><a href="#formato-78">Formato</a></li>
<li><a href="#parámetros-65">Parámetros</a></li>
<li><a href="#ejemplos-52">Ejemplos</a></li>
</ul></li>
<li><a href="#exp">EXP</a>
<ul>
<li><a href="#versión-79">Versión</a></li>
<li><a href="#formato-79">Formato</a></li>
<li><a href="#parámetros-66">Parámetros</a></li>
<li><a href="#retorno-14">Retorno</a></li>
<li><a href="#ejemplos-53">Ejemplos</a></li>
</ul></li>
<li><a href="#field">FIELD</a>
<ul>
<li><a href="#versión-80">Versión</a></li>
<li><a href="#formato-80">Formato</a></li>
<li><a href="#parámetros-67">Parámetros</a></li>
<li><a href="#ejemplos-54">Ejemplos</a></li>
</ul></li>
<li><a href="#files">FILES</a>
<ul>
<li><a href="#versión-81">Versión</a></li>
<li><a href="#fomato">Fomato</a></li>
<li><a href="#parámetros-68">Parámetros</a></li>
<li><a href="#ejemplos-55">Ejemplos</a></li>
</ul></li>
<li><a href="#fix">FIX</a>
<ul>
<li><a href="#versión-82">Versión</a></li>
<li><a href="#formato-81">Formato</a></li>
<li><a href="#parámetros-69">Parámetros</a></li>
<li><a href="#retorno-15">Retorno</a></li>
<li><a href="#ejemplos-56">Ejemplos</a></li>
</ul></li>
<li><a href="#for--next">FOR -NEXT</a>
<ul>
<li><a href="#versión-83">Versión</a></li>
<li><a href="#formato-82">Formato</a></li>
<li><a href="#parámetros-70">Parámetros</a></li>
<li><a href="#ejemplos-57">Ejemplos</a></li>
</ul></li>
<li><a href="#fre">FRE</a>
<ul>
<li><a href="#versión-84">Versión</a></li>
<li><a href="#formato-83">Formato</a></li>
<li><a href="#parámetros-71">Parámetros</a></li>
<li><a href="#retorno-16">Retorno</a></li>
<li><a href="#ejemplos-58">Ejemplos</a></li>
</ul></li>
<li><a href="#get">GET</a>
<ul>
<li><a href="#versión-85">Versión</a></li>
<li><a href="#formato-84">Formato</a></li>
<li><a href="#parámetros-72">Parámetros</a></li>
<li><a href="#ejemplos-59">Ejemplos</a></li>
</ul></li>
<li><a href="#get-date">GET DATE</a>
<ul>
<li><a href="#versión-86">Versión</a></li>
<li><a href="#formato-85">Formato</a></li>
<li><a href="#parámetros-73">Parámetros</a></li>
<li><a href="#ejemplos-60">Ejemplos</a></li>
</ul></li>
<li><a href="#get-time">GET TIME</a>
<ul>
<li><a href="#versión-87">Versión</a></li>
<li><a href="#formato-86">Formato</a></li>
<li><a href="#parámetros-74">Parámetros</a></li>
<li><a href="#ejemplos-61">Ejemplos</a></li>
</ul></li>
<li><a href="#gosub-return-1">GOSUB-RETURN</a>
<ul>
<li><a href="#versión-88">Versión</a></li>
<li><a href="#formato-87">Formato</a></li>
<li><a href="#parámetros-75">Parámetros</a></li>
</ul></li>
<li><a href="#goto-1">GOTO</a>
<ul>
<li><a href="#versión-89">Versión</a></li>
<li><a href="#formato-88">Formato</a></li>
<li><a href="#parámetros-76">Parámetros</a></li>
</ul></li>
<li><a href="#hex">HEX$</a>
<ul>
<li><a href="#versión-90">Versión</a></li>
<li><a href="#formato-89">Formato</a></li>
<li><a href="#parámetros-77">Parámetros</a></li>
<li><a href="#retorno-17">Retorno</a></li>
<li><a href="#ejemplos-62">Ejemplos</a></li>
</ul></li>
<li><a href="#if--then-else">IF- THEN-ELSE</a>
<ul>
<li><a href="#versión-91">Versión</a></li>
<li><a href="#formato-90">Formato</a></li>
<li><a href="#parámetros-78">Parámetros</a></li>
<li><a href="#ejemplos-63">Ejemplos</a></li>
</ul></li>
<li><a href="#inkey">INKEY$</a>
<ul>
<li><a href="#versión-92">Versión</a></li>
<li><a href="#formato-91">Formato</a></li>
<li><a href="#retorno-18">Retorno</a></li>
<li><a href="#ejemplos-64">Ejemplos</a></li>
</ul></li>
<li><a href="#inp">INP</a>
<ul>
<li><a href="#versión-93">Versión</a></li>
<li><a href="#formato-92">Formato</a></li>
<li><a href="#parámetros-79">Parámetros</a></li>
<li><a href="#retorno-19">Retorno</a></li>
</ul></li>
<li><a href="#input">INPUT</a>
<ul>
<li><a href="#versión-94">Versión</a></li>
<li><a href="#formato-93">Formato</a></li>
<li><a href="#parámetros-80">Parámetros</a></li>
<li><a href="#ejemplos-65">Ejemplos</a></li>
</ul></li>
<li><a href="#input-1">INPUT$</a>
<ul>
<li><a href="#versión-95">Versión</a></li>
<li><a href="#formato-94">Formato</a></li>
<li><a href="#parámetros-81">Parámetros</a></li>
<li><a href="#retorno-20">Retorno</a></li>
<li><a href="#ejemplos-66">Ejemplos</a></li>
</ul></li>
<li><a href="#input-2">INPUT#</a>
<ul>
<li><a href="#versión-96">Versión</a></li>
<li><a href="#formato-95">Formato</a></li>
<li><a href="#parámetros-82">Parámetros</a></li>
<li><a href="#ejemplos-67">Ejemplos</a></li>
</ul></li>
<li><a href="#instr">INSTR</a>
<ul>
<li><a href="#versión-97">Versión</a></li>
<li><a href="#formato-96">Formato</a></li>
<li><a href="#parámetros-83">Parámetros</a></li>
<li><a href="#retorno-21">Retorno</a></li>
<li><a href="#ejemplos-68">Ejemplos</a></li>
</ul></li>
<li><a href="#int">INT</a>
<ul>
<li><a href="#versión-98">Versión</a></li>
<li><a href="#formato-97">Formato</a></li>
<li><a href="#parámetros-84">Parámetros</a></li>
<li><a href="#retorno-22">Retorno</a></li>
<li><a href="#ejemplos-69">Ejemplos</a></li>
</ul></li>
<li><a href="#interval-on-interval-off-interval-stop">INTERVAL ON/ INTERVAL OFF/ INTERVAL STOP</a>
<ul>
<li><a href="#versión-99">Versión</a></li>
<li><a href="#formato-98">Formato</a></li>
<li><a href="#ejemplos-70">Ejemplos</a></li>
</ul></li>
<li><a href="#key">KEY</a>
<ul>
<li><a href="#versión-100">Versión</a></li>
<li><a href="#formato-99">Formato</a></li>
<li><a href="#parámetros-85">Parámetros</a></li>
<li><a href="#ejemplos-71">Ejemplos</a></li>
</ul></li>
<li><a href="#key-list">KEY LIST</a>
<ul>
<li><a href="#versión-101">Versión</a></li>
<li><a href="#formato-100">Formato</a></li>
<li><a href="#ejemplos-72">Ejemplos</a></li>
</ul></li>
<li><a href="#key-on-key-off">KEY ON/ KEY OFF</a>
<ul>
<li><a href="#versión-102">Versión</a></li>
<li><a href="#formato-101">Formato</a></li>
</ul></li>
<li><a href="#key-n-onkey-n-off-key-n-stop">KEY (n) ON/KEY (n) OFF/ KEY (n) STOP</a>
<ul>
<li><a href="#versión-103">Versión</a></li>
<li><a href="#formato-102">Formato</a></li>
<li><a href="#parámetros-86">Parámetros</a></li>
<li><a href="#ejemplos-73">Ejemplos</a></li>
</ul></li>
<li><a href="#kill">KILL</a>
<ul>
<li><a href="#versión-104">Versión</a></li>
<li><a href="#formato-103">Formato</a></li>
<li><a href="#parámetros-87">Parámetros</a></li>
<li><a href="#ejemplos-74">Ejemplos</a></li>
</ul></li>
<li><a href="#left">LEFT$</a>
<ul>
<li><a href="#versión-105">Versión</a></li>
<li><a href="#formato-104">Formato</a></li>
<li><a href="#parámetros-88">Parámetros</a></li>
<li><a href="#retorno-23">Retorno</a></li>
<li><a href="#ejemplos-75">Ejemplos</a></li>
</ul></li>
<li><a href="#len">LEN</a>
<ul>
<li><a href="#versión-106">Versión</a></li>
<li><a href="#formato-105">Formato</a></li>
<li><a href="#parámetros-89">Parámetros</a></li>
<li><a href="#retorno-24">Retorno</a></li>
<li><a href="#ejemplos-76">Ejemplos</a></li>
</ul></li>
<li><a href="#let">LET</a>
<ul>
<li><a href="#versión-107">Versión</a></li>
<li><a href="#formato-106">Formato</a></li>
<li><a href="#parámetros-90">Parámetros</a></li>
<li><a href="#ejemplos-77">Ejemplos</a></li>
</ul></li>
<li><a href="#line">LINE</a>
<ul>
<li><a href="#versión-108">Versión</a></li>
<li><a href="#formato-107">Formato</a></li>
<li><a href="#parámetros-91">Parámetros</a></li>
<li><a href="#ejemplos-78">Ejemplos</a></li>
</ul></li>
<li><a href="#line-input">LINE INPUT</a>
<ul>
<li><a href="#versión-109">Versión</a></li>
<li><a href="#formato-108">Formato</a></li>
<li><a href="#parámetros-92">Parámetros</a></li>
<li><a href="#ejemplos-79">Ejemplos</a></li>
</ul></li>
<li><a href="#line-input-1">LINE INPUT #</a>
<ul>
<li><a href="#versión-110">Versión</a></li>
<li><a href="#formato-109">Formato</a></li>
<li><a href="#parámetros-93">Parámetros</a></li>
<li><a href="#ejemplos-80">Ejemplos</a></li>
</ul></li>
<li><a href="#list">LIST</a>
<ul>
<li><a href="#versión-111">Versión</a></li>
<li><a href="#formato-110">Formato</a></li>
<li><a href="#parámetros-94">Parámetros</a></li>
<li><a href="#ejemplos-81">Ejemplos</a></li>
</ul></li>
<li><a href="#llist">LLIST</a>
<ul>
<li><a href="#versión-112">Versión</a></li>
<li><a href="#formato-111">Formato</a></li>
<li><a href="#parámetros-95">Parámetros</a></li>
</ul></li>
<li><a href="#load">LOAD</a>
<ul>
<li><a href="#versión-113">Versión</a></li>
<li><a href="#formato-112">Formato</a></li>
<li><a href="#parámetros-96">Parámetros</a></li>
<li><a href="#ejemplos-82">Ejemplos</a></li>
</ul></li>
<li><a href="#loc">LOC</a>
<ul>
<li><a href="#versión-114">Versión</a></li>
<li><a href="#formato-113">Formato</a></li>
<li><a href="#parámetros-97">Parámetros</a></li>
<li><a href="#retorno-25">Retorno</a></li>
</ul></li>
<li><a href="#locate">LOCATE</a>
<ul>
<li><a href="#versión-115">Versión</a></li>
<li><a href="#formato-114">Formato</a></li>
<li><a href="#parámetros-98">Parámetros</a></li>
<li><a href="#ejemplos-83">Ejemplos</a></li>
</ul></li>
<li><a href="#lof">LOF</a>
<ul>
<li><a href="#versión-116">Versión</a></li>
<li><a href="#formato-115">Formato</a></li>
<li><a href="#parámetros-99">Parámetros</a></li>
<li><a href="#retorno-26">Retorno</a></li>
</ul></li>
<li><a href="#log">LOG</a>
<ul>
<li><a href="#versión-117">Versión</a></li>
<li><a href="#formato-116">Formato</a></li>
<li><a href="#parámetros-100">Parámetros</a></li>
<li><a href="#retorno-27">Retorno</a></li>
<li><a href="#ejemplos-84">Ejemplos</a></li>
</ul></li>
<li><a href="#lpos">LPOS</a>
<ul>
<li><a href="#versión-118">Versión</a></li>
<li><a href="#formato-117">Formato</a></li>
<li><a href="#parámetros-101">Parámetros</a></li>
<li><a href="#retorno-28">Retorno</a></li>
</ul></li>
<li><a href="#lprint">LPRINT</a>
<ul>
<li><a href="#versión-119">Versión</a></li>
<li><a href="#formato-118">Formato</a></li>
<li><a href="#parámetros-102">Parámetros</a></li>
</ul></li>
<li><a href="#lprint-using">LPRINT USING</a>
<ul>
<li><a href="#versión-120">Versión</a></li>
<li><a href="#formato-119">Formato</a></li>
<li><a href="#parámetros-103">Parámetros</a></li>
</ul></li>
<li><a href="#lset">LSET</a>
<ul>
<li><a href="#versión-121">Versión</a></li>
<li><a href="#formato-120">Formato</a></li>
<li><a href="#parámetros-104">Parámetros</a></li>
<li><a href="#ejemplos-85">Ejemplos</a></li>
</ul></li>
<li><a href="#maxfiles">MAXFILES</a>
<ul>
<li><a href="#versión-122">Versión</a></li>
<li><a href="#formato-121">Formato</a></li>
<li><a href="#parámetros-105">Parámetros</a></li>
<li><a href="#ejemplos-86">Ejemplos</a></li>
</ul></li>
<li><a href="#merge">MERGE</a>
<ul>
<li><a href="#versión-123">Versión</a></li>
<li><a href="#formato-122">Formato</a></li>
<li><a href="#parámetros-106">Parámetros</a></li>
<li><a href="#ejemplos-87">Ejemplos</a></li>
</ul></li>
<li><a href="#mid">MID$</a>
<ul>
<li><a href="#versión-124">Versión</a></li>
<li><a href="#formato-123">Formato</a></li>
<li><a href="#parámetros-107">Parámetros</a></li>
<li><a href="#retorno-29">Retorno</a></li>
<li><a href="#ejemplos-88">Ejemplos</a></li>
</ul></li>
<li><a href="#mid-y">MID$ = Y$</a>
<ul>
<li><a href="#versión-125">Versión</a></li>
<li><a href="#formato-124">Formato</a></li>
<li><a href="#parámetros-108">Parámetros</a></li>
<li><a href="#ejemplos-89">Ejemplos</a></li>
</ul></li>
<li><a href="#mkimksmkd">MKI$/MKS$/MKD$</a>
<ul>
<li><a href="#versión-126">Versión</a></li>
<li><a href="#formato-125">Formato</a></li>
<li><a href="#parámetros-109">Parámetros</a></li>
<li><a href="#retorno-30">Retorno</a></li>
<li><a href="#ejemplos-90">Ejemplos</a></li>
</ul></li>
<li><a href="#motor">MOTOR</a>
<ul>
<li><a href="#versión-127">Versión</a></li>
<li><a href="#formato-126">Formato</a></li>
</ul></li>
<li><a href="#name">NAME</a>
<ul>
<li><a href="#versión-128">Versión</a></li>
<li><a href="#formato-127">Formato</a></li>
<li><a href="#parámetros-110">Parámetros</a></li>
<li><a href="#ejemplos-91">Ejemplos</a></li>
</ul></li>
<li><a href="#new">NEW</a>
<ul>
<li><a href="#versión-129">Versión</a></li>
<li><a href="#formato-128">Formato</a></li>
</ul></li>
<li><a href="#oct">OCT$</a>
<ul>
<li><a href="#versión-130">Versión</a></li>
<li><a href="#formato-129">Formato</a></li>
<li><a href="#parámetros-111">Parámetros</a></li>
<li><a href="#retorno-31">Retorno</a></li>
<li><a href="#ejemplos-92">Ejemplos</a></li>
</ul></li>
<li><a href="#on-error-goto">ON ERROR GOTO</a>
<ul>
<li><a href="#versión-131">Versión</a></li>
<li><a href="#formato-130">Formato</a></li>
<li><a href="#parámetros-112">Parámetros</a></li>
<li><a href="#ejemplos-93">Ejemplos</a></li>
</ul></li>
<li><a href="#on-gosub">ON GOSUB</a>
<ul>
<li><a href="#versión-132">Versión</a></li>
<li><a href="#formato-131">Formato</a></li>
<li><a href="#parámetros-113">Parámetros</a></li>
<li><a href="#ejemplos-94">Ejemplos</a></li>
</ul></li>
<li><a href="#on-goto-1">ON GOTO</a>
<ul>
<li><a href="#versión-133">Versión</a></li>
<li><a href="#formato-132">Formato</a></li>
<li><a href="#parámetros-114">Parámetros</a></li>
<li><a href="#ejemplos-95">Ejemplos</a></li>
</ul></li>
<li><a href="#on-interval-gosub">ON INTERVAL GOSUB</a>
<ul>
<li><a href="#versión-134">Versión</a></li>
<li><a href="#formato-133">Formato</a></li>
<li><a href="#parámetros-115">Parámetros</a></li>
<li><a href="#ejemplos-96">Ejemplos</a></li>
</ul></li>
<li><a href="#on-key-gosub">ON KEY GOSUB</a>
<ul>
<li><a href="#versión-135">Versión</a></li>
<li><a href="#formato-134">Formato</a></li>
<li><a href="#parámetros-116">Parámetros</a></li>
<li><a href="#ejemplos-97">Ejemplos</a></li>
</ul></li>
<li><a href="#on-sprite-gosub">ON SPRITE GOSUB</a>
<ul>
<li><a href="#versión-136">Versión</a></li>
<li><a href="#formato-135">Formato</a></li>
<li><a href="#parámetros-117">Parámetros</a></li>
<li><a href="#ejemplo-1-2">Ejemplo 1</a></li>
<li><a href="#ejemplo-2-1">Ejemplo 2</a></li>
</ul></li>
<li><a href="#on-stop-gosub">ON STOP GOSUB</a>
<ul>
<li><a href="#versión-137">Versión</a></li>
<li><a href="#formato-136">Formato</a></li>
<li><a href="#parámetros-118">Parámetros</a></li>
<li><a href="#ejemplos-98">Ejemplos</a></li>
</ul></li>
<li><a href="#on-strig-gosub">ON STRIG GOSUB</a>
<ul>
<li><a href="#versión-138">Versión</a></li>
<li><a href="#formato-137">Formato</a></li>
<li><a href="#parámetros-119">Parámetros</a></li>
<li><a href="#ejemplos-99">Ejemplos</a></li>
</ul></li>
<li><a href="#open">OPEN</a>
<ul>
<li><a href="#versión-139">Versión</a></li>
<li><a href="#formato-138">Formato</a></li>
<li><a href="#parámetros-120">Parámetros</a></li>
<li><a href="#ejemplos-100">Ejemplos</a></li>
</ul></li>
<li><a href="#out">OUT</a>
<ul>
<li><a href="#versión-140">Versión</a></li>
<li><a href="#formato-139">Formato</a></li>
<li><a href="#parámetros-121">Parámetros</a></li>
</ul></li>
<li><a href="#pad">PAD</a>
<ul>
<li><a href="#versión-141">Versión</a></li>
<li><a href="#formato-140">Formato</a></li>
<li><a href="#parámetros-122">Parámetros</a></li>
<li><a href="#retorno-32">Retorno</a></li>
<li><a href="#ejemplos-101">Ejemplos</a></li>
</ul></li>
<li><a href="#paint">PAINT</a>
<ul>
<li><a href="#versión-142">Versión</a></li>
<li><a href="#formato-141">Formato</a></li>
<li><a href="#parámetros-123">Parámetros</a></li>
<li><a href="#ejemplos-102">Ejemplos</a></li>
</ul></li>
<li><a href="#pdl">PDL</a>
<ul>
<li><a href="#versión-143">Versión</a></li>
<li><a href="#formato-142">Formato</a></li>
<li><a href="#parámetros-124">Parámetros</a></li>
<li><a href="#retorno-33">Retorno</a></li>
</ul></li>
<li><a href="#peek">PEEK</a>
<ul>
<li><a href="#versión-144">Versión</a></li>
<li><a href="#formato-143">Formato</a></li>
<li><a href="#parámetros-125">Parámetros</a></li>
<li><a href="#retorno-34">Retorno</a></li>
<li><a href="#ejemplos-103">Ejemplos</a></li>
</ul></li>
<li><a href="#play">PLAY</a>
<ul>
<li><a href="#versión-145">Versión</a></li>
<li><a href="#formato-144">Formato</a></li>
<li><a href="#parámetros-126">Parámetros</a></li>
</ul></li>
<li><a href="#play-1">PLAY</a>
<ul>
<li><a href="#versión-146">Versión</a></li>
<li><a href="#formato-145">Formato</a></li>
<li><a href="#parámetros-127">Parámetros</a></li>
<li><a href="#retorno-35">Retorno</a></li>
</ul></li>
<li><a href="#point">POINT</a>
<ul>
<li><a href="#versión-147">Versión</a></li>
<li><a href="#formato-146">Formato</a></li>
<li><a href="#parámetros-128">Parámetros</a></li>
<li><a href="#ejemplos-104">Ejemplos</a></li>
</ul></li>
<li><a href="#poke">POKE</a>
<ul>
<li><a href="#versión-148">Versión</a></li>
<li><a href="#formato-147">Formato</a></li>
<li><a href="#parámetros-129">Parámetros</a></li>
<li><a href="#ejemplos-105">Ejemplos</a></li>
</ul></li>
<li><a href="#pos">POS</a>
<ul>
<li><a href="#versión-149">Versión</a></li>
<li><a href="#formato-148">Formato</a></li>
<li><a href="#parámetros-130">Parámetros</a></li>
<li><a href="#retorno-36">Retorno</a></li>
<li><a href="#ejemplos-106">Ejemplos</a></li>
</ul></li>
<li><a href="#preset">PRESET</a>
<ul>
<li><a href="#versión-150">Versión</a></li>
<li><a href="#formato-149">Formato</a></li>
<li><a href="#parámetros-131">Parámetros</a></li>
</ul></li>
<li><a href="#print">PRINT</a>
<ul>
<li><a href="#versión-151">Versión</a></li>
<li><a href="#formato-150">Formato</a></li>
<li><a href="#parámetros-132">Parámetros</a></li>
<li><a href="#ejemplos-107">Ejemplos</a></li>
</ul></li>
<li><a href="#print-using">PRINT USING</a>
<ul>
<li><a href="#versión-152">Versión</a></li>
<li><a href="#formato-151">Formato</a></li>
<li><a href="#parámetros-133">Parámetros</a></li>
</ul></li>
<li><a href="#print-1">PRINT #</a>
<ul>
<li><a href="#versión-153">Versión</a></li>
<li><a href="#formato-152">Formato</a></li>
<li><a href="#parámetros-134">Parámetros</a></li>
<li><a href="#ejemplos-108">Ejemplos</a></li>
</ul></li>
<li><a href="#print-using-1">PRINT #USING</a>
<ul>
<li><a href="#versión-154">Versión</a></li>
<li><a href="#formato-153">Formato</a></li>
<li><a href="#parámetros-135">Parámetros</a></li>
</ul></li>
<li><a href="#pset">PSET</a>
<ul>
<li><a href="#versión-155">Versión</a></li>
<li><a href="#formato-154">Formato</a></li>
<li><a href="#parámetros-136">Parámetros</a></li>
<li><a href="#ejemplo1">Ejemplo1</a></li>
<li><a href="#ejemplo-2-2">Ejemplo 2</a></li>
<li><a href="#ejemplo-3-1">Ejemplo 3</a></li>
</ul></li>
<li><a href="#put">PUT</a>
<ul>
<li><a href="#versión-156">Versión</a></li>
<li><a href="#formato-155">Formato</a></li>
<li><a href="#parámetros-137">Parámetros</a></li>
<li><a href="#ejemplos-109">Ejemplos</a></li>
</ul></li>
<li><a href="#put-sprite">PUT SPRITE</a>
<ul>
<li><a href="#versión-157">Versión</a></li>
<li><a href="#formato-156">Formato</a></li>
<li><a href="#parámetros-138">Parámetros</a></li>
<li><a href="#ejemplo-1-3">Ejemplo 1</a></li>
<li><a href="#ejemplo-2-3">Ejemplo 2</a></li>
<li><a href="#ejemplo-3-2">Ejemplo 3</a></li>
<li><a href="#ejemplo-4-1">Ejemplo 4</a></li>
<li><a href="#ejemplo-5">Ejemplo 5</a></li>
<li><a href="#ejemplo-6">Ejemplo 6</a></li>
<li><a href="#ejemplo-7">Ejemplo 7</a></li>
<li><a href="#ejemplo-8">Ejemplo 8</a></li>
<li><a href="#ejemplo-9">Ejemplo 9</a></li>
</ul></li>
<li><a href="#read">READ</a>
<ul>
<li><a href="#versión-158">Versión</a></li>
<li><a href="#formato-157">Formato</a></li>
<li><a href="#parámetros-139">Parámetros</a></li>
<li><a href="#ejemplos-110">Ejemplos</a></li>
</ul></li>
<li><a href="#rem">REM</a>
<ul>
<li><a href="#versión-159">Versión</a></li>
<li><a href="#formato-158">Formato</a></li>
<li><a href="#ejemplos-111">Ejemplos</a></li>
</ul></li>
<li><a href="#renum">RENUM</a>
<ul>
<li><a href="#versión-160">Versión</a></li>
<li><a href="#formato-159">Formato</a></li>
<li><a href="#parámetros-140">Parámetros</a></li>
<li><a href="#ejemplos-112">Ejemplos</a></li>
</ul></li>
<li><a href="#restore">RESTORE</a>
<ul>
<li><a href="#versión-161">Versión</a></li>
<li><a href="#formato-160">Formato</a></li>
<li><a href="#parámetros-141">Parámetros</a></li>
<li><a href="#ejemplos-113">Ejemplos</a></li>
</ul></li>
<li><a href="#resume">RESUME</a>
<ul>
<li><a href="#versión-162">Versión</a></li>
<li><a href="#formato-161">Formato</a></li>
<li><a href="#parámetros-142">Parámetros</a></li>
<li><a href="#ejemplos-114">Ejemplos</a></li>
</ul></li>
<li><a href="#right">RIGHT$</a>
<ul>
<li><a href="#versión-163">Versión</a></li>
<li><a href="#formato-162">Formato</a></li>
<li><a href="#parámetros-143">Parámetros</a></li>
<li><a href="#retorno-37">Retorno</a></li>
<li><a href="#ejemplos-115">Ejemplos</a></li>
</ul></li>
<li><a href="#rnd">RND</a>
<ul>
<li><a href="#versión-164">Versión</a></li>
<li><a href="#formato-163">Formato</a></li>
<li><a href="#parámetros-144">Parámetros</a></li>
<li><a href="#retorno-38">Retorno</a></li>
<li><a href="#ejemplos-116">Ejemplos</a></li>
</ul></li>
<li><a href="#rset">RSET</a>
<ul>
<li><a href="#versión-165">Versión</a></li>
<li><a href="#formato-164">Formato</a></li>
<li><a href="#parámetros-145">Parámetros</a></li>
<li><a href="#ejemplos-117">Ejemplos</a></li>
</ul></li>
<li><a href="#run">RUN</a>
<ul>
<li><a href="#versión-166">Versión</a></li>
<li><a href="#formato-165">Formato</a></li>
<li><a href="#parámetros-146">Parámetros</a></li>
</ul></li>
<li><a href="#save">SAVE</a>
<ul>
<li><a href="#versión-167">Versión</a></li>
<li><a href="#formato-166">Formato</a></li>
<li><a href="#parámetros-147">Parámetros</a></li>
<li><a href="#ejemplos-118">Ejemplos</a></li>
</ul></li>
<li><a href="#screen">SCREEN</a>
<ul>
<li><a href="#versión-168">Versión</a></li>
<li><a href="#formato-167">Formato</a></li>
<li><a href="#parámetros-148">Parámetros</a></li>
<li><a href="#ejemplos-119">Ejemplos</a></li>
</ul></li>
<li><a href="#set-adjust">SET ADJUST</a>
<ul>
<li><a href="#versión-169">Versión</a></li>
<li><a href="#formato-168">Formato</a></li>
<li><a href="#parámetros-149">Parámetros</a></li>
<li><a href="#ejemplos-120">Ejemplos</a></li>
</ul></li>
<li><a href="#set-beep">SET BEEP</a>
<ul>
<li><a href="#versión-170">Versión</a></li>
<li><a href="#formato-169">Formato</a></li>
<li><a href="#parámetros-150">Parámetros</a></li>
</ul></li>
<li><a href="#set-date">SET DATE</a>
<ul>
<li><a href="#versión-171">Versión</a></li>
<li><a href="#formato-170">Formato</a></li>
<li><a href="#parámetros-151">Parámetros</a></li>
<li><a href="#ejemplos-121">Ejemplos</a></li>
</ul></li>
<li><a href="#set-page">SET PAGE</a>
<ul>
<li><a href="#versión-172">Versión</a></li>
<li><a href="#formato-171">Formato</a></li>
<li><a href="#parámetros-152">Parámetros</a></li>
<li><a href="#ejemplos-122">Ejemplos</a></li>
</ul></li>
<li><a href="#set-password">SET PASSWORD</a>
<ul>
<li><a href="#versión-173">Versión</a></li>
<li><a href="#formato-172">Formato</a></li>
<li><a href="#parámetros-153">Parámetros</a></li>
</ul></li>
<li><a href="#set-prompt">SET PROMPT</a>
<ul>
<li><a href="#versión-174">Versión</a></li>
<li><a href="#formato-173">Formato</a></li>
<li><a href="#parámetros-154">Parámetros</a></li>
</ul></li>
<li><a href="#set-screen">SET SCREEN</a>
<ul>
<li><a href="#versión-175">Versión</a></li>
<li><a href="#formato-174">Formato</a></li>
</ul></li>
<li><a href="#set-scroll">SET SCROLL</a>
<ul>
<li><a href="#versión-176">Versión</a></li>
<li><a href="#formato-175">Formato</a></li>
<li><a href="#parámetros-155">Parámetros</a></li>
<li><a href="#ejemplos-123">Ejemplos</a></li>
</ul></li>
<li><a href="#set-time">SET TIME</a>
<ul>
<li><a href="#versión-177">Versión</a></li>
<li><a href="#formato-176">Formato</a></li>
<li><a href="#parámetros-156">Parámetros</a></li>
<li><a href="#ejemplos-124">Ejemplos</a></li>
</ul></li>
<li><a href="#set-title">SET TITLE</a>
<ul>
<li><a href="#versión-178">Versión</a></li>
<li><a href="#formato-177">Formato</a></li>
<li><a href="#parámetros-157">Parámetros</a></li>
<li><a href="#ejemplos-125">Ejemplos</a></li>
</ul></li>
<li><a href="#set-video">SET VIDEO</a>
<ul>
<li><a href="#versión-179">Versión</a></li>
<li><a href="#formato-178">Formato</a></li>
<li><a href="#parámetros-158">Parámetros</a></li>
</ul></li>
<li><a href="#sgn">SGN</a>
<ul>
<li><a href="#versión-180">Versión</a></li>
<li><a href="#formato-179">Formato</a></li>
<li><a href="#parámetros-159">Parámetros</a></li>
<li><a href="#retorno-39">Retorno</a></li>
<li><a href="#ejemplos-126">Ejemplos</a></li>
</ul></li>
<li><a href="#sin">SIN</a>
<ul>
<li><a href="#versión-181">Versión</a></li>
<li><a href="#formato-180">Formato</a></li>
<li><a href="#parámetros-160">Parámetros</a></li>
<li><a href="#retorno-40">Retorno</a></li>
<li><a href="#ejemplos-127">Ejemplos</a></li>
</ul></li>
<li><a href="#sound">SOUND</a>
<ul>
<li><a href="#versión-182">Versión</a></li>
<li><a href="#formato-181">Formato</a></li>
<li><a href="#parámetros-161">Parámetros</a></li>
<li><a href="#ejemplos-128">Ejemplos</a></li>
</ul></li>
<li><a href="#space">SPACE$</a>
<ul>
<li><a href="#versión-183">Versión</a></li>
<li><a href="#formato-182">Formato</a></li>
<li><a href="#parámetros-162">Parámetros</a></li>
<li><a href="#retorno-41">Retorno</a></li>
<li><a href="#ejemplos-129">Ejemplos</a></li>
</ul></li>
<li><a href="#spc">SPC</a>
<ul>
<li><a href="#versión-184">Versión</a></li>
<li><a href="#formato-183">Formato</a></li>
<li><a href="#parámetros-163">Parámetros</a></li>
<li><a href="#retorno-42">Retorno</a></li>
<li><a href="#ejemplos-130">Ejemplos</a></li>
</ul></li>
<li><a href="#sprite-onsprite-offsprite-stop">SPRITE ON/SPRITE OFF/SPRITE STOP</a>
<ul>
<li><a href="#versión-185">Versión</a></li>
<li><a href="#formato-184">Formato</a></li>
</ul></li>
<li><a href="#sprite">SPRITE$</a>
<ul>
<li><a href="#versión-186">Versión</a></li>
<li><a href="#formato-185">Formato</a></li>
<li><a href="#parámetros-164">Parámetros</a></li>
<li><a href="#ejemplo-10">Ejemplo</a></li>
</ul></li>
<li><a href="#sqr">SQR</a>
<ul>
<li><a href="#versión-187">Versión</a></li>
<li><a href="#formato-186">Formato</a></li>
<li><a href="#parámetros-165">Parámetros</a></li>
<li><a href="#retorno-43">Retorno</a></li>
<li><a href="#ejemplos-131">Ejemplos</a></li>
</ul></li>
<li><a href="#stick">STICK</a>
<ul>
<li><a href="#versión-188">Versión</a></li>
<li><a href="#formato-187">Formato</a></li>
<li><a href="#parámetros-166">Parámetros</a></li>
<li><a href="#retorno-44">Retorno</a></li>
<li><a href="#ejemplos-132">Ejemplos</a></li>
</ul></li>
<li><a href="#stop">STOP</a>
<ul>
<li><a href="#versión-189">Versión</a></li>
<li><a href="#formato-188">Formato</a></li>
</ul></li>
<li><a href="#stop-onstop-offstop-stop">STOP ON/STOP OFF/STOP STOP</a>
<ul>
<li><a href="#versión-190">Versión</a></li>
<li><a href="#formato-189">Formato</a></li>
</ul></li>
<li><a href="#strig">STRIG</a>
<ul>
<li><a href="#versión-191">Versión</a></li>
<li><a href="#formato-190">Formato</a></li>
<li><a href="#parámetros-167">Parámetros</a></li>
<li><a href="#retorno-45">Retorno</a></li>
<li><a href="#ejemplos-133">Ejemplos</a></li>
</ul></li>
<li><a href="#strig-onstrig-offstrig-stop">STRIG ON/STRIG OFF/STRIG STOP</a>
<ul>
<li><a href="#versión-192">Versión</a></li>
<li><a href="#formato-191">Formato</a></li>
<li><a href="#parámetros-168">Parámetros</a></li>
<li><a href="#ejemplos-134">Ejemplos</a></li>
</ul></li>
<li><a href="#str">STR$</a>
<ul>
<li><a href="#versión-193">Versión</a></li>
<li><a href="#formato-192">Formato</a></li>
<li><a href="#parámetros-169">Parámetros</a></li>
<li><a href="#retorno-46">Retorno</a></li>
<li><a href="#ejemplos-135">Ejemplos</a></li>
</ul></li>
<li><a href="#string">STRING$</a>
<ul>
<li><a href="#versión-194">Versión</a></li>
<li><a href="#formato-193">Formato</a></li>
<li><a href="#parámetros-170">Parámetros</a></li>
<li><a href="#retorno-47">Retorno</a></li>
<li><a href="#ejemplos-136">Ejemplos</a></li>
</ul></li>
<li><a href="#swap">SWAP</a>
<ul>
<li><a href="#versión-195">Versión</a></li>
<li><a href="#formato-194">Formato</a></li>
<li><a href="#parámetros-171">Parámetros</a></li>
<li><a href="#ejemplos-137">Ejemplos</a></li>
</ul></li>
<li><a href="#tab">TAB</a>
<ul>
<li><a href="#versión-196">Versión</a></li>
<li><a href="#formato-195">Formato</a></li>
<li><a href="#parámetros-172">Parámetros</a></li>
<li><a href="#ejemplos-138">Ejemplos</a></li>
</ul></li>
<li><a href="#tan">TAN</a>
<ul>
<li><a href="#versión-197">Versión</a></li>
<li><a href="#formato-196">Formato</a></li>
<li><a href="#parámetros-173">Parámetros</a></li>
<li><a href="#retorno-48">Retorno</a></li>
<li><a href="#ejemplos-139">Ejemplos</a></li>
</ul></li>
<li><a href="#time">TIME</a>
<ul>
<li><a href="#versión-198">Versión</a></li>
<li><a href="#formato-197">Formato</a></li>
<li><a href="#parámetros-174">Parámetros</a></li>
<li><a href="#ejemplos-140">Ejemplos</a></li>
</ul></li>
<li><a href="#troff">TROFF</a>
<ul>
<li><a href="#versión-199">Versión</a></li>
<li><a href="#formato-198">Formato</a></li>
</ul></li>
<li><a href="#tron">TRON</a>
<ul>
<li><a href="#versión-200">Versión</a></li>
<li><a href="#formato-199">Formato</a></li>
<li><a href="#ejemplos-141">Ejemplos</a></li>
</ul></li>
<li><a href="#usr">USR</a>
<ul>
<li><a href="#versión-201">Versión</a></li>
<li><a href="#formato-200">Formato</a></li>
<li><a href="#parámetros-175">Parámetros</a></li>
<li><a href="#retorno-49">Retorno</a></li>
<li><a href="#ejemplos-142">Ejemplos</a></li>
</ul></li>
<li><a href="#val">VAL</a>
<ul>
<li><a href="#versión-202">Versión</a></li>
<li><a href="#formato-201">Formato</a></li>
<li><a href="#parámetros-176">Parámetros</a></li>
<li><a href="#retorno-50">Retorno</a></li>
<li><a href="#ejemplos-143">Ejemplos</a></li>
</ul></li>
<li><a href="#varptr-1">VARPTR (1)</a>
<ul>
<li><a href="#versión-203">Versión</a></li>
<li><a href="#formato-202">Formato</a></li>
<li><a href="#parámetros-177">Parámetros</a></li>
<li><a href="#retorno-51">Retorno</a></li>
<li><a href="#ejemplos-144">Ejemplos</a></li>
</ul></li>
<li><a href="#varptr-2">VARPTR (2)</a>
<ul>
<li><a href="#versión-204">Versión</a></li>
<li><a href="#formato-203">Formato</a></li>
<li><a href="#parámetros-178">Parámetros</a></li>
<li><a href="#retorno-52">Retorno</a></li>
</ul></li>
<li><a href="#vdp">VDP</a>
<ul>
<li><a href="#versión-205">Versión</a></li>
<li><a href="#formato-204">Formato</a></li>
<li><a href="#parámetros-179">Parámetros</a></li>
<li><a href="#ejemplos-145">Ejemplos</a></li>
</ul></li>
<li><a href="#vpeek">VPEEK</a>
<ul>
<li><a href="#versión-206">Versión</a></li>
<li><a href="#formato-205">Formato</a></li>
<li><a href="#parámetros-180">Parámetros</a></li>
<li><a href="#retorno-53">Retorno</a></li>
<li><a href="#ejemplos-146">Ejemplos</a></li>
</ul></li>
<li><a href="#vpoke">VPOKE</a>
<ul>
<li><a href="#versión-207">Versión</a></li>
<li><a href="#formato-206">Formato</a></li>
<li><a href="#parámetros-181">Parámetros</a></li>
</ul></li>
<li><a href="#wait">WAIT</a>
<ul>
<li><a href="#versión-208">Versión</a></li>
<li><a href="#formato-207">Formato</a></li>
<li><a href="#parámetros-182">Parámetros</a></li>
</ul></li>
<li><a href="#width">WIDTH</a>
<ul>
<li><a href="#versión-209">Versión</a></li>
<li><a href="#formato-208">Formato</a></li>
<li><a href="#parámetros-183">Parámetros</a></li>
<li><a href="#ejemplos-147">Ejemplos</a></li>
</ul></li>
<li><a href="#mensajes-de-error">MENSAJES DE ERROR</a></li>
</ul></li>
<li><a href="#vr-dos">VR-DOS</a></li>
<li><a href="#qué-es-vr-dos">¿Qué es VR-DOS?</a></li>
<li><a href="#editando-comandos">Editando comandos</a></li>
<li><a href="#notación-de-los-comandos">Notación de los comandos</a>
<ul>
<li><a href="#as">AS</a></li>
<li><a href="#assign">ASSIGN</a></li>
<li><a href="#atdir">ATDIR</a></li>
<li><a href="#attrib">ATTRIB</a></li>
<li><a href="#basic">BASIC</a></li>
<li><a href="#buffers">BUFFERS</a></li>
<li><a href="#chdir-cd">CHDIR / CD</a></li>
<li><a href="#chkdsk">CHKDSK</a></li>
<li><a href="#cls-1">CLS</a></li>
<li><a href="#command2">COMMAND2</a></li>
<li><a href="#concat">CONCAT</a></li>
<li><a href="#config">CONFIG</a></li>
<li><a href="#copy-2">COPY</a></li>
<li><a href="#color-1">COLOR</a></li>
<li><a href="#date">DATE</a></li>
<li><a href="#dir">DIR</a></li>
<li><a href="#diskcopy">DISKCOPY</a></li>
<li><a href="#dsktool">DSKTOOL</a></li>
<li><a href="#echo">ECHO</a></li>
<li><a href="#edit">EDIT</a></li>
<li><a href="#era-erase-del">ERA / ERASE / DEL</a></li>
<li><a href="#exit">EXIT</a></li>
<li><a href="#fixdisk">FIXDISK</a></li>
<li><a href="#format">FORMAT</a></li>
<li><a href="#gr-geekreader">GR <span>GeekReader</span></a></li>
<li><a href="#help">HELP</a></li>
<li><a href="#history">HISTORY</a></li>
<li><a href="#kill-1">KILL</a></li>
<li><a href="#md-mkdir">MD / MKDIR</a></li>
<li><a href="#mode">MODE</a></li>
<li><a href="#move">MOVE</a></li>
<li><a href="#mvdir">MVDIR</a></li>
<li><a href="#mount">MOUNT</a></li>
<li><a href="#path-1">PATH</a></li>
<li><a href="#net">NET</a></li>
<li><a href="#pause">PAUSE</a></li>
<li><a href="#play-2">PLAY</a></li>
<li><a href="#pkg">PKG</a></li>
<li><a href="#ramdisk">RAMDISK</a></li>
<li><a href="#rem-1">REM</a></li>
<li><a href="#ren-rename">REN / RENAME</a></li>
<li><a href="#reset">RESET</a></li>
<li><a href="#rmdir-rd">RMDIR / RD</a></li>
<li><a href="#rndir">RNDIR</a></li>
<li><a href="#set">SET</a></li>
<li><a href="#stop-1">STOP</a></li>
<li><a href="#time-1">TIME</a></li>
<li><a href="#type">TYPE</a></li>
<li><a href="#undel">UNDEL</a></li>
<li><a href="#ver">VER</a></li>
<li><a href="#verify">VERIFY</a></li>
<li><a href="#vol">VOL</a></li>
<li><a href="#wget">WGET</a></li>
<li><a href="#xdir">XDIR</a></li>
<li><a href="#ziptool">ZIPTOOL</a></li>
</ul></li>
<li><a href="#redirección">Redirección</a></li>
<li><a href="#tuberías">Tuberías</a></li>
<li><a href="#archivos-de-procesamiento-por-lotes">Archivos de procesamiento por lotes</a></li>
<li><a href="#variables-de-entorno">Variables de entorno</a></li>
<li><a href="#códigos-de-error">Códigos de error</a></li>
<li><a href="#mensajes-del-prompt">Mensajes del prompt</a>
<ul>
<li><a href="#vr-script">VR-SCRIPT</a></li>
</ul></li>
<li><a href="#qué-es-vr-script">¿Qué es VR-SCRIPT?</a></li>
<li><a href="#palabras-reservadas">Palabras reservadas</a></li>
<li><a href="#estructura-del-archivo">Estructura del archivo</a></li>
<li><a href="#tipos">Tipos</a></li>
<li><a href="#propiedades">Propiedades</a>
<ul>
<li><a href="#variables-y-constantes-globales">Variables y constantes globales</a></li>
<li><a href="#properties-y-constants">Properties y Constants</a></li>
<li><a href="#locales">Locales</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#acceso-por-nombre-a-propiedades">Acceso por nombre a propiedades</a></li>
</ul></li>
<li><a href="#funciones-1">Funciones</a>
<ul>
<li><a href="#polimorfismo">Polimorfismo</a></li>
<li><a href="#virtuales">Virtuales</a></li>
<li><a href="#llamada-a-funciones-por-nombre">Llamada a funciones por nombre</a></li>
<li><a href="#funciones-ocultas">Funciones ocultas</a></li>
</ul></li>
<li><a href="#el-preprocesador">El preprocesador</a></li>
<li><a href="#pragmas">Pragmas</a></li>
<li><a href="#operadores-1">Operadores</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#listas">Listas</a></li>
<li><a href="#diccionarios">Diccionarios</a></li>
<li><a href="#estructuras-de-control">Estructuras de control</a>
<ul>
<li><a href="#if---else-if---else">IF - ELSE IF - ELSE</a></li>
<li><a href="#while">WHILE</a></li>
<li><a href="#do-while">DO-WHILE</a></li>
<li><a href="#for">FOR</a></li>
<li><a href="#switch">SWITCH</a></li>
<li><a href="#repeat">REPEAT</a></li>
<li><a href="#break-continue">BREAK, CONTINUE</a></li>
</ul></li>
<li><a href="#creación-y-borrado-de-instancias">Creación y borrado de instancias</a></li>
<li><a href="#herencia-de-clases">Herencia de clases</a></li>
<li><a href="#partials">Partials</a></li>
<li><a href="#máquina-de-estados">Máquina de estados</a></li>
<li><a href="#evaluación-de-expresiones-al-vuelo">Evaluación de expresiones al vuelo</a></li>
<li><a href="#ejecución-de-código-al-vuelo">Ejecución de código al vuelo</a></li>
<li><a href="#sobrecarga-de-operadores">Sobrecarga de operadores</a></li>
<li><a href="#optimizaciones">Optimizaciones</a></li>
<li><a href="#definición-de-funciones-con-número-de-parámetros-indefinido">Definición de funciones con número de parámetros indefinido</a></li>
<li><a href="#instanceof">Instanceof</a></li>
<li><a href="#implements">Implements</a></li>
<li><a href="#acceso-al-engine-del-sistema">Acceso al Engine del sistema</a>
<ul>
<li><a href="#directorios">Directorios</a></li>
<li><a href="#ethernet">Ethernet</a></li>
<li><a href="#wifi">WIFI</a></li>
<li><a href="#httpmanager">HTTPManager</a></li>
<li><a href="#config-1">Config</a></li>
<li><a href="#registro">Registro</a></li>
<li><a href="#carpetas">Carpetas</a></li>
<li><a href="#archivos">Archivos</a></li>
<li><a href="#programas">Programas</a></li>
<li><a href="#geekreader">GeekReader</a></li>
<li><a href="#máquinas-virtuales">Máquinas Virtuales</a></li>
<li><a href="#imágenes">Imágenes</a></li>
<li><a href="#localización-idiomas">Localización / Idiomas</a></li>
<li><a href="#logger">Logger</a></li>
<li><a href="#notificaciones">Notificaciones</a></li>
<li><a href="#vídeo">Vídeo</a></li>
<li><a href="#audio">Audio</a></li>
<li><a href="#temas">Temas</a></li>
<li><a href="#encendido-y-apagado">Encendido y apagado</a></li>
<li><a href="#user">User</a></li>
<li><a href="#time-3">Time</a></li>
</ul></li>
<li><a href="#programar-una-aplicación-vr-dos">Programar una aplicación VR-DOS</a></li>
<li><a href="#programar-una-aplicación-vr-view">Programar una aplicación VR-VIEW</a>
<ul>
<li><a href="#el-desktop">El Desktop</a></li>
<li><a href="#ventanas-de-aplicación">Ventanas de Aplicación</a></li>
<li><a href="#ventanas-mdi">Ventanas MDI</a></li>
<li><a href="#menús">Menús</a></li>
<li><a href="#eventos">Eventos</a></li>
<li><a href="#controles">Controles</a></li>
<li><a href="#frame">Frame</a></li>
<li><a href="#scrollframe">ScrollFrame</a></li>
<li><a href="#button">Button</a></li>
<li><a href="#checkbox">CheckBox</a></li>
<li><a href="#colorpicker">ColorPicker</a></li>
<li><a href="#combobox">ComboBox</a></li>
<li><a href="#image">Image</a></li>
<li><a href="#listbox">ListBox</a></li>
<li><a href="#progressbar">ProgressBar</a></li>
<li><a href="#richtexteditor">RichTextEditor</a></li>
<li><a href="#scrollbar">ScrollBar</a></li>
<li><a href="#spin">Spin</a></li>
<li><a href="#textbox">TextBox</a></li>
<li><a href="#toolbar">ToolBar</a></li>
<li><a href="#trackbar">TrackBar</a></li>
<li><a href="#diálogos-genéricos">Diálogos genéricos</a></li>
</ul></li>
<li><a href="#programar-una-aplicación-vr-basic">Programar una aplicación VR-BASIC</a></li>
<li><a href="#programar-una-aplicación-vr-gl">Programar una aplicación VR-GL</a>
<ul>
<li><a href="#gl_program">GL_Program</a></li>
<li><a href="#gl_object">GL_Object</a></li>
<li><a href="#gl_stage">GL_Stage</a></li>
<li><a href="#gl_sprite">GL_Sprite</a></li>
<li><a href="#gl_mapper">GL_Mapper</a></li>
<li><a href="#gl_music-y-gl_sound">GL_Music y GL_Sound</a></li>
<li><a href="#gl_route">GL_Route</a></li>
<li><a href="#gl_text">GL_Text</a></li>
<li><a href="#gl_timer">GL_Timer</a></li>
<li><a href="#gl_collider">GL_Collider</a></li>
<li><a href="#gl_controller">GL_Controller</a></li>
<li><a href="#gl_pad">GL_Pad</a></li>
</ul></li>
<li><a href="#uso-de-vr-script-para-generar-código-asm">Uso de VR-SCRIPT para generar código ASM</a></li>
<li><a href="#programación-del-v9968">Programación del V9968</a></li>
<li><a href="#programación-del-r8000">Programación del R8000</a></li>
<li><a href="#funciones-del-api-nativo">Funciones del API Nativo</a>
<ul>
<li><a href="#casting">Casting</a></li>
<li><a href="#matemáticas-1">Matemáticas</a></li>
<li><a href="#matemáticas-avanzadas-2d-y-3d">Matemáticas Avanzadas 2D y 3D</a></li>
<li><a href="#buffer">Buffer</a></li>
<li><a href="#string-1">String</a></li>
<li><a href="#color-2">Color</a></li>
<li><a href="#container">Container</a></li>
<li><a href="#xml">XML</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#database">Database</a></li>
<li><a href="#crypto">Crypto</a></li>
<li><a href="#dictionary">Dictionary</a></li>
<li><a href="#netsocket">NetSocket</a></li>
<li><a href="#regex">RegEx</a></li>
<li><a href="#timer">Timer</a></li>
<li><a href="#systime">SysTime</a></li>
<li><a href="#zip">ZIP</a></li>
<li><a href="#file">File</a></li>
<li><a href="#texture">Texture</a></li>
<li><a href="#serial">Serial</a></li>
<li><a href="#miscelánea">Miscelánea</a></li>
</ul></li>
<li><a href="#constantes-de-teclado">Constantes de teclado</a></li>
<li><a href="#ejemplos-148">Ejemplos</a>
<ul>
<li><a href="#hola-mundo-en-vr-dos">Hola mundo en VR-DOS</a></li>
<li><a href="#hola-mundo-en-vr-view">Hola mundo en VR-VIEW</a></li>
<li><a href="#hola-mundo-en-vr-basic">Hola mundo en VR-BASIC</a></li>
<li><a href="#detectar-un-cartucho-opl4-en-alguna-de-las-ranuras">Detectar un cartucho OPL4 en alguna de las ranuras</a></li>
<li><a href="#detectar-un-cartucho-fmpacmsxmusic-en-alguna-de-las-ranuras">Detectar un cartucho FMPAC/MSX‑MUSIC en alguna de las ranuras</a></li>
<li><a href="#pelotas-rebotonas-en-vr-gl">Pelotas Rebotonas en VR-GL</a></li>
</ul></li>
</ul>
</nav>
<p>MANUAL DE PROGRAMACIÓN</p>
<p><strong>MSXVR</strong></p>
<h1 id="editorial">Editorial</h1>
<p>MSX, MSX2, MSX2+, MSXturboR y MSX-DOS son marcas registradas de MSX Association / MSX Licensing Corporation.</p>
<p>MSX-BASIC es una marca registrada de Microsoft Corporation.</p>
<p>MSXVR es una marca registrada de VIKALB PROGRAMMING S.L.</p>
<p>© 2020 VIKALB PROGRAMMING S.L.</p>
<p>Autor: Alberto De Hoyo Nebot</p>
<p>1ª Edición: 2020 - Revisión 8</p>
<p>Derechos de edición reservados.</p>
<p>A pesar del cuidado con que ha sido compuesto el texto, ni la redacción ni el editor aceptarán responsabilidad alguna por los daños que eventualmente pudieran derivarse de algún error que pudiese contener esta edición.</p>
<p>Ninguna parte de este libro podrá ser reproducida, ni impresa, ni fotografiada, ni microfilmada, ni copiada digitalmente, ni analógicamente ni con cualquier otro método existente, sin el permiso del editor.</p>
<h1 id="prólogo">Prólogo</h1>
<p>Detrás de un MSXVR se encuentra escondido todo un mundo, un mundo que está determinado por una gran cantidad de marcas diferentes de ordenadores de 8 bits que, curiosamente, comparten más similitudes que diferencias. En este caso, MSXVR es una máquina compatible con la norma MSX y su intención es la de querer preservarla en el tiempo.</p>
<p>El proyecto MSXVR pretende dar a conocer la informática clásica de los años 80-90, ampliando su potencial, pero conservando su esencia básica, la de disponer de todo un sistema computacional con el que comunicarte, aprender, desarrollar y jugar desde el primer momento en el que el sistema se inicia.</p>
<p>MSXVR anhela acercar a los nuevos usuarios y a los nostálgicos toda una nueva forma de entender la informática. Forma que se ha ido perdiendo con los años debido en parte a la gran evolución de la tecnología en tan poco tiempo y a la potencia de los nuevos ordenadores. Querer simplificar la manera de comunicarse con el ordenador reduce finalmente nuestro propio potencial y nos hace perder la verdadera esencia de la informática. Querer simplificar nos hace querer ir deprisa, querer llegar antes de tiempo, no abordar los detalles y, al final, no aprender y disfrutar.</p>
<p>Toda esta problemática ha llevado a que la calidad de la programación baje drásticamente en los últimos años. La programación, como tal, apenas existe, ya que todo deriva en procesos automáticos, en aplicaciones drag &amp; drop<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> y otra serie de herramientas que, sugieren que “programar” es simple y fácil. Cualquiera puede hacerlo. Sin embargo, ese concepto de “programación” incurre en precisamente lo contrario.</p>
<p>Programar requiere paciencia, ir poco a poco y subir de nivel a medida que se consiguen los objetivos, para lo cual hay que dedicar tiempo. Cuanto más tiempo dediques más rápido progresarás. Para aprender a programar se debe comenzar por el principio. Así como a un niño cuando aprende a leer, no le das El Quijote, del mismo modo hay que acercarse a la programación desde un modelo más sencillo. El mismo que desarrollaron los primeros informáticos que quisieron acercar la programación y la computación a los hogares de la gente.</p>
<p>Con este manual, pretendemos que viva de nuevo la informática clásica y que, si un usuario que no la conoce, pueda conocerla y disfrutarla. Desde el primer momento en el que enciende su ordenador MSXVR, arranca el DOS. Y el DOS ya escucha sus comandos, espera que hable con el ordenador a través de su teclado. A través del DOS podrá ir conociendo todas las sorpresas que aguardan en su máquina y le podemos asegurar ¡¡que no son pocas!!</p>
<p>Esperamos que disfrute de la experiencia y le merezca la pena.</p>
<p><em>A todos los “PRIMEROS”, los que habéis participado en el primer lote de unidades con vuestras reservas, los que habéis permitido que este proyecto pueda salir a la luz. El mayor de los agradecimientos por nuestra parte, y que aquí quede por escrito.</em></p>
<p><em>¡MUCHAS GRACIAS!</em></p>
<h1 id="qué-es-un-msxvr">¿Qué es un MSXVR?</h1>
<p>Es un ordenador de aspecto retro que intenta recrear el espíritu de los ordenadores clásicos de las décadas de los 80 y 90.</p>
<p>En este caso, no solo intenta asemejarse en aspecto, sino también en filosofía de trabajo e interacción con la máquina.</p>
<p>MSXVR es una máquina compatible MSX<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> a todos los niveles, pero también lo es con otras máquinas que compartieron época con el mismo ordenador: ZX Spectrum, Amstrad CPC, Commodore 64 y otras tantas que van sumándose a la lista de posibles personalizaciones.</p>
<p>Este ordenador, además, dispone de una serie de conexiones que le van a permitir inventar y crear más allá de lo que sus conocimientos de programación le permitan. No solo va a poder conectar sus propios dispositivos MSX, sino que podrá conectar otros diseñados por usted mismo o por terceros para controlar robots, juguetes electrónicos, estaciones meteorológicas, sensores para el cuidado de la salud, teclados musicales, unidades de disco, impresoras, etc.</p>
<p>El ordenador viene acompañado de un sistema operativo y un conjunto de herramientas para poder desarrollar juegos y aplicaciones en diferentes lenguajes y para distintos sistemas. Incorpora herramientas para navegar por Internet, dibujar, crear música, etc. En definitiva, pretende ofrecer una estación de trabajo completa para poder no solo disfrutar de desarrollos terceros, sino también de los suyos propios.</p>
<h1 id="concepto-y-términos">Concepto y Términos</h1>
<p>El concepto del MSXVR se basa en su independencia con el huésped donde se encuentra. El planteamiento es que el mismo software pueda evolucionar/adaptarse en diferentes entornos. De este modo se puede garantizar la supervivencia del software a través del tiempo mediante posteriores revisiones del hardware que mejoren la potencia y características de la máquina.</p>
<p><em>Términos:</em></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>SISTEMA OPERATIVO BASE</th>
<th>Es el sistema operativo que inicia el ordenador. Por ejemplo: Un Linux, Android, Windows o uno creado ad hoc para un FPGA.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>APLICACIÓN MSXVR</td>
<td>Es una aplicación nativa creada para el Sistema Operativo Base.</td>
</tr>
<tr class="even">
<td>NATIVE ENGINE</td>
<td>Hace referencia al conjunto de librerías nativas, compatibles con el Sistema Operativo Base y con un interfaz accesible mediante VR‑SCRIPT.</td>
</tr>
<tr class="odd">
<td>APLICACIÓN VR-SCRIPT</td>
<td>Es una aplicación programada íntegramente en VR‑SCRIPT.</td>
</tr>
<tr class="even">
<td>VR-OS</td>
<td>Hace referencia al sistema operativo creado en VR-SCRIPT y que define la interfaz entre el usuario y el ordenador.</td>
</tr>
<tr class="odd">
<td>VR-ENGINE</td>
<td>Espina dorsal desde la cual las aplicaciones pueden acceder a todas las partes de VR-OS.</td>
</tr>
<tr class="even">
<td>VR-BASIC</td>
<td>Aplicación VR-SCRIPT que simula diferentes implementaciones del MSX-BASIC.</td>
</tr>
<tr class="odd">
<td>VR-DOS</td>
<td>Aplicación VR-SCRIPT con apariencia similar al MSX-DOS y que permite interactuar mediante comandos.</td>
</tr>
</tbody>
</table>
<h2 id="vr-basic">VR-BASIC</h2>
<h2 id="qué-es-vr-basic">¿Qué es VR-BASIC?</h2>
<p>VR-BASIC es un intérprete de comandos compatible con MSX-BASIC. Aporta nuevas funcionalidades, pero sigue manteniendo la sencillez del BASIC original que poseían las máquinas de los años 80-90.</p>
<h4 id="la-consola">La consola</h4>
<pre><code>VR-BASIC version 1.0
Copyright MSXVR Team 2013-2017
3674453345 bytes free
Ok</code></pre>
<p><img src="media/a551340073138dc908b639573821e6b4.png" /></p>
<p>El VR-BASIC se presenta de esta forma, indicando su versión y esperando a que el usuario introduzca instrucciones desde la posición del cursor intermitente. Para introducir comandos hemos de escribir cosas que el VR-BASIC entienda: si las entiende nos dirá que todo ha ido OK, pero si no es así nos dará un mensaje de error.</p>
<p>Para introducir comandos usaremos la tecla retorno (ENTER). Primero escribiremos el comando o la instrucción y seguidamente esta tecla.</p>
<p>Por ejemplo, escriba CLS y pulse la tecla ENTER: verá que la pantalla se limpia y posteriormente aparecerá OK en la parte superior. Efectivamente, CLS (<em>clear screen</em> en inglés) es un comando que sirve para borrar el contenido completo de la pantalla, situando el cursor en la posición más arriba y a la izquierda.</p>
<p>Le instamos a que teclee otra instrucción; por ejemplo, un nombre:</p>
<pre><code>DANIEL
Syntax Error
Ok</code></pre>
<p>En este caso, no se reconoce DANIEL como ninguna instrucción válida, y se nos avisa con un error de sintaxis por pantalla.</p>
<h5 id="teclas-de-función">Teclas de función</h5>
<p><img src="media/bde4055d32a4a39d9d14b41d500c1cd6.png" /></p>
<p><img src="media/698185e4be1fc7acec41e5f4f5cab2d7.png" /></p>
<p>Puede observar que en la parte de abajo de la pantalla hay 5 palabras, ¿Qué son? Pues bien, es texto asociado a cada tecla de función (F1 al F5).</p>
<p>En este caso, el texto son instrucciones VR-BASIC más o menos comunes. Si pulsa la tecla Mayúsculas (SHIFT) verá que salen otros textos: eso es porque esta tecla se puede combinar al mismo tiempo con las de función.</p>
<h2 id="texto">Texto</h2>
<p>Existen dos comandos muy importantes y posiblemente, sean de los más utilizados en este lenguaje. Estos comandos son PRINT e INPUT. Una pequeña descripción:</p>
<p><strong>PRINT</strong>: Visualiza datos numéricos o alfanuméricos en la pantalla en modo texto.</p>
<p><strong>INPUT</strong>: Acepta datos introducidos desde el teclado y los asigna a una variable.</p>
<p>Estos comandos están ampliamente documentados en el apartado de “<em>Lista de comandos y funciones</em>”.</p>
<p>Estos dos comandos se pueden usar de modo directo en VR-BASIC, es decir, que los podemos escribir directamente y pulsar ENTER para ejecutarlos:</p>
<div class="line-block">PRINT “Esto es un ejemplo” | | Muestra en pantalla el texto introducido entre comillas. |<br />
Esto es un ejemplo | | |<br />
Ok | | |</div>
<p>|————————————————|—|—————————————————————–| | INPUT A | | Introducimos un valor numérico para la variable A. | | ? 4 | | | | Ok | | | | PRINT A | | Muestra el contenido de la variable A. | | 4 | | | | Ok | | | | INPUT A$ | | Introducimos un valor alfanumérico para la variable A$. | | ? Hola | | | | Ok | | | | PRINT A$ | | Muestra el contenido de la variable A$. | | Hola | | | | Ok | | | | INPUT | | Si no indicamos una variable, obtendremos un error de sintaxis. | | ? Hola | | | | Syntax error | | |</p>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="constantes-y-variables">Constantes y Variables</h2>
<p>Conviene entender los conceptos de constante y variable. Una constante hace referencia a un valor que nunca va a cambiar: por ejemplo, el número 5. Siempre será el número 5, esto no va a cambiar. Es algo constante en el tiempo.</p>
<p><img src="media/ba7a7f7161fe71ed0f3177d85b0d4e0e.png" /></p>
<p>Sin embargo, una variable es como un cajón donde almacenamos constantes. O sea, valores concretos. Por tanto, una variable sí puede contener distintos valores a lo largo del tiempo.</p>
<p>Las variables en VR-BASIC se identifican con un nombre. Para el ordenador, esto supone reservar un espacio en su memoria. Quiere decirse con esto que el número de variables en un ordenador es finito y se termina. Todo dependerá de la cantidad de memoria que tenga. Para su tranquilidad, son bastantes las que puede usar.</p>
<p>Veamos cómo se define una variable: para ello utilizaremos la función <strong>LET</strong>.</p>
<pre><code>LET A = 5</code></pre>
<p>Así creamos nuestra variable A y le asignamos el número 5.</p>
<p>Si ahora hacemos:</p>
<pre><code>PRINT A
 5</code></pre>
<p>Efectivamente, vemos que se muestra su contenido. Por supuesto, podemos volver a cambiar el valor tantas veces como queramos. Pruebe a darle otro valor y lo verá:</p>
<pre><code>LET A = 12
PRINT A
 12</code></pre>
<p>Atención: en VR-BASIC las variables pueden tener el nombre que queramos, pero internamente solo se hace caso a las dos primeras letras. Quiere decirse que, si usamos la variable CONTADOR, es lo mismo que usar CO (el resto de letras se ignoran).</p>
<p>Otra curiosidad es que se puede omitir el uso de LET. Por tanto, podemos hacer:</p>
<pre><code>A = 12
PRINT A
 12</code></pre>
<p>Hasta ahora hemos asignado números enteros a las variables, pero también podemos asignar cadenas de texto (<em>strings</em> en su término inglés). Sin embargo, hay que distinguir estas variables mediante un símbolo.</p>
<pre><code>A$ = &quot;Hola&quot;
PRINT A$
Hola</code></pre>
<p>Efectivamente, el símbolo es el $ y sirve para diferenciar la variable como numérica o como cadena de texto. Para el VR-BASIC, A y A$ son dos variables distintas:</p>
<pre><code>A = 10
A$ = &quot;Casa&quot;
PRINT A
 10
PRINT A$
Casa</code></pre>
<p>Por defecto, en VR-BASIC, cuando trabajamos con números, estos usan un formato interno de doble precisión. Quiere decirse con esto que es un formato que usa más memoria para almacenar el número, además de que su manipulación le cuesta más tiempo al ordenador. Cierto es que al ser de doble precisión nos permite almacenar números con más dígitos y más grandes.</p>
<p>Sin embargo, como bien sabemos, el ordenador tiene limitaciones de memoria y de velocidad y a veces, como programadores, conviene ayudar al ordenador para conseguir que este pueda hacer funcionar mejor los programas. A esta tarea se la denomina <strong>Optimizar</strong>.</p>
<p>En VR-BASIC podemos indicar que queremos variables que almacenen números con formatos más pequeños y rápidos de gestionar. Estos formatos son los números de precisión simple y los números enteros.</p>
<p>Los más rápidos son los números enteros: no permiten usar decimales, pero son los más comunes a la hora de programar. Para indicar al VR-BASIC que queremos tener una variable de tipo entero y que use este tipo de número, aplicaremos el símbolo (%). Al igual que hacemos con las cadenas de caracteres, podemos indicar que una variable es entera así:</p>
<pre><code>A% = 5</code></pre>
<p>Del mismo modo, podemos indicar que una variable es de precisión simple con el símbolo (!):</p>
<pre><code>A! = 3.33</code></pre>
<p>NOTA: Aunque no sea necesario hacerlo, podemos indicar explícitamente que queremos usar valores de precisión doble usando el símbolo (#). Por ejemplo: A# = 10# / 3# vendría a ser lo mismo que A = 10 / 3</p>
<p>Ya que ahora sabemos que tenemos diferentes formatos de números, también conviene saber que los números enteros se pueden expresar de diferentes formas, refiriéndose todas ellas al mismo valor numérico. En VR-BASIC podemos expresar números enteros en formato <strong>Binario</strong>, <strong>Octal</strong>, <strong>Decimal</strong> y <strong>Hexadecimal</strong>.</p>
<p>Por ejemplo, el valor 32 en decimal corresponde al mismo número en:</p>
<ul>
<li><p><strong>&amp;B</strong>00100000 en binario</p></li>
<li><p><strong>&amp;O</strong>40 en octal</p></li>
<li><p><strong>&amp;H</strong>20 en hexadecimal</p></li>
</ul>
<p>Observe cómo utilizamos ciertos prefijos (&amp;B, &amp;O, &amp;H) para indicar si el número está siendo expresado en un formato u otro.</p>
<p>Un número decimal (BASE 10) es aquel que utiliza 10 dígitos (del 0 al 9) para representarse. Pues bien, un número binario (BASE 2) utiliza 2 dígitos (el 0 y el 1), uno en octal (BASE 8) utiliza 8 dígitos (del 0 al 7) y en hexadecimal (BASE 16) utiliza 16 dígitos (del 0 al 15).</p>
<p>NOTA: El binario es el formato más usado en informática debido a la forma de operar de los ordenadores. Los ordenadores trabajan internamente con ceros y unos. Según la corriente eléctrica que circula por los circuitos del ordenador, este entiende que le llegan unos o ceros.</p>
<p>Veamos cómo funciona esto de las bases, imagine el número 4736 en decimal:</p>
<table>
<thead>
<tr class="header">
<th>4</th>
<th>103 = 1000</th>
<th>4 x 1000 = 4000</th>
<th>4000</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>7</td>
<td>102 = 100</td>
<td>7 x 100 = 700</td>
<td>700</td>
</tr>
<tr class="even">
<td>3</td>
<td>101 = 10</td>
<td>3 x 10 = 30</td>
<td>30</td>
</tr>
<tr class="odd">
<td>6</td>
<td>100 = 1</td>
<td>6 x 1 = 6</td>
<td>6</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>SUMA</td>
<td><strong>4736</strong></td>
</tr>
</tbody>
</table>
<p>Ahora veamos cómo convertir &amp;B10101101 a decimal:</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>27 = 128</th>
<th>1 x 128</th>
<th>128</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>26 = 64</td>
<td>0 x 64</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>25 = 32</td>
<td>1 x 32</td>
<td>32</td>
</tr>
<tr class="odd">
<td>0</td>
<td>24 = 16</td>
<td>0 x 16</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>23 = 8</td>
<td>1 x 8</td>
<td>8</td>
</tr>
<tr class="odd">
<td>1</td>
<td>22 = 4</td>
<td>1 x 4</td>
<td>4</td>
</tr>
<tr class="even">
<td>0</td>
<td>21 = 2</td>
<td>0 x 2</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>20 = 1</td>
<td>1 x 1</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>SUMA</td>
<td><strong>173</strong></td>
</tr>
</tbody>
</table>
<p>Con la misma lógica podemos convertir números de octal y hexadecimal a decimal. Eso sí, debe saber que, en hexadecimal, los dígitos correspondientes a los valores decimales del 10 al 15 se escriben con las letras A, B, C, D, E, F respectivamente.</p>
<p>&amp;HFF es igual al número decimal 255 y al &amp;B11111111 en binario.</p>
<p>&amp;H0F es igual al número decimal 15 y al &amp;B00001111 en binario.</p>
<h2 id="expresiones">Expresiones</h2>
<p>Como parte de las expresiones consideraremos: constantes, variables, funciones y operadores.</p>
<h4 id="operadores-aritméticos">OPERADORES ARITMÉTICOS</h4>
<table>
<thead>
<tr class="header">
<th>Operador</th>
<th>Semántica</th>
<th>Ejemplo</th>
<th>Prioridad</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>Suma</td>
<td>X + Y</td>
<td>6</td>
</tr>
<tr class="even">
<td>-</td>
<td>Resta</td>
<td>X - Y</td>
<td>6</td>
</tr>
<tr class="odd">
<td>*</td>
<td>Multiplicación</td>
<td>X * Y</td>
<td>3</td>
</tr>
<tr class="even">
<td>/</td>
<td>División</td>
<td>X / Y</td>
<td>3</td>
</tr>
<tr class="odd">
<td>^</td>
<td>Potencia</td>
<td>X ^ Y</td>
<td>1</td>
</tr>
<tr class="even">
<td>-</td>
<td>Negación</td>
<td>-X</td>
<td>2</td>
</tr>
<tr class="odd">
<td>\</td>
<td>División Entera</td>
<td>X \ Y</td>
<td>4</td>
</tr>
<tr class="even">
<td>MOD</td>
<td>Resto de una división</td>
<td>X MOD 10</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>La prioridad indica qué operadores se aplicarán antes que otros. A menor prioridad, antes se calculará la expresión.</p>
<h4 id="operadores-condicionales">OPERADORES CONDICIONALES</h4>
<table>
<thead>
<tr class="header">
<th>Operador</th>
<th>Semántica</th>
<th>Ejemplo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>Igual</td>
<td>X = Y</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>Menor</td>
<td>X &lt; Y</td>
</tr>
<tr class="odd">
<td>&gt;</td>
<td>Mayor</td>
<td>X &gt; Y</td>
</tr>
<tr class="even">
<td>&gt;&lt;, &lt;&gt;</td>
<td>Distinto</td>
<td>X &gt;&lt; Y, X &lt;&gt; Y</td>
</tr>
<tr class="odd">
<td>&lt;=, =&lt;</td>
<td>Menor o igual</td>
<td>X &lt;= Y, X =&lt; Y</td>
</tr>
<tr class="even">
<td>&gt;=, =&gt;</td>
<td>Mayor o igual</td>
<td>X &gt;= Y, X =&gt; Y</td>
</tr>
</tbody>
</table>
<p>El resultado de una expresión condicional siempre tendrá o bien el valor -1 (VERDADERO) o bien el valor 0 (FALSO).</p>
<h4 id="paréntesis">PARÉNTESIS</h4>
<p>Puede usar paréntesis para forzar que se evalúen algunas partes de una expresión antes que otras. Esto puede invalidar el orden de prioridad y la asociatividad de izquierda a derecha. VR-BASIC siempre realiza las operaciones que se incluyen entre paréntesis antes de las externas. Sin embargo, dentro del paréntesis se mantiene la prioridad y la asociatividad ordinarias, a menos que use paréntesis dentro de los paréntesis.</p>
<p>Un ejemplo:</p>
<pre><code>PRINT 15 + (7 + 3) * (100 - 3)
 985
Ok</code></pre>
<h4 id="operadores-lógicos">OPERADORES LÓGICOS</h4>
<table>
<thead>
<tr class="header">
<th>Operador</th>
<th>Semántica</th>
<th>Tabla de verdad</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NOT</td>
<td>Negación Lógica</td>
<td>X</td>
<td>NOT X</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>AND</td>
<td>Producto Lógico</td>
<td>X</td>
<td>Y</td>
<td>X AND Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>OR</td>
<td>Suma Lógica</td>
<td>X</td>
<td>Y</td>
<td>X OR Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>XOR</td>
<td>OR Exclusivo</td>
<td>X</td>
<td>Y</td>
<td>X XOR Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>EQV</td>
<td>XOR Negado</td>
<td>X</td>
<td>Y</td>
<td>X EQV Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>IMP</td>
<td>Implicación</td>
<td>X</td>
<td>Y</td>
<td>X IMP Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="matemáticas">Matemáticas</h2>
<p>En este apartado veremos el conjunto de instrucciones y operadores del que dispone VR‑BASIC para hacer cálculos matemáticos, desde los más sencillos hasta los más complejos.</p>
<h4 id="funciones">Funciones</h4>
<p><strong>ABS</strong> - Devuelve el valor absoluto de un número (el valor sin signo).</p>
<p><strong>ATN</strong> - Devuelve el arco tangente. Valor entre –pi/2 y pi/2.</p>
<p><strong>TAN</strong> - Devuelve la tangente del número (medido en radianes).</p>
<p><strong>COS</strong> - Devuelve el coseno de un ángulo (medido en radianes).</p>
<p><strong>SIN</strong> - Devuelve el seno de un ángulo (medido en radianes).</p>
<p><strong>LOG</strong> - Devuelve el logaritmo natural o neperiano (base e).</p>
<p><strong>EXP</strong> - Devuelve la exponencial (e elevado al número).</p>
<p><strong>RND</strong> - Devuelve un número aleatorio entre 0 y 1.</p>
<p><strong>SQR</strong> - Devuelve la raíz cuadrada de un número.</p>
<p><strong>INT</strong> - Devuelve el mayor número entero que es menor o igual que el número dado.</p>
<p><strong>SNG</strong> - Da el valor -1, 0 o 1, dependiendo del signo del número o de si vale cero.</p>
<h4 id="operadores">Operadores</h4>
<table>
<thead>
<tr class="header">
<th>Suma</th>
<th>+</th>
<th>5 + 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Diferencia</td>
<td>-</td>
<td>5 – 3</td>
</tr>
<tr class="even">
<td>Producto/Multiplicación</td>
<td>*</td>
<td>5 * 3</td>
</tr>
<tr class="odd">
<td>División</td>
<td>/</td>
<td>5 / 3</td>
</tr>
<tr class="even">
<td>Potencia</td>
<td>^</td>
<td>2 ^ 3</td>
</tr>
<tr class="odd">
<td>Negar o cambiar el signo</td>
<td>-X</td>
<td>-5</td>
</tr>
<tr class="even">
<td>Módulo</td>
<td>MOD</td>
<td>5 MOD 3</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="prioridad-de-operadores">Prioridad de operadores</h4>
<p>Las expresiones se evalúan de izquierda a derecha. Dentro de la misma prioridad, se ejecutan primero los operadores de más a la izquierda.</p>
<p>Dentro de una expresión se efectúan en este orden de prioridad:</p>
<ol type="1">
<li><p>Los paréntesis</p></li>
<li><p>La potencia</p></li>
<li><p>La multiplicación y la división</p></li>
<li><p>Cambiar el signo</p></li>
<li><p>El módulo</p></li>
<li><p>La suma y la resta</p></li>
</ol>
<h2 id="crear-programas">Crear programas</h2>
<p>En esta sección introduciremos todo lo necesario para crear y manipular nuestros programas VR-BASIC. Pero antes, ¿qué es un <strong>programa</strong>? Pues se trata de una secuencia de instrucciones que podemos almacenar, modificar y ejecutar tantas veces como queramos. En VR-BASIC las instrucciones de los programas se asocian a números de línea. Cada número de línea puede almacenar una o varias instrucciones.</p>
<pre><code>10 REM Este es mi primer programa
20 CLS
30 PRINT &quot;Hola mundo&quot;
40 END</code></pre>
<p>Desde la consola VR-BASIC podemos crear un programa simplemente precediendo de un número el texto que escribamos. Por ejemplo:</p>
<pre><code>10 PRINT &quot;Hola Mundo&quot;</code></pre>
<p>Observamos que el PRINT no se realiza, no se ejecuta. Eso es porque el intérprete VR‑BASIC ha creado y almacenado nuestra primera línea de programa.</p>
<p>Vamos a ejecutar nuestro programa. Para ello está la instrucción <strong>RUN</strong>. Verá que al ejecutarla se muestra el texto “Hola Mundo” en pantalla. Podemos ejecutar RUN tantas veces como queramos y siempre saldrá el mismo texto en pantalla.</p>
<p>Para mostrar el listado de instrucciones de nuestro programa usaremos la instrucción <strong>LIST</strong>.</p>
<p>Habitualmente se suelen usar los números de línea de 10 en 10. Esto es así para tener huecos donde poder crear nuevos números de línea, tanto antes como después de una en particular. ¿Qué pasa si después de crear nuevos números de línea nos quedamos sin huecos libres? Para ello existe la instrucción <strong>RENUM</strong>. Esta instrucción permite renumerar las líneas otra vez para volver a tener huecos de nuevo.</p>
<p>Por ejemplo, agregue este número de línea:</p>
<pre><code>5 CLS</code></pre>
<p>Ahora haga AUTO y a continuación un LIST. Verá que sale lo siguiente:</p>
<pre><code>10 CLS
20 PRINT &quot;Hola Mundo&quot;</code></pre>
<p>Recuerde que CLS es una instrucción que le permite limpiar toda la pantalla, colocando el cursor en la posición superior-izquierda de la pantalla.</p>
<p>Ahora ya tenemos nuestro programa y resulta que hemos de dejarlo para continuar en otro momento. Si apagamos el ordenador lo perderemos todo. Así que es necesario saber cómo guardar y recuperar nuestros programas. Para ello se utilizan las instrucciones SAVE y LOAD.</p>
<p>Por ejemplo:</p>
<pre><code>SAVE &quot;miprograma.bas&quot;</code></pre>
<p>Permite guardar nuestro programa VR-BASIC en un archivo de la unidad de almacenamiento por defecto. El nombre del archivo utilizado será “miprograma.bas”. Si tras el guardado usamos la instrucción <strong>FILES</strong>, veremos que efectivamente nuestro archivo está entre la lista de los que ya tenemos.</p>
<p>Para recuperar nuestro programa en otro momento haremos:</p>
<pre><code>LOAD &quot;miprograma.bas&quot;</code></pre>
<p>NOTA: Cuidado con esto, porque si tenemos un programa ya en memoria y hacemos la carga de otro, lo perderemos.</p>
<p>Otra cosa que debemos saber sobre la gestión de los programas en VR-BASIC es ¿y cómo hacer para borrar un programa que ya tenga en memoria? Porque claro, puede que tenga uno y necesite comenzar otro. Esto se haría con la instrucción <strong>NEW</strong>. Ejecutamos este comando y el programa que tengamos se borrará: puede comprobarlo y verificar que no hay nada usando LIST.</p>
<p>Otra acción bastante requerida a la hora de escribir un programa es borrar números de línea o escribir código nuevo en una línea en concreto. Si ya tenemos un número de línea usado (con instrucciones y que se puede ver haciendo LIST) y queremos sustituirla por un nuevo código, simplemente hemos de reescribir ese número de línea. Si lo que queremos es borrar la línea, podemos simplemente escribir el número y pulsar retorno (tecla ENTER) o bien podemos usar la instrucción <strong>DELETE</strong>. Por ejemplo:</p>
<pre><code>DELETE 10</code></pre>
<p>Es interesante conocer y saber utilizar toda esta forma de interactuar con los programas. Sin embargo, en VR-BASIC existe un editor de texto pensado para la programación y que se invoca desde el intérprete con la instrucción <strong>CALL EDIT</strong> o bien con la versión abreviada <strong>_EDIT</strong>. Este editor facilita algunas cosas de las vistas anteriormente, además de que tiene resaltado de sintaxis para ver mejor el código, entre otras funcionalidades muy interesantes.</p>
<h4 id="uso-de-etiquetas">Uso de etiquetas</h4>
<p>Otra de las ventajas incluidas en el VR-BASIC es la capacidad de usar etiquetas o identificadores en formato texto para poder hacer referencia a ellas en el momento que se requiera e identificar alguna zona del código.</p>
<pre><code>1 @main:
2 print &quot;Hola!&quot;
3 gosub @subrutina1
4 end
5 @subrutina1:
6 print &quot;yeira!&quot;
7 return</code></pre>
<p>Desde el editor es posible agregar código sin números de línea. Cuando se ejecuta este código, el editor se encarga de agregarlos para ser compatible con la edición desde la consola VR-BASIC. Nótese que el archivo de texto que se guarda desde el editor no contendrá los números de línea.</p>
<h2 id="comentar-código">Comentar código</h2>
<p>Llega un momento en el que las dimensiones de nuestro programa serán considerables y su número de líneas elevado. Habrá multitud de rutinas y zonas de código, por lo que será necesario ayudar a la vista y memoria del programador. Afortunadamente, el lenguaje de programación VR-BASIC dispone de la opción de agregar comentarios. La instrucción se denomina <strong>REM</strong> y la forma de usarla es como la del siguiente ejemplo:</p>
<pre><code>10 REM Esto es un comentario</code></pre>
<p>También se puede usar el símbolo ‘ de la forma:</p>
<pre><code>10 ‘ Esto es un comentario</code></pre>
<p>Consejos a la hora de documentar nuestro programa.</p>
<ul>
<li><p>Agregar, al comienzo del todo, información sobre el título, fecha de creación, lo que hace vuestro programa, el nombre del programador, cualquier consideración genérica o importante que convenga señalar.</p></li>
<li><p>Antes de cualquier subrutina, indicar su nombre, parámetros de entrada y de salida, comentario respecto a lo que hace o datos importantes que se deben conocer sobre su uso.</p></li>
<li><p>Intentar comentar aquellas zonas de código complejas o que asumamos como complejas o difíciles de entender. Hay que pensar siempre que el código puede acabar en manos de otro programador. Incluso a nosotros mismos, tras mucho tiempo después de haberlo hecho, se nos pueden olvidar ciertos detalles que ayuden a su comprensión.</p></li>
</ul>
<h2 id="bucles">Bucles</h2>
<p>Una de las ventajas de los programas es su capacidad de repetir acciones indefinidamente y siempre de la misma forma. Pues bien, una de las cosas que a su vez hacen todos los programas es ejecutar una y otra vez los mismos trozos de código (secuencia de instrucciones)</p>
<p>Los Bucles son una forma de indicar que algo se repite una y otra vez, bien de forma indefinida o bien un determinado número de veces. En VR-BASIC existen varias formas de realizar esto, y cada una de ellas se utiliza con un fin.</p>
<h4 id="goto">GOTO</h4>
<p>Con GOTO podemos cambiar la instrucción siguiente a ejecutar. La forma de ejecutar un programa es ir línea a línea, en orden, una detrás de otra, ejecutando todas las instrucciones a su paso. Sin embargo, usando GOTO permitimos romper esta situación y hacer que la siguiente instrucción a ejecutar esté antes o después de la línea en la que estamos.</p>
<pre><code>10 I = 1
20 PRINT I
30 I = I + 1
40 IF I &lt; 10 THEN GOTO 20
50 END</code></pre>
<pre><code></code></pre>
<h4 id="for-next">FOR / NEXT</h4>
<p>Permite definir, entre un FOR y un NEXT, una serie de instrucciones para que se repitan, generalmente un número de veces determinado. En el siguiente ejemplo, imprimiremos por pantalla los números del 1 al 10.</p>
<pre><code>10 FOR I = 1 TO 10
20 PRINT I
30 NEXT I</code></pre>
<pre><code></code></pre>
<h4 id="gosub-return">GOSUB / RETURN</h4>
<p>Permite gestionar la llamada a ciertas zonas de código genéricas funcionando como subrutinas. Se usa para hacer una operación en concreto (algo que repetimos muchas veces y se ubica en otro número de línea) y volver justo donde estábamos, sin tener que escribir varias veces las instrucciones de la operación que se repite.</p>
<pre><code>10 CLS
20 A = 5 : GOSUB 100
30 A = 6 : GOSUB 100
40 A = 7 : GOSUB 100
50 END
100 ‘ Mi subrutina
110 PRINT &quot;Aqui imprimo A:&quot;;A
120 RETURN</code></pre>
<pre><code></code></pre>
<h4 id="on-goto">ON / GOTO</h4>
<p>Permite usar condiciones al mismo tiempo que la instrucción GOTO. O sea, según el valor de una variable podemos decidir a dónde saltar. Veamos un ejemplo:</p>
<pre><code>10 INPUT K
20 ON K GOTO 30, 50
30 PRINT &quot;K ES 1&quot;
40 GOTO 70
50 PRINT &quot;K ES 2&quot;
60 GOTO 70
70 END</code></pre>
<pre><code></code></pre>
<p>Otro ejemplo:</p>
<pre><code>10 CLS
20 PRINT &quot;MENU DE OPCIONES&quot;
30 PRINT &quot;1.- PREGUNTAR NOMBRE&quot;
40 PRINT &quot;2.- MOSTRAR NOMBRE&quot;
50 PRINT &quot;3.- SALIR&quot;
60 INPUT &quot;Opción&quot;;OP
70 ON OP GOTO 80, 100, 120
80 INPUT &quot;Dime un nombre&quot;;N$
90 GOTO 60
100 PRINT &quot;Nombre actual:&quot;;N$
110 GOTO 60
120 END</code></pre>
<h2 id="condiciones">Condiciones</h2>
<p>En VR-BASIC contamos con las sentencias IF, THEN, ELSE para poder controlar el flujo de ejecución de nuestros programas mediante la evaluación de expresiones condicionales.</p>
<pre><code>IF expresión_condicional THEN sentencias
IF expresión_condicional THEN sentencias ELSE sentencias
IF expresión_condicional GOTO &lt;número&gt; [ELSE &lt;número&gt;]</code></pre>
<pre><code></code></pre>
<p>Las expresiones condicionales utilizan operadores condicionales, como se comentan en el apartado de la página 28.</p>
<p>Las expresiones condicionales devuelven un valor VERDADERO o FALSO. A este tipo de valores se les denomina Booleanos. Numéricamente, el 0 correspondería a FALSO y otro valor distinto de cero correspondería a VERDADERO.</p>
<p>Cuando la expresión condicional devuelve VERDADERO, se ejecutan las sentencias del THEN. Si la expresión devuelve FALSO, se ejecutarán las sentencias del ELSE (siempre que se estén usando).</p>
<p>Ejemplo:</p>
<pre><code>10 INPUT &quot;Que edad tienes&quot;;A
20 IF A &lt; 18 THEN PRINT &quot;Eres joven&quot;:END ELSE PRINT &quot;Eres adulto&quot;</code></pre>
<pre><code></code></pre>
<p>Otro ejemplo:</p>
<pre><code>10 INPUT &quot;Área del cuadrado o del triangulo (C o T) &quot;;A$
20 IF A$ = &quot;C&quot; GOTO 40 ELSE IF A$ = &quot;T&quot; GOTO 70 ELSE 10
30 REM ---
40 INPUT &quot;Dime cuanto mide el lado&quot;;S
50 PRINT &quot;El área del cuadrado es: &quot;; S*S
60 END
70 INPUT &quot;Dime cuanto mide la altura&quot;;H
80 INPUT &quot;Dime cuanto mide la base&quot;;B
90 PRINT &quot;El área del triangulo es&quot;; B*H/2
100 END</code></pre>
<h2 id="tablas-arrays">Tablas (Arrays)</h2>
<p>En muchos programas hay necesidad de disponer de gran número de variables. Podríamos pensar, por ejemplo, en un programa para la administración de existencias en un almacén. Si para cada artículo almacenado tenemos que reflejar en el programa una variable diferente, el programa sería enorme y poco usable, además de que gestionar el agregado y borrado de estos artículos se convertiría en una tarea irremediablemente tediosa.</p>
<p>Por suerte, en el VR-BASIC tenemos la instrucción DIM. Esta permite reservar espacio de acceso indexado utilizando para ello un único nombre de variable.</p>
<p>Por ejemplo:</p>
<pre><code>DIM A(100)</code></pre>
<p>Con esta instrucción reservamos 101 variables realmente. Para acceder a cada una de ellas usaremos la forma:</p>
<pre><code>A(0), A(1), A(2) … A(100)</code></pre>
<p>Otro ejemplo:</p>
<pre><code>10 DIM A(100)
20 A(3) = 6
30 A(27) = 5
40 A(98) = A(3) + A(27)
50 PRINT A(98)</code></pre>
<p>Si ejecutamos el programa obtendremos:</p>
<pre><code>RUN
 11
Ok</code></pre>
<p>Lo interesante de esta funcionalidad es que también es posible acceder a los arrays usando una expresión. Por ejemplo:</p>
<pre><code>10 DIM B(10)
20 FOR K=1 to 10 
30 B(K) = K
40 NEXT K
50 FOR K=10 TO 1 STEP -1
60 PRINT B(K);
70 NEXT K</code></pre>
<p>Resultado:</p>
<pre><code>RUN
 10 9 8 7 6 5 4 3 2 1
Ok</code></pre>
<h4 id="matrices">MATRICES</h4>
<p>Otro aspecto interesante de los arrays es que permite definirlos con varias dimensiones.</p>
<p><em>Cuando un array tiene más de una dimensión se le suele denominar matriz.</em></p>
<p>La forma de definir un matriz de dos dimensiones sería:</p>
<pre><code>DIM A(4, 4)</code></pre>
<p>Y si fuese de tres dimensiones:</p>
<pre><code>DIM A(4, 5, 3)</code></pre>
<p>De esta forma, podemos definir tantas dimensiones como requiramos y la memoria del sistema nos permita.</p>
<p>Ejemplo:</p>
<pre><code>5 REM ORDENAR NOMBRES
10 READ N
15 DIM A$(N)
20 FOR J = 1 TO N
30 READ A$(J)
40 NEXT J
50 DATA 5, PRIMERO, SEGUNDO, TERCERO, CUARTO, QUINTO
100 FOR J = 1 TO N -1
110 FOR K = J + 1 TO N
120 IF A$(J) &lt; A$(K) THEN 160
130 X$ = A$(J)
140 A$(J) = A$(K)
150 A$(K) = X$
160 NEXT K
170 NEXT J
200 FOR I = 1 TO N
210 PRINT A$(I)
220 NEXT I
230 END</code></pre>
<h2 id="algunos-ejemplos-en-vr-basic">Algunos ejemplos en VR-BASIC</h2>
<p>Estos ejemplos servirán de ayuda para comprender todo lo descrito hasta ahora. Todos los ejemplos son en modo de texto. En el siguiente punto, trataremos el tema gráfico.</p>
<h2 id="tabla-de-multiplicar">Tabla de multiplicar</h2>
<pre><code>10 CLS
20 INPUT &quot;Dime el multiplicador&quot;;M
30 PRINT M;&quot;X 1&quot;;&quot; = &quot;;1*M
40 PRINT M;&quot;X 2&quot;;&quot; = &quot;;2*M
50 PRINT M;&quot;X 3&quot;;&quot; = &quot;;3*M
60 PRINT M;&quot;X 4&quot;;&quot; = &quot;;4*M
70 PRINT M;&quot;X 5&quot;;&quot; = &quot;;5*M
80 PRINT M;&quot;X 6&quot;;&quot; = &quot;;6*M
90 PRINT M;&quot;X 7&quot;;&quot; = &quot;;7*M
100 PRINT M;&quot;X 8&quot;;&quot; = &quot;;8*M
110 PRINT M;&quot;X 9&quot;;&quot; = &quot;;9*M
120 PRINT M;&quot;X 10&quot;;&quot; = &quot;;10*M</code></pre>
<p>En este ejemplo, pedimos por teclado que se introduzca un número que usaremos como multiplicador y el multiplicando, serán los números comprendidos del 1 al 10.</p>
<p>Cada línea PRINT hace el cálculo y lo muestra formateado.</p>
<h2 id="tabla-de-multiplicar-optimizada-con-un-bucle">Tabla de multiplicar optimizada con un bucle</h2>
<pre><code>10 CLS
20 INPUT &quot;Dime el multiplicador&quot;;M
30 FOR C=1 TO 10
40 PRINT C;&quot;X &quot;;M;&quot; = &quot;;C*M
50 NEXT C</code></pre>
<p>Hemos cambiado todas las líneas PRINT por una sola que se encuentra dentro de un bucle FOR / NEXT. De este modo, mientras se recorre el bucle del 1 al 10, se van pintando los resultados.</p>
<h2 id="adivina-mi-número">Adivina mi número</h2>
<pre><code>10 Y=INT(RND(1)*10)
20 CLS
30 PRINT &quot;ADIVINA MI NUMERO&quot;
40 PRINT &quot;-----------------&quot;:PRINT
50 INPUT &quot;DAME UN NUMERO (0-9)&quot;;X
60 IF X &lt; Y THEN PRINT:PRINT &quot;DEBE SER MAYOR&quot;:FOR I=1 TO 300:NEXT I:GOTO 20
65 IF X &gt; Y THEN PRINT:PRINT &quot;DEBE SER MENOR&quot;:FOR I=1 TO 300:NEXT I:GOTO 20</code></pre>
<pre><code>70 IF Y = X THEN PRINT:PRINT &quot;ACERTASTE MI NUMERO!!&quot;
80 PRINT:PRINT &quot;Mi numero era:&quot;;Y</code></pre>
<p>Este sencillo programa, genera un número aleatorio del 1 al 10 y lo que hace es ir comparando el número introducido por teclado, variable X, con el generado de modo aleatorio, variable Y. Cuando son iguales, finaliza el programa. Observa que usamos la función INT para obtener el número entero sin decimales.</p>
<h2 id="jugando-con-bucles">Jugando con bucles</h2>
<pre><code>10 CLS
15 PRINT &quot;*&quot;
20 FOR I=1 TO 9
30 FOR J=1 TO I
40 PRINT &quot;*&quot;;
50 NEXT J
55 PRINT &quot;*&quot;
60 NEXT I</code></pre>
<p>Este ejemplo pinta una media pirámide hecha a base de asteriscos. El “;” (punto y coma) después del PRINT sirve para que se pinte el siguiente PRINT seguido, sin saltos de línea.</p>
<h2 id="jugando-a-tabular-la-salida-de-datos">Jugando a tabular la salida de datos</h2>
<pre><code>10 CLS
20 DIM ano$(12)
30 FOR I=1 TO 12
40 READ ano$(I)
100 PRINT ano$(I);TAB(15);I
110 NEXT I
120 END
130 DATA Enero,Febrero,Marzo,Abril,Mayo
140 DATA Junio,Julio,Agosto,Septiembre
150 DATA Octubre,Noviembre,Diciembre</code></pre>
<p>Este otro ejemplo, muestra la lista de meses con sus nombres y el número de mes al que corresponde. Usamos la función TAB para formatear la salida del número de mes.</p>
<pre><code></code></pre>
<h2 id="textos-que-se-mueven">Textos que se mueven</h2>
<pre><code>10 CLS
20 FOR X=1 TO 6
30 LOCATE X,2
40 PRINT&quot;NOMBRE&quot;
50 FOR T=1 TO 100:NEXT T                                                      </code></pre>
<pre><code>60 LOCATE X,2                                                                 </code></pre>
<pre><code>70 IF X&lt;6 THEN PRINT &quot; &quot;                                                    </code></pre>
<pre><code>80 NEXT X</code></pre>
<pre><code>90 FOR X=30 TO 20 STEP -1                                                     </code></pre>
<pre><code>100 LOCATE X,2                                                                 </code></pre>
<pre><code>110 PRINT &quot;APELLIDO&quot;                                                           </code></pre>
<pre><code>120 FOR T=1 TO 100:NEXT T                                                      </code></pre>
<pre><code>130 LOCATE X+7,2                                                              </code></pre>
<pre><code>140 IF X&gt;20 THEN PRINT &quot; &quot;                                                    </code></pre>
<pre><code>150 NEXT X</code></pre>
<p>En este ejemplo, podremos observar cómo se mueven dos cadenas de texto. NOMBRE se desplaza hacia la derecha y APELLIDO se desplaza hacia la izquierda. Utilizamos el comando LOCATE para posicionar el texto en los ejes X,Y de la pantalla. En este caso para ambos textos, el eje Y es 2. Los FOR.. NEXT con la variable X son los que manejan el movimiento del eje X, y al usar LOCATE X,2 y LOCATE X+7 junto con los FOR.. NEXT X, provocamos el movimiento en dicho eje. Los IF THE ELSE, controlan el borrado del carácter que vamos arrastrando. En el caso de NOMBRE es la letra N y en APELLIDO en la O. Prueba a quitar dichos IF THEN ELSE y comprobarás para que se usan. Los FOR..NEXT con la variable T actúa como temporizador, es decir, el tiempo que tarda el desplazar el texto carácter a carácter. Si cambiamos su valor, 100 por otro menor, los textos se desplazarán más rápido y por supuesto, si ponemos un valor superior a 100, se desplazarán más lentos.</p>
<h2 id="atrapa-el-número">Atrapa el número</h2>
<pre><code>10 KEY OFF:SCREEN 0:WIDTH 80</code></pre>
<pre><code>20 CLS</code></pre>
<pre><code>30 PRINT &quot;ATRAPA EL NUMERO&quot; TAB(30) &quot;NUMERO ALEATORIO&quot;</code></pre>
<pre><code>40 I=INT(9*RND(-1*TIME))</code></pre>
<pre><code>50 LOCATE 5,2:PRINT I</code></pre>
<pre><code>60 A=INT(9*RND(-1*TIME))</code></pre>
<pre><code>65 LOCATE 35,2:PRINT A</code></pre>
<pre><code>70 LOCATE 5,6: PRINT &quot;Pulsa la barra espaciadora para congelar un numero&quot;</code></pre>
<pre><code>80 K$=INKEY$</code></pre>
<pre><code>90 IF K$=&quot; &quot; THEN 140</code></pre>
<pre><code>100 GOTO 60</code></pre>
<pre><code>140 IF I=A THEN LOCATE 10,9:PRINT &quot;ERES UN GENIO!&quot;</code></pre>
<pre><code>150 IF I&lt;&gt;A THEN LOCATE 10,9:PRINT &quot;HAS FALLADO&quot;</code></pre>
<pre><code>230 LOCATE 1,12:PRINT &quot;QUIERES JUGAR DE NUEVO?(S/N)&quot;;</code></pre>
<pre><code>240 A$=INKEY$</code></pre>
<pre><code>250 IF A$=&quot;S&quot; OR A$=&quot;s&quot; THEN GOTO 20 ELSE IF A$=&quot;N&quot; OR A$=&quot;n&quot; THEN END ELSE GOTO 240</code></pre>
<p>Este programa hace uso de dos números aleatorios contenidos en dos variables; I, A. El número I se nos muestra bajo el texto ATRAPA ESTE NUMERO y bajo el texto NUMERO ALEATORIO vemos un número que va cambiando con rapidez del 1 al 9 de forma aleatoria, esa es la variable A.</p>
<p>El programa espera la pulsación de la barra espaciadora para parar el número que se autogenera rápidamente y el objetivo es pararlo en el mismo número que nos muestra a la izquierda. Si fallamos o acertamos, el programa mostrará el texto de ERES UN GENIO o HAS FALLADO, según el caso. Podremos continuar la partida pulsando S/s o parar pulsando N/n. La clave de este código es que genera dos códigos aleatorios y los comparamos para ver si son iguales o no.</p>
<h2 id="slot-machine">Slot machine</h2>
<pre><code>10 REM SLOT MACHINE</code></pre>
<pre><code>20 KEY OFF:SCREEN 0,,0</code></pre>
<pre><code>30 DIM DADO(3)</code></pre>
<pre><code>40 M=100</code></pre>
<pre><code>50 APUESTA=5:I=1:CO=0:DI=0:TR=0:PI=0</code></pre>
<pre><code>55 DADO(0)=0:DADO(1)=0:DADO(2)=0:DADO(3)=0</code></pre>
<pre><code>60 CLS</code></pre>
<pre><code>70 PRINT &quot;SLOT MACHINE&quot;</code></pre>
<pre><code>80 DADO(I)=INT(4*RND(-1*TIME))</code></pre>
<pre><code>90 IF DADO(I)=0 THEN DADO(I)=67</code></pre>
<pre><code>100 IF DADO(I)=1 THEN DADO(I)=68</code></pre>
<pre><code>110 IF DADO(I)=2 THEN DADO(I)=69</code></pre>
<pre><code>120 IF DADO(I)=3 THEN DADO(I)=70</code></pre>
<pre><code>130 LOCATE 5+I,2:PRINT CHR$(1)+CHR$(DADO(I))</code></pre>
<pre><code>140 K$=INKEY$</code></pre>
<pre><code>150 IF K$=&quot; &quot; THEN 180</code></pre>
<pre><code>160 GOTO 80</code></pre>
<pre><code>180 IF DADO(I)=67 THEN CO=CO+1</code></pre>
<pre><code>190 IF DADO(I)=68 THEN DI=DI+1</code></pre>
<pre><code>200 IF DADO(I)=69 THEN TR=TR+1</code></pre>
<pre><code>210 IF DADO(I)=70 THEN PI=PI+1</code></pre>
<pre><code>215 IF I&lt;3 THEN I=I+1:GOTO 80</code></pre>
<pre><code>220 IF CO&gt;1 THEN APUESTA=APUESTA*CO</code></pre>
<pre><code>230 IF DI&gt;1 THEN APUESTA=APUESTA*DI</code></pre>
<pre><code>240 IF TR&gt;1 THEN APUESTA=APUESTA*TR</code></pre>
<pre><code>250 IF PI&gt;1 THEN APUESTA=APUESTA*PI</code></pre>
<pre><code>260 IF APUESTA=5 THEN M=M-APUESTA:LOCATE 10,8:PRINT &quot;HAS PERDIDO:&quot;;APUESTA</code></pre>
<pre><code>270 IF APUESTA&gt;5 THEN M=M+APUESTA:LOCATE 10,8:PRINT &quot;HAS GANADO:&quot;;APUESTA</code></pre>
<pre><code>280 LOCATE 10,10:PRINT &quot;TU MONEDERO:&quot;;M</code></pre>
<pre><code>290 LOCATE 1,12:PRINT &quot;QUIERES JUGAR DE NUEVO?(S/N)&quot;;</code></pre>
<pre><code>300 A$=INKEY$</code></pre>
<pre><code>310 IF A$=&quot;S&quot; OR A$=&quot;s&quot; THEN GOTO 50 ELSE IF A$=&quot;N&quot; OR A$=&quot;n&quot; THEN END ELSE GOTO 300</code></pre>
<p>Ya comenzamos a ver código más complejo. El corazón de este programa está basado en el código anterior: Atrapa el número.</p>
<p>En este caso generamos un número aleatorio del 0 a 3 y dependiendo del número le asignamos otro número que usaremos más tarde para mostrar su código ASCII. Esos códigos ASCII son los símbolos de la baraja de cartas francesa: corazones, diamantes, tréboles y picas. El programa contabiliza cuantas figuras iguales han aparecido en las tiradas, de modo que, si han salido al menos dos símbolos iguales, suma puntos, si no, los resta.</p>
<pre><code></code></pre>
<h2 id="moviendo-un-carácter-con-el-teclado">Moviendo un carácter con el teclado</h2>
<pre><code>10 X=10:Y=10:CLS:KEY OFF</code></pre>
<pre><code>20 A$=INKEY$</code></pre>
<pre><code>30 IF A$=&quot;S&quot; THEN X=X-1:GOTO 70</code></pre>
<pre><code>40 IF A$=&quot;D&quot; THEN X=X+1:GOTO 70</code></pre>
<pre><code>50 IF A$=&quot;E&quot; THEN Y=Y-1:GOTO 90</code></pre>
<pre><code>60 IF A$=&quot;X&quot; THEN Y=Y+1:GOTO 90</code></pre>
<pre><code>70 IF X&lt;0 THEN X=0</code></pre>
<pre><code>80 IF X&gt;28 THEN X=28</code></pre>
<pre><code>90 IF Y&lt;0 THEN Y=0</code></pre>
<pre><code>100 IF Y&gt;20 THEN Y=20</code></pre>
<pre><code>110 LOCATE X,Y:PRINT &quot; O &quot;</code></pre>
<pre><code>120 GOTO 20</code></pre>
<pre><code>130 END</code></pre>
<p>Este programa muestra esto “ O “ en la pantalla. Lo podemos mover pulsando las teclas:</p>
<p>S: izquierda, D: derecha, E:arriba, X: abajo</p>
<h2 id="creando-un-menú-de-acciones">Creando un menú de acciones</h2>
<p>10 REM SIMPLE MENU SYSTEM</p>
<p>20 REM PRINT OUT LIST OF OPTIONS</p>
<p>25 KEY OFF</p>
<p>30 CLS</p>
<p>35 PRINT “1. MOSTRAR UN MENSAJE”</p>
<p>40 PRINT “2. ESCUCHAR NOTAS MUSICALES”</p>
<p>50 PRINT “3. PINTAR UN CIRCULO”</p>
<p>60 PRINT “4. EXIT”</p>
<p>70 LOCATE 1,20</p>
<p>80 PRINT “ELIGE UNA OPCION”;</p>
<p>90 A$=INKEY$:IF A$="" THEN 90 ELSE PRINT A$</p>
<p>100 OPT%=ASC(A$)-48</p>
<p>110 IF (OPT%&lt;1) OR (OPT%&gt;4) THEN BEEP:LOCATE 22,20:GOTO 90</p>
<p>120 REM SELECT ACTION TO BE TAKEN</p>
<p>130 ON OPT% GOSUB 500,600,700,800</p>
<p>500 CLS:PRINT “HOLA. SOY UN MSXVR!”</p>
<p>510 FOR I=1 TO 800:NEXT I</p>
<p>520 RETURN 30</p>
<p>600 REM ALGO DE MUSICA</p>
<p>610 PLAY “CDEFG”</p>
<p>620 FOR I=1 TO 800:NEXT I</p>
<p>630 RETURN 30</p>
<p>700 REM PINTAR UN CIRCULO</p>
<p>710 SCREEN 2</p>
<p>720 CIRCLE(128,92),70,1</p>
<p>730 PAINT(128,92),1</p>
<p>740 FOR I=1 TO 800:NEXT I</p>
<p>750 SCREEN 1:RETURN 30</p>
<p>800 CLS:END:REM FIN DEL PROGRAMA</p>
<p>Un ejemplo sencillo de cómo crear un menú interactivo, de modo que, dependiendo de la opción que se elija, el programa salta a las líneas adecuadas para ejecutar esa parte de código. Todo se controla con GOSUB y RETURN. Este último para volver siempre al menú principal.</p>
<h2 id="gráficos">Gráficos</h2>
<h3 id="comandos-vr-basic">Comandos VR-BASIC</h3>
<p>Los comandos relacionados con los gráficos en VR-BASIC son:</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>SCREEN</th>
<th>Permite establecer el modo de pantalla. Resolución, colores y modos para los sprites.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COLOR</td>
<td>Aplica colores a la pantalla, a los gráficos y a la paleta de colores.</td>
</tr>
<tr class="even">
<td>DRAW</td>
<td>Dibuja patrones a partir de un lenguaje de comandos.</td>
</tr>
<tr class="odd">
<td>LINE</td>
<td>Dibuja líneas y cajas.</td>
</tr>
<tr class="even">
<td>CIRCLE</td>
<td>Dibuja círculos, arcos y elipses.</td>
</tr>
<tr class="odd">
<td>PAINT</td>
<td>Rellena con color figuras dibujadas en pantalla.</td>
</tr>
<tr class="even">
<td>PSET</td>
<td>Dibuja puntos.</td>
</tr>
<tr class="odd">
<td>PRESET</td>
<td>Borra puntos.</td>
</tr>
<tr class="even">
<td>POINT</td>
<td>Obtiene el valor del color de un punto en pantalla.</td>
</tr>
<tr class="odd">
<td>COPY</td>
<td>Permite hacer operaciones con bloques de gráficos en VRAM, RAM y/o disco.</td>
</tr>
<tr class="even">
<td>COPY SCREEN</td>
<td>Captura de imágenes desde un digitalizador.</td>
</tr>
<tr class="odd">
<td>SPRITE$</td>
<td>Define la apariencia de sprites.</td>
</tr>
<tr class="even">
<td>PUT SPRITE</td>
<td>Asigna atributos en sprites y mostrar/ocultar en pantalla.</td>
</tr>
<tr class="odd">
<td>COLOR SPRITE$</td>
<td>Asigna colores en sprites.</td>
</tr>
</tbody>
</table>
<h3 id="vdp-en-los-distintos-msx">VDP en los distintos MSX</h3>
<p>El VDP hace referencia al procesador de pantalla de vídeo (<em>Video Display Processor</em>) o chip encargado de representar gráficos en la pantalla, bien sea a través de un monitor o de una televisión.</p>
<table>
<thead>
<tr class="header">
<th><strong>Modelo</strong></th>
<th><strong>Fabricante</strong></th>
<th><strong>Chip</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MSX*</td>
<td>Texas Instruments</td>
<td>TMS9918</td>
</tr>
<tr class="even">
<td>MSX2</td>
<td>Yamaha</td>
<td>VDP9938</td>
</tr>
<tr class="odd">
<td>MSX2+</td>
<td>Yamaha</td>
<td>VDP9958</td>
</tr>
<tr class="even">
<td>MSXturboR</td>
<td>Yamaha</td>
<td>VDP9958</td>
</tr>
<tr class="odd">
<td>MSXVR</td>
<td>--</td>
<td>VDP9968</td>
</tr>
</tbody>
</table>
<p>* En algunos modelos MSX podemos encontrar variantes del VDP, incluso de otros fabricantes, compatibles con el estándar, pero con sutiles diferencias, como por ejemplo los TMS9929, TMS9129, T9737 y T6950 de (Toshiba).</p>
<h3 id="vram">VRAM</h3>
<p>La memoria de vídeo o VRAM es la memoria utilizada por el procesador de vídeo (VDP) para representar la información que vemos en pantalla. La cantidad máxima de memoria del procesador de vídeo determinará el espacio de direccionamiento disponible.</p>
<h3 id="modos-de-pantalla">Modos de Pantalla</h3>
<p>Según se configure el procesador de vídeo, se podrán determinar diferentes modos de pantalla. Cada modo de pantalla permite una resolución horizontal y vertical, además del número máximo de colores y su formato. En VR-BASIC los modos de pantalla se establecen con la sentencia SCREEN. Véase SCREEN para más información sobre los modos de pantalla disponibles.</p>
<h3 id="páginas-de-vídeo">Páginas de vídeo</h3>
<p>Una página de vídeo es una zona de la VRAM donde se almacena la información de una pantalla, tal y como la veríamos en un televisor o monitor. Según el formato del pixel (bits codificados o no, con los que obtener el color a representar) y la resolución del modo de pantalla, una página ocupará más o menos bytes en la VRAM. De esta forma, y según la VRAM disponible, podremos llegar a tener más o menos páginas accesibles para almacenar una o varias pantallas.</p>
<h3 id="página-visible">Página visible</h3>
<p>Aunque podamos tener una o varias páginas de vídeo disponibles, solo podrá ser visible una a la vez (exceptuando cuando usamos el modo entrelazado).</p>
<h3 id="entrelazado">Entrelazado</h3>
<p>Para conseguir resoluciones verticales mayores, es posible activar el modo entrelazado. Este modo permite combinar 2 páginas en VRAM como una sola, de manera que, si la resolución vertical usual es de 212 pixeles, podemos conseguir 424.</p>
<h3 id="pixeles-y-puntos">Pixeles y puntos</h3>
<p>Un pixel hace referencia a una unidad de color representable en una pantalla (monitor o televisor). Una pantalla permite una cantidad máxima de pixeles en horizontal y en vertical (resolución).</p>
<p>Un punto hace referencia a la unidad que, tras aplicar una expresión de conversión, nos devuelve la cantidad de pixeles necesarios para cumplir la relación. Por ejemplo: Pixeles por pulgada o Pixeles por centímetro.</p>
<h3 id="paleta-de-colores">Paleta de colores</h3>
<p>Para determinar el color final de un pixel, el procesador de vídeo interpreta la distinta información de su memoria de vídeo para obtener el color resultante. Este color se codificará finalmente en un formato digital o analógico que será transmitido a la pantalla. A la hora de determinar ese color, se podrá usar una conversión directa, leyendo el color directamente (<em>Direct Color</em>) de los datos guardados en la VRAM, o bien ese valor será un índice que permitirá extraer el color de una paleta de colores.</p>
<h3 id="sprites">Sprites</h3>
<p>Son gráficos que se pintan por encima de la página activa y funcionan de forma independiente a las páginas de vídeo; por tanto, la información que se utiliza se almacena en otras áreas de la VRAM. Estas áreas son:</p>
<ul>
<li><p><strong>Tabla de atributos:</strong> En ella se encuentran las posiciones en pantalla de los distintos sprites, su color, el patrón utilizado e información adicional.</p></li>
<li><p><strong>Tabla de patrones:</strong> Aquí se organiza la información que describe gráficamente a los sprites. Esta información se distribuye en patrones de tamaño 8x8 pixeles, aunque en VRAM se almacena en grupos de 8 bytes. Cada bit de un byte representa un pixel, por lo que un byte representa una línea de 8 pixeles. El valor 0 indica transparente (deja ver el pixel de la página activa) y el valor 1 indica que se pintará el pixel con el color correspondiente del sprite.</p></li>
</ul>
<p><strong>Tamaño</strong></p>
<p>Un Sprite puede tener dos tamaños posibles, o bien de 8x8 o de 16x16. A su vez, es posible indicar si se quiere magnificar su tamaño. En ese caso, el tamaño final del sprite podrá ser o bien 16x16 o 32x32; eso sí, el grosor de sus pixeles será del doble de su tamaño normal.</p>
<p><strong>Prioridad y cantidad</strong></p>
<p>Pueden haber 32 sprites a la vez en pantalla. Cada sprite usa un plano independiente de manera que el sprite que usa el plano 0 se pinta por delante de todos los demás. Por tanto, a menor número de plano, mayor prioridad tendrá cuando se dibuje en pantalla.</p>
<p><strong>Colores</strong></p>
<p>Los sprites pueden trabajar en modo monocromático en Screen 1, 2 y 3. En este modo, el color del sprite se obtiene de su tabla de atributos y lo aplica al dibujar los patrones en pantalla. Sin embargo, en Screen 4 hasta Screen 13 se utiliza el modo multicolor. Este modo permite asociar 2 colores por línea de patrón de sprite y para establecer esta información se utiliza la <em>Tabla de colores de sprites</em> que se ubica en la VRAM.</p>
<p>NOTA: Las direcciones de VRAM donde se encuentran las diferentes tablas de los sprites son accesibles a través de la sentencia BASE del VR-BASIC.</p>
<h2 id="música-y-sonido">Música y Sonido</h2>
<p>Las instrucciones relacionadas con la música y el sonido en VR-BASIC son:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>PLAY</th>
<th>Permite reproducir música PSG, OPLL y de otros chips de sonido utilizando el lenguaje de texto MML.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SOUND</td>
<td>Reproduce sonidos directamente desde el PSG.</td>
</tr>
<tr class="even">
<td>SET BEEP</td>
<td>Configura el tipo de pitido.</td>
</tr>
<tr class="odd">
<td>BEEP</td>
<td>Hace sonar un pitido.</td>
</tr>
<tr class="even">
<td>CALL MUSIC</td>
<td>Establece la configuración de voces para los chips de sonido.</td>
</tr>
<tr class="odd">
<td>CALL AUDIO</td>
<td></td>
</tr>
<tr class="even">
<td>CALL AUDREG</td>
<td>Escribe directamente a un registro de un chip de sonido.</td>
</tr>
<tr class="odd">
<td>CALL MDR</td>
<td>Asocia notas MIDI con los instrumentos usados como percusión.</td>
</tr>
<tr class="even">
<td>CALL BGM</td>
<td>Establece el modo de reproducción.</td>
</tr>
<tr class="odd">
<td>CALL PITCH</td>
<td>Establece el ajuste de tono a utilizar.</td>
</tr>
<tr class="even">
<td>CALL PLAY</td>
<td>Averigua qué canales están reproduciendo sonido.</td>
</tr>
<tr class="odd">
<td>CALL STOPM</td>
<td>Detiene la reproducción.</td>
</tr>
<tr class="even">
<td>CALL TEMPER</td>
<td>Ajusta el temperamento de los sonidos.</td>
</tr>
<tr class="odd">
<td>CALL TRANSPOSE</td>
<td>Altera al tono en la reproducción del sonido.</td>
</tr>
<tr class="even">
<td>CALL VOICE</td>
<td>Establece la configuración de cada voz.</td>
</tr>
<tr class="odd">
<td>CALL VOICE COPY</td>
<td>Copia la configuración de las voces entre diferentes ubicaciones.</td>
</tr>
<tr class="even">
<td>CALL AUDIODRIVERBASEPORT</td>
<td>Configura los puertos a utilizar para los drivers de sonido disponibles.</td>
</tr>
</tbody>
</table>
<h3 id="lenguaje-mml">Lenguaje MML</h3>
<p>Es el lenguaje utilizado por VR-BASIC para escribir música. Sus siglas vienen de <em>Music Macro Language</em>. La codificación permite almacenar la música en cadenas de texto visualmente legibles, donde diferentes letras indican órdenes a procesar: tocar nota, cambiar de octava, cambiar de volumen, etc.</p>
<h3 id="chips-de-audio">Chips de audio</h3>
<table>
<thead>
<tr class="header">
<th><strong>NOMBRE</strong></th>
<th><strong>Máximo número de CANALES</strong></th>
<th><strong>SÍNTESIS</strong></th>
<th><strong>PLATAFORMAS</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AY8910</td>
<td>3</td>
<td>Oscilador + Ondas + Ruido</td>
<td>MSX, SPECTRUM, CPC</td>
</tr>
<tr class="even">
<td>SID</td>
<td>3</td>
<td>Osciladores + Ondas + DSP</td>
<td>C64</td>
</tr>
<tr class="odd">
<td>SN76489</td>
<td>3</td>
<td>Oscilador + Ondas + Ruido</td>
<td>Master System</td>
</tr>
<tr class="even">
<td>SCC</td>
<td>5 (4 + 1)</td>
<td>Wavetable</td>
<td>MSX</td>
</tr>
<tr class="odd">
<td>SCC+</td>
<td>5</td>
<td>Wavetable</td>
<td>MSX</td>
</tr>
<tr class="even">
<td>OPLL</td>
<td>9</td>
<td>FM (2 ops) + Percusión</td>
<td>MSX-MUSIC</td>
</tr>
<tr class="odd">
<td>OPL1 + ADPCM</td>
<td>9</td>
<td>FM (2 ops) + Percusión</td>
<td>MSX-AUDIO</td>
</tr>
<tr class="even">
<td>OPL4</td>
<td>18 FM + 24 PCM</td>
<td>FM (2 o 4 ops) + Percusión + Wavetable</td>
<td>MSX</td>
</tr>
</tbody>
</table>
<h3 id="instrumentos-o-voces-fm-msx-music-y-msx-audio">Instrumentos o voces FM (MSX-MUSIC y MSX-AUDIO)</h3>
<table>
<thead>
<tr class="header">
<th><strong>Número de voz</strong></th>
<th><strong>Nombre</strong></th>
<th><strong>Número de voz</strong></th>
<th><strong>Nombre</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Piano 1</td>
<td>32</td>
<td>Piano 3</td>
</tr>
<tr class="even">
<td>1</td>
<td>Piano 2</td>
<td>33</td>
<td>Contrabajo</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Violín</td>
<td>34</td>
<td>Santur 2</td>
</tr>
<tr class="even">
<td>3</td>
<td>Flauta 1</td>
<td>35</td>
<td>Trombón</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Clarinete</td>
<td>36</td>
<td>Flauta 2</td>
</tr>
<tr class="even">
<td>5</td>
<td>Oboe</td>
<td>37</td>
<td>Clavicordio 2</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Trompeta</td>
<td>38</td>
<td>Clavicordio 3</td>
</tr>
<tr class="even">
<td>7</td>
<td>Órgano de tubo 1</td>
<td>39</td>
<td>Koto 2</td>
</tr>
<tr class="odd">
<td>8</td>
<td>Xilófono</td>
<td>40</td>
<td>Órgano de tubo 2</td>
</tr>
<tr class="even">
<td>9</td>
<td>Órgano</td>
<td>41</td>
<td>P0hdsPLA</td>
</tr>
<tr class="odd">
<td>10</td>
<td>Guitarra</td>
<td>42</td>
<td>P0hdsPRA</td>
</tr>
<tr class="even">
<td>11</td>
<td>Santur 1</td>
<td>43</td>
<td>Órgano de iglesia L</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Bajo eléctrico</td>
<td>44</td>
<td>Órgano de iglesia R</td>
</tr>
<tr class="even">
<td>13</td>
<td>Clavicordio 1</td>
<td>45</td>
<td>Violín sintético</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Clavecín 1</td>
<td>46</td>
<td>Órgano sintético</td>
</tr>
<tr class="even">
<td>15</td>
<td>Clavecín 2</td>
<td>47</td>
<td>Trombón sintético</td>
</tr>
<tr class="odd">
<td>16</td>
<td>Vibráfono</td>
<td>48</td>
<td>Trompa</td>
</tr>
<tr class="even">
<td>17</td>
<td>Koto 1</td>
<td>49</td>
<td>Shamisen</td>
</tr>
<tr class="odd">
<td>18</td>
<td>Taiko</td>
<td>50</td>
<td>Mágico</td>
</tr>
<tr class="even">
<td>19</td>
<td>Motor 1</td>
<td>51</td>
<td>Fuwawa</td>
</tr>
<tr class="odd">
<td>20</td>
<td>UFO</td>
<td>52</td>
<td>Wonderflat</td>
</tr>
<tr class="even">
<td>21</td>
<td>Campana sintética</td>
<td>53</td>
<td>Hard Rock</td>
</tr>
<tr class="odd">
<td>22</td>
<td>Chimes</td>
<td>54</td>
<td>Máquina</td>
</tr>
<tr class="even">
<td>23</td>
<td>Bajo sintético</td>
<td>55</td>
<td>Máquina V</td>
</tr>
<tr class="odd">
<td>24</td>
<td>Sintetizador</td>
<td>56</td>
<td>Cómico</td>
</tr>
<tr class="even">
<td>25</td>
<td>Batería sintética</td>
<td>57</td>
<td>FX cómico</td>
</tr>
<tr class="odd">
<td>26</td>
<td>Ritmo sintético</td>
<td>58</td>
<td>FX láser</td>
</tr>
<tr class="even">
<td>27</td>
<td>Harmo drum</td>
<td>59</td>
<td>FX ruido</td>
</tr>
<tr class="odd">
<td>28</td>
<td>Cencerro</td>
<td>60</td>
<td>FX estrella 1</td>
</tr>
<tr class="even">
<td>29</td>
<td>Charles</td>
<td>61</td>
<td>FX estrella 2</td>
</tr>
<tr class="odd">
<td>30</td>
<td>Caja</td>
<td>62</td>
<td>Motor 2</td>
</tr>
<tr class="even">
<td>31</td>
<td>Bombo</td>
<td>63</td>
<td>Voz de usuario</td>
</tr>
</tbody>
</table>
<p>Esta tabla es de utilidad en comandos que se explican más adelante como CALL VOICE, CALL VOICECOPY y en general para todas las funciones usadas por MSX-MUSIC y MSX-AUDIO. Las entradas marcadas con un color gris hacen referencia a instrumentos preconfigurados en el chip, el resto son instrumentos gestionados por VR-BASIC.</p>
<h3 id="instrumentos-de-percusión">Instrumentos de percusión</h3>
<p>Para definir la percusión en MSX-AUDIO y MSX-MUSIC se utilizan 5 códigos MML: B, S, M, C, H. La percusión no tiene diferentes notas: simplemente aplica el sonido de cada instrumento en el tiempo y momento establecidos.</p>
<table>
<thead>
<tr class="header">
<th><strong>MML</strong></th>
<th><strong>Instrumento</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B</td>
<td>Bombo</td>
</tr>
<tr class="even">
<td>S</td>
<td>Caja</td>
</tr>
<tr class="odd">
<td>M</td>
<td>TomTom</td>
</tr>
<tr class="even">
<td>C</td>
<td>Platillos</td>
</tr>
<tr class="odd">
<td>H</td>
<td>Charles</td>
</tr>
</tbody>
</table>
<h3 id="formato-del-array-de-voz">Formato del array de voz</h3>
<table>
<thead>
<tr class="header">
<th><strong>Índice</strong></th>
<th><strong>Contenido</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cabecera</td>
<td></td>
</tr>
<tr class="even">
<td>0~7</td>
<td>Nombre de la voz</td>
</tr>
<tr class="odd">
<td>8</td>
<td>Transposición de la voz (LSB)</td>
</tr>
<tr class="even">
<td>8</td>
<td>Transposición de la voz (MSB)</td>
</tr>
<tr class="odd">
<td>10</td>
<td>Bit 0= Algorithm (solo MSX-AUDIO)</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 1~3= Feedback</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 4= Fixed pitch (solo MSX-AUDIO)</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 5= AMD/PMD load function (solo MSX-AUDIO)</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 6= PMD (solo MSX-AUDIO)</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 7= AMD (solo MSX-AUDIO)</td>
</tr>
<tr class="odd">
<td>11~15</td>
<td>Reservado</td>
</tr>
<tr class="even">
<td>Operador 0</td>
<td></td>
</tr>
<tr class="odd">
<td>16</td>
<td>Bit 0~3= Multiple</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 4= Key Scale Rate</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 5= EG-Type (Sustained/Percussive tone switch)</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 6= Vibrato switch</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 7= Amplitude Modulation</td>
</tr>
<tr class="even">
<td>17</td>
<td>Bit 0~5= Total Level</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 6~7= Key Scale Level</td>
</tr>
<tr class="even">
<td>18</td>
<td>Bit 0~3= Decay rate</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 4~7= Attack rate</td>
</tr>
<tr class="even">
<td>19</td>
<td>Bit 0~3= Release rate</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 4~7= Sustain level</td>
</tr>
<tr class="even">
<td>20</td>
<td>Bit 0~3= Unused</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 4~7= Velocity sensibility (0~8) (solo MSX-AUDIO)</td>
</tr>
<tr class="even">
<td>21~23</td>
<td>Reservado</td>
</tr>
<tr class="odd">
<td>Operador 1</td>
<td></td>
</tr>
<tr class="even">
<td>24</td>
<td>Bit 0~3= Multiple</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 4= Key Scale Rate</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 5= EG-Type (Sustained/Percussive tone switch)</td>
</tr>
<tr class="odd">
<td></td>
<td>Bit 6= Vibrato switch</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 7= Amplitude Modulation</td>
</tr>
<tr class="odd">
<td>25</td>
<td>Bit 0~5= Total Level (solo MSX-AUDIO)</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 6~7= Key Scale Level</td>
</tr>
<tr class="odd">
<td>26</td>
<td>Bit 0~3= Decay rate</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 4~7= Attack rate</td>
</tr>
<tr class="odd">
<td>27</td>
<td>Bit 0~3= Release rate</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 4~7= Sustain level</td>
</tr>
<tr class="odd">
<td>28</td>
<td>Bit 0~3= Unused</td>
</tr>
<tr class="even">
<td></td>
<td>Bit 4~7= Velocity sensibility (0~8) (solo MSX-AUDIO)</td>
</tr>
<tr class="odd">
<td>29~31</td>
<td>Reservado</td>
</tr>
</tbody>
</table>
<h3 id="midi">MIDI</h3>
<p>MIDI (Musical Instrument Digital Interface) es un <a href="https://es.wikipedia.org/wiki/Norma_(tecnolog%C3%ADa)">estándar tecnológico</a> que describe un <a href="https://es.wikipedia.org/wiki/Protocolo_de_comunicaciones">protocolo</a>, una <a href="https://es.wikipedia.org/wiki/Electr%C3%B3nica_digital">interfaz digital</a> y <a href="https://es.wikipedia.org/wiki/Conector_el%C3%A9ctrico">conectores</a> que permiten que varios <a href="https://es.wikipedia.org/wiki/Instrumento_musical_electr%C3%B3nico">instrumentos musicales electrónicos</a>, <a href="https://es.wikipedia.org/wiki/Computadora">ordenadores</a> y otros dispositivos relacionados se conecten y comuniquen entre sí.</p>
<h2 id="puertos-de-entrada-y-salida">Puertos de entrada y salida</h2>
<p>Los puertos de entrada y salida para los MSX se codifican en un número entero que va del 0 al 255. A continuación, se muestra una tabla<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> con los distintos dispositivos a los que se puede acceder según sea el número de puerto utilizado. Nótese que, en algunos casos, distintos fabricantes pueden llegar a usar el mismo puerto.</p>
<table>
<thead>
<tr class="header">
<th><strong>Puerto &amp;H</strong></th>
<th><strong>Dispositivo</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>00-01</td>
<td>Salida MIDI del Music Module</td>
</tr>
<tr class="even">
<td>00-01</td>
<td>Cartucho Sony Sensor Kid</td>
</tr>
<tr class="odd">
<td>02-03</td>
<td>Interfaz MIDI FAC</td>
</tr>
<tr class="even">
<td>04-05</td>
<td>Entrada MIDI del Music Module</td>
</tr>
<tr class="odd">
<td>0A</td>
<td>DAC del Music Module</td>
</tr>
<tr class="even">
<td>0F</td>
<td>MegaRAMs de Zemina</td>
</tr>
<tr class="odd">
<td>10-11</td>
<td>MegaFlashROM PSG</td>
</tr>
<tr class="even">
<td>14-17</td>
<td>Cartucho YM2608 OPNA</td>
</tr>
<tr class="odd">
<td>18-19</td>
<td>Lector de código de barras Philips NMS-1170/20</td>
</tr>
<tr class="even">
<td>20-28</td>
<td>Modem Philips NMS1251</td>
</tr>
<tr class="odd">
<td>20-28</td>
<td>Modem Miniware M4000</td>
</tr>
<tr class="even">
<td>21-27</td>
<td>Reproductor MP3 de Sunrise</td>
</tr>
<tr class="odd">
<td>27-2F</td>
<td>Interfaz serie Philips NMS 1210/1211/1212</td>
</tr>
<tr class="even">
<td>28-29</td>
<td>Interfaz Ethernet DenYoNet</td>
</tr>
<tr class="odd">
<td>2A-2B</td>
<td>Cartucho PlaySoniq</td>
</tr>
<tr class="even">
<td>30-38</td>
<td>Modem Philips NMS-1251</td>
</tr>
<tr class="odd">
<td>30-38</td>
<td>Modem Miniware M4000</td>
</tr>
<tr class="even">
<td>30-38</td>
<td>Interfaz SCSI GREEN/MAK</td>
</tr>
<tr class="odd">
<td>30-38</td>
<td>Interfaz CD-ROM Philips NMS-0210</td>
</tr>
<tr class="even">
<td>37-3F</td>
<td>Modem Philips NMS-1250/1255</td>
</tr>
<tr class="odd">
<td>37-3F</td>
<td>Interfaz serie Philips NMS-1210/1211/1212)</td>
</tr>
<tr class="even">
<td>3C</td>
<td>Musical Memory Mapper - registro de control</td>
</tr>
<tr class="odd">
<td>3F</td>
<td>Musical Memory Mapper - SN76489 registro de control</td>
</tr>
<tr class="even">
<td>40-4F</td>
<td>Permite intercambiar puertos E/S</td>
</tr>
<tr class="odd">
<td>48-49</td>
<td>Cartucho Franky (SN76489 y VDP)</td>
</tr>
<tr class="even">
<td>50-6F</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="odd">
<td>50-53</td>
<td>Pack de fuente Hangul</td>
</tr>
<tr class="even">
<td>5E-5F</td>
<td>Interfaz Ethernet GR8NET</td>
</tr>
<tr class="odd">
<td>60-6F</td>
<td>Graphics9000 / V9990</td>
</tr>
<tr class="even">
<td>70-73</td>
<td>Cartucho Midi Saurus (Bit2)</td>
</tr>
<tr class="odd">
<td>74-7B</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="even">
<td>77</td>
<td>Super Game 90</td>
</tr>
<tr class="odd">
<td>7C-7D</td>
<td>MSX-Music (OPLL)</td>
</tr>
<tr class="even">
<td>7E-7F</td>
<td>Cartucho MoonSound (OPL4)</td>
</tr>
<tr class="odd">
<td>80-83</td>
<td>RS-232C UART (8251)</td>
</tr>
<tr class="even">
<td>84-87</td>
<td>RS-232C Temporizador programable (8253)</td>
</tr>
<tr class="odd">
<td>88-8B</td>
<td>Acceso a los puertos VDP externos</td>
</tr>
<tr class="even">
<td>8C-8D</td>
<td>Modem MSX</td>
</tr>
<tr class="odd">
<td>8E-8F</td>
<td>MegaRam DDX</td>
</tr>
<tr class="even">
<td>8E-8F</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="odd">
<td>90-91</td>
<td>Puerto de impresora</td>
</tr>
<tr class="even">
<td>94</td>
<td>Puerto de control de dirección para impresora</td>
</tr>
<tr class="odd">
<td>92-97</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="even">
<td>98-9B</td>
<td>Acceso a los puertos VDP</td>
</tr>
<tr class="odd">
<td>9C-9F</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="even">
<td>A0-A2</td>
<td>PSG (AY-3-8910/YM2149)</td>
</tr>
<tr class="odd">
<td>A4-A5</td>
<td>MSX turbo R PCM</td>
</tr>
<tr class="even">
<td>A6</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="odd">
<td>A7</td>
<td>MSX turbo R - Leds de Pausa y R800. Registro de control</td>
</tr>
<tr class="even">
<td>A8-AB</td>
<td>PPI (8255/ULA9RA041)</td>
</tr>
<tr class="odd">
<td>AC-AF</td>
<td>Control 1chipMSX</td>
</tr>
<tr class="even">
<td>B0-B3</td>
<td>Cartuchos Sony HBI-55 y Yamaha UDC-01 (PPI 8255 externo)</td>
</tr>
<tr class="odd">
<td>B4-B5</td>
<td>Real Time Clock (RP-5C01)</td>
</tr>
<tr class="even">
<td>B6-B7</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="odd">
<td>B8-BB</td>
<td>Lápiz óptico Sanyo</td>
</tr>
<tr class="even">
<td>BC-BF</td>
<td>Controlador VHD</td>
</tr>
<tr class="odd">
<td>C0-C1</td>
<td>MSX Audio/Music Module (principal)</td>
</tr>
<tr class="even">
<td>C2-C3</td>
<td>MSX Audio/Music Module (secundario)</td>
</tr>
<tr class="odd">
<td>C0-C3</td>
<td>Moonsound / OPL4 (alternativos)</td>
</tr>
<tr class="even">
<td>C4-C7</td>
<td>Moonsound / OPL4</td>
</tr>
<tr class="odd">
<td>C8-CC</td>
<td>Interfaz serie asíncrono</td>
</tr>
<tr class="even">
<td>D0-D7</td>
<td>Controlador disco flexible Microsol (WD2793)</td>
</tr>
<tr class="odd">
<td>D8-D9</td>
<td>Kanji Rom nivel 1</td>
</tr>
<tr class="even">
<td>DA-DB</td>
<td>Kanji Rom nivel 2</td>
</tr>
<tr class="odd">
<td>DC</td>
<td>Reservado para extensión Kanji ROM</td>
</tr>
<tr class="even">
<td>DC-DD</td>
<td>Cartucho PlaySoniq (mando de juegos Sega)</td>
</tr>
<tr class="odd">
<td>E4-E5</td>
<td>MSX turbo R - S1990</td>
</tr>
<tr class="even">
<td>E6-E7</td>
<td>MSX turbo R - S1990 (temporizador)</td>
</tr>
<tr class="odd">
<td>F3</td>
<td>MSX2+ registro modo de pantalla</td>
</tr>
<tr class="even">
<td>F4</td>
<td>MSX2+ o superior. Registro de estado</td>
</tr>
<tr class="odd">
<td>F5</td>
<td>Registros de control internos</td>
</tr>
<tr class="even">
<td>F6</td>
<td>Colors bus</td>
</tr>
<tr class="odd">
<td>F7</td>
<td>NTSC A/V registro de control</td>
</tr>
<tr class="even">
<td>F8</td>
<td>PAL A/V registro de control</td>
</tr>
<tr class="odd">
<td>F9-FB</td>
<td>Puertos reservados para el sistema</td>
</tr>
<tr class="even">
<td>F8-FB</td>
<td>Cartucho PlaySoniq</td>
</tr>
<tr class="odd">
<td>FC-FF</td>
<td>Mapper de memoria</td>
</tr>
</tbody>
</table>
<h2 id="dispositivos-de-archivo">Dispositivos de archivo</h2>
<p>En el acceso a archivos mediante ordenes VR-BASIC, el elemento a utilizar se especifica mediante el nombre del dispositivo. Se pueden utilizar los siguientes:</p>
<table>
<thead>
<tr class="header">
<th>CAS:</th>
<th>Grabador/Reproductor de casetes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CRT:</td>
<td>Pantalla modo texto</td>
</tr>
<tr class="even">
<td>GRP:</td>
<td>Pantalla modo gráfico</td>
</tr>
<tr class="odd">
<td>LPT:</td>
<td>Impresora</td>
</tr>
<tr class="even">
<td>MEM:</td>
<td>RAM-Disk</td>
</tr>
<tr class="odd">
<td>A: ~ H:</td>
<td>Nombre de unidad de discos compatible con versiones MSX</td>
</tr>
<tr class="even">
<td>&lt;nombre&gt;:</td>
<td>Cualquier nombre seguido de dos puntos para unidades MSXVR</td>
</tr>
</tbody>
</table>
<h4 id="ram-disk">RAM-DISK</h4>
<p>Para guardar ficheros de programa y de datos se utilizan discos flexibles FDD y cintas de casete, además de otros dispositivos USB que puedan actuar como unidades de almacenamiento. Junto a estas opciones, el VR-BASIC tiene una función que ofrece la posibilidad de utilizar una parte de la memoria interna como dispositivo de memoria a efectos de almacenamiento de ficheros. Este tipo de dispositivo recibe el nombre de RAM-Disk.</p>
<p>La RAM-Disk es volátil y toda la información que contenga desaparecerá tras apagar el ordenador o cerrar la aplicación VR-BASIC.</p>
<h2 id="función-de-las-teclas-y-su-utilización">Función de las teclas y su utilización</h2>
<p>La consola VR-BASIC permite efectuar la modificación y adición de caracteres mediante el desplazamiento del cursor a una posición cualquiera de la pantalla. Con esta función podrá realizar con suma facilidad la edición o la corrección de los programas.</p>
<p>El editor de pantalla permite modificar cualquier carácter presente en la pantalla, y al pulsar la tecla ENTER se introduce en la memoria del ordenador la línea donde esté situado el cursor en ese momento. Cuando el principio de una línea es un número, la línea resulta almacenada en memoria como línea de programa, y cuando no es un número, la línea es ejecutada directamente.</p>
<h4 id="teclas-de-edición">TECLAS DE EDICIÓN</h4>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>Tecla</th>
<th>Función</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cursores</td>
<td>Mueven el cursor un carácter, hacia arriba, hacia abajo, a la izquierda o a la derecha.</td>
</tr>
<tr class="even">
<td>HOME</td>
<td>Mueve el cursor a la esquina superior izquierda de la pantalla.</td>
</tr>
<tr class="odd">
<td>SHIFT + HOME</td>
<td>Borra todos los caracteres de la pantalla y mueve el cursor a la esquina superior izquierda de la pantalla.</td>
</tr>
<tr class="even">
<td>INS</td>
<td>Permite entrar al modo de inserción (el cursor disminuye su tamaño). Todos los caracteres introducidos por el teclado tras la pulsación de esa tecla quedan insertados en la posición del cursor. Para volver al modo normal, pulsar otra vez la tecla INS y la tecla ENTER o una tecla de desplazamiento del cursor.</td>
</tr>
<tr class="odd">
<td>DEL</td>
<td>Borra el carácter que coincide con la posición del cursor. Los caracteres siguientes se desplazan un espacio a la izquierda.</td>
</tr>
<tr class="even">
<td>BS</td>
<td>Borra el carácter situado delante del cursor. Los caracteres se desplazan un espacio a la izquierda.</td>
</tr>
<tr class="odd">
<td>TAB</td>
<td>Adelanta el cursor a la siguiente posición de tabulador, y si hay caracteres en medio, deja un espacio.</td>
</tr>
<tr class="even">
<td>CTRL + B</td>
<td>Desplaza el cursor al principio de una palabra (grupo de caracteres separados por un espacio). Cuando el cursor ya está en el principio de una palabra, pasa al principio de la palabra inmediatamente anterior.</td>
</tr>
<tr class="odd">
<td>CTRL + C</td>
<td>Activa el estado de espera de entrada o la generación automática de número de línea por la orden AUTO para volver al estado de espera de orden.</td>
</tr>
<tr class="even">
<td>CTRL + E</td>
<td>Borra todo lo escrito desde la posición del cursor hasta la última línea.</td>
</tr>
<tr class="odd">
<td>CTRL + F</td>
<td>Desplaza el cursor al principio de la palabra siguiente.</td>
</tr>
<tr class="even">
<td>CTRL + G</td>
<td>Genera un pitido (bip).</td>
</tr>
<tr class="odd">
<td>CTRL + H</td>
<td>Igual que la tecla BS.</td>
</tr>
<tr class="even">
<td>CTRL + I</td>
<td>Igual que la tecla TAB.</td>
</tr>
<tr class="odd">
<td>CTRL + J</td>
<td>Desplaza el cursor una línea hacia abajo.</td>
</tr>
<tr class="even">
<td>CTRL + K</td>
<td>Igual que HOME.</td>
</tr>
<tr class="odd">
<td>CTRL + L</td>
<td>Igual que SHIFT + HOME.</td>
</tr>
<tr class="even">
<td>CTRL + M</td>
<td>Igual que ENTER.</td>
</tr>
<tr class="odd">
<td>CTRL + N</td>
<td>Desplaza el cursor a la posición siguiente al último carácter de la línea.</td>
</tr>
<tr class="even">
<td>CTRL + R</td>
<td>Igual que INS.</td>
</tr>
<tr class="odd">
<td>CTRL + U</td>
<td>Borra todos los caracteres de una línea.</td>
</tr>
<tr class="even">
<td>CTRL + X</td>
<td>Igual que SELECT.</td>
</tr>
</tbody>
</table>
<h4 id="teclas-de-función-1">TECLAS DE FUNCIÓN</h4>
<p>Las teclas F1 a F5 reciben el nombre de teclas de función. Para cada una de estas teclas, se puede definir una cadena de caracteres de manera que su pulsación surte los mismos efectos que introducir esa misma cadena en el editor. Para definir el texto asociado a cada tecla se usa el comando KEY.</p>
<h4 id="otras-teclas-de-control">OTRAS TECLAS DE CONTROL</h4>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>STOP</th>
<th>Detiene temporalmente la ejecución de un programa VR‑BASIC. Pulsar esta tecla otra vez para continuar con la ejecución del programa.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CTRL + STOP</td>
<td>Interrumpe la ejecución de un programa VR-BASIC. En el estado de generación automática de número de línea, consecuencia de una instrucción AUTO, produce el paso al estado de espera de órdenes.</td>
</tr>
</tbody>
</table>
<h2 id="funcionalidades-adicionales">Funcionalidades adicionales</h2>
<p>Convendría comentar características que encontrará en el VR-BASIC y no en los MSX-BASIC:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Máximo número de línea</th>
<th>En los MSX-BASIC el límite para el número de línea usado en los programas es de 65529, mientras que en MSXVR el límite es de más de 2 millones de líneas.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Etiquetas</td>
<td>En MSX-BASIC no existe la funcionalidad para agregar etiquetas en el código. En MSXVR sí es posible.</td>
</tr>
<tr class="even">
<td>Editor</td>
<td>En MSX-BASIC solo se dispone de la consola estándar. En MSXVR, además, se tiene el comando CALL EDIT que permite el uso de un editor más avanzado con resaltado de sintaxis entre otras funcionalidades.</td>
</tr>
<tr class="odd">
<td>Depurador</td>
<td>En MSX-BASIC no se puede depurar el código. En MSXVR es posible iniciar el depurador mediante CALL DEBUG o mediante el atajo de teclado CTRL + D.</td>
</tr>
<tr class="even">
<td>Unidades de disco</td>
<td>En DISK-BASIC el límite de unidades es de 9 (A: hasta H:) mientras que en un MSXVR no existe límite de unidades y se les puede poner nombres de más de un carácter.</td>
</tr>
<tr class="odd">
<td>Screen 13</td>
<td>En MSXVR existe un modo gráfico nuevo que permite una paleta de colores de 24 bits de resolución y 256 colores simultáneos por pantalla.</td>
</tr>
<tr class="even">
<td>VRAM</td>
<td>El MSXVR usa el chip VDP9968 que incorpora hasta 4Mb de memoria, lo cual permite mayor número de páginas para los distintos modos gráficos bitmap existentes.</td>
</tr>
</tbody>
</table>
<h2 id="lista-de-comandos-y-funciones">Lista de comandos y funciones</h2>
<p>A continuación, se irán detallando los diferentes comandos y funciones disponibles en VR‑BASIC. En todos ellos veremos:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>NOMBRE</th>
<th>La cadena de texto que hace referencia al comando que los invoca.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMENTARIO</td>
<td>Breve explicación del comportamiento del comando y qué es lo que hace.</td>
</tr>
<tr class="even">
<td>VERSIÓN</td>
<td>En qué versiones de MSX-BASIC está disponible.</td>
</tr>
<tr class="odd">
<td>FORMATO</td>
<td>El formato de la llamada, qué parámetros requiere y cuáles son opcionales.</td>
</tr>
<tr class="even">
<td>PARÁMETROS</td>
<td>La explicación de cada uno de los parámetros y qué valores se les puede pasar.</td>
</tr>
<tr class="odd">
<td>RETORNO</td>
<td>En caso de devolver algún valor, de qué tipo se trata y si hay que considerar alguna cosa.</td>
</tr>
<tr class="even">
<td>EJEMPLOS</td>
<td>Uno o varios ejemplos donde se muestran el uso del comando o aspectos excepcionales de su uso.</td>
</tr>
</tbody>
</table>
<h2 id="abs">ABS</h2>
<p>Ofrece el valor absoluto de un dato numérico.</p>
<p>Devuelve X cuando X &gt;= 0 y cuando X &lt; 0.</p>
<h3 id="versión">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato">Formato</h3>
<pre><code>ABS(X)</code></pre>
<h3 id="parámetros">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz o sus expresiones (numéricas)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno">Retorno</h3>
<p>Tipo numérico</p>
<h3 id="ejemplos">Ejemplos</h3>
<pre><code>PRINT ABS(2)
 2</code></pre>
<pre><code>PRINT ABS(3-10)
 7</code></pre>
<h2 id="asc">ASC</h2>
<p>Ofrece el código ASCII correspondiente al primer carácter del dato de cadena.</p>
<h3 id="versión-1">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-1">Formato</h3>
<pre><code>ASC(X$)</code></pre>
<h3 id="parámetros-1">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes variables, variables de matriz, sus expresiones (de cadena)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-1">Retorno</h3>
<p>Expresiones decimales, de tipo entero.</p>
<h3 id="ejemplos-1">Ejemplos</h3>
<pre><code>PRINT ASC(&quot;d&quot;)
 100    Código de carácter correspondiente a &quot;d&quot;</code></pre>
<pre><code>PRINT ASC(&quot;data&quot;)
 100    Código de carácter correspondiente a &quot;d&quot;</code></pre>
<h2 id="atn">ATN</h2>
<p>Ofrece el valor del arcotangente correspondiente a un dato numérico.</p>
<p>La función ATN da un valor numérico de coma flotante que corresponde a un ángulo cuya tangente es X. Su unidad es el radián.</p>
<p>Para obtener el resultado en grados, debe multiplicarse por 180/<br /><span class="math display"><em>π</em></span><br />.</p>
<h3 id="versión-2">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-2">Formato</h3>
<pre><code>ATN(X)  </code></pre>
<h3 id="parámetros-2">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-2">Retorno</h3>
<p>Tipo numérico expresado en radianes.</p>
<h3 id="ejemplos-2">Ejemplos</h3>
<pre><code>PRINT ATN(1)
 .78539816339745        resultado en radianes</code></pre>
<pre><code>PRINT ATN(1)*180/3.14149
 45.000038009905        resultado en grados</code></pre>
<h2 id="auto">AUTO</h2>
<p>Produce la generación automática de números de línea a partir de un número de línea especificado y con un incremento especificado.</p>
<p>Sirve para eliminar la necesidad de teclear los números de línea a la hora de introducir un programa por el teclado.</p>
<p>Cuando un número de línea generado automáticamente tiene ya asociada una instrucción de programa, sale un asterisco “*” a la derecha del número de línea. Para modificar esta instrucción de programa, se debe mover el cursor al asterisco y luego introducir una nueva instrucción tras borrar el asterisco pulsando la tecla DEL o espacio. Cuando no es preciso modificarla, basta con pulsar ENTER.</p>
<p>Para poner fin a la generación automática de números de línea, se debe pulsar STOP manteniendo pulsada CTRL al mismo tiempo, o pulsar C manteniendo pulsada CTRL al mismo tiempo.</p>
<h3 id="versión-3">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-3">Formato</h3>
<pre><code>AUTO (número de línea inicial) (,incremento)</code></pre>
<h3 id="parámetros-3">Parámetros</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea inicial</th>
<th><strong>Cond.</strong> Constantes tipo entero, 0≤número≤65529 <strong>Omit</strong>. 0. Pero si también se omite el incremento, es 10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Incremento</td>
<td><strong>Cond</strong>. Constantes tipo entero, 1≤incremento≤65529 <strong>Omit.</strong> 10.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-3">Ejemplos</h3>
<pre><code>AUTO 100,50</code></pre>
<pre><code>100 PRINT &quot;12345&quot;
150*</code></pre>
<blockquote>
<p>indica que ya existe el número de línea 150</p>
</blockquote>
<h2 id="base">BASE</h2>
<p>Sirve para leer o escribir una dirección base de la tabla del VDP (<em>Video Display Processor,</em> o lo que sería el Procesador de pantalla de vídeo).</p>
<p>Para asignar valores se pueden utilizar los modos SCREEN 0 a 3.</p>
<p>El comando admite un parámetro N que se calcula de la siguiente forma:</p>
<p>Modo SCREEN * 5 + número de tabla</p>
<p>Por ejemplo, el valor N de la dirección de la tabla de atributos de los sprites en SCREEN 2 (tabla nº3) se calcula así: N = 2 * 5 + 3 = 13</p>
<table>
<thead>
<tr class="header">
<th><strong>Tabla Nº</strong></th>
<th><strong>Tabla</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Tabla de nombres de configuraciones</td>
</tr>
<tr class="even">
<td>1</td>
<td>Tabla de colores</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Tabla de generadores de configuraciones</td>
</tr>
<tr class="even">
<td>3</td>
<td>Tabla de atributos de los sprites</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Tabla de configuraciones de los sprites</td>
</tr>
</tbody>
</table>
<p>Se deben utilizar las fórmulas siguientes para determinar la dirección o el modo SCREEN cuando está incluido en el valor de N:</p>
<p>Modo SCREEN INT (N/5)</p>
<p>Nº de tabla (N MOD 5)</p>
<p>Por ejemplo, cuando N = 44, el modo de SCREEN sería 44 / 5 = 8 y el número de tabla sería 44 MOD 5 = 4.</p>
<h3 id="versión-4">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-4">Formato</h3>
<pre><code>BASE (N)</code></pre>
<h3 id="parámetros-4">Parámetros</h3>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Valores a leer: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤valores&lt;45. Valores a asignar: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤valores&lt;20.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="beep">BEEP</h2>
<p>Genera un pitido.</p>
<h3 id="versión-5">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-5">Formato</h3>
<pre><code>BEEP</code></pre>
<h3 id="ejemplos-4">Ejemplos</h3>
<pre><code>10 FOR I=0 TO 9
20 BEEP
30 NEXT 1</code></pre>
<p>Este programa genera un pitido que se repite 10 veces consecutivamente.</p>
<h2 id="bin">BIN$</h2>
<p>Ofrece, en formato alfanumérico, la expresión binaria de un dato numérico.</p>
<h3 id="versión-6">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-6">Formato</h3>
<pre><code>BIN$(x)</code></pre>
<h3 id="parámetros-5">Parámetros</h3>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (número); -32768≤X&lt;65536. En caso de un número negativo, tiene el mismo valor que si se sumara su valor a 65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-3">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-5">Ejemplos</h3>
<pre><code>PRINT BIN$ (100)
1100100</code></pre>
<pre><code>PRINT BIN$ (-32768)
1000000000000000</code></pre>
<h2 id="bload">BLOAD</h2>
<p>Carga un programa en lenguaje máquina a la memoria del ordenador, o lo carga y ejecuta.</p>
<p>Carga un fichero en la RAM de vídeo.</p>
<p>Carga un programa que había sido almacenado mediante la orden BSAVE en la zona de memoria comprendida entre la dirección inicial y la dirección final que se especificaron en la orden BSAVE. Si se ha especificado un desplazamiento, sumará dicho valor a la dirección inicial y a la dirección final.</p>
<p>Si se ha especificado la opción R, el programa será ejecutado inmediatamente después de ser cargado. La dirección de ejecución será la dirección especificada en la orden BSAVE.</p>
<p>Si se ha especificado la opción S, cargará el contenido de la RAM de vídeo almacenada mediante la orden BSAVE con la opción S. En el caso de SCREEN 5 a 13, cargará el contenido en la página activa.</p>
<h3 id="versión-7">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-7">Formato</h3>
<pre><code>BLOAD &quot;[nombre del dispositivo]nombre del fichero[.extensión]&quot; { [,R][,S] } [,desplazamiento]</code></pre>
<h3 id="parámetros-6">Parámetros</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del dispositivo</th>
<th><strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 caracteres o menos. Una cadena de 8 caracteres o menos. <strong>Omit.</strong> Carga el primer fichero encontrado en la cinta. (No se puede omitir con DISK-BASIC).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 caracteres o menos. <strong>Omit</strong> Cadena nula.</td>
</tr>
<tr class="odd">
<td>Opción R</td>
<td><strong>Omit.</strong> Únicamente carga (no ejecuta el programa).</td>
</tr>
<tr class="even">
<td>Opción S</td>
<td><strong>Omit.</strong> Carga el programa en la memoria principal.</td>
</tr>
<tr class="odd">
<td>Desplazamiento</td>
<td><strong>Cond.</strong> Un entero. <strong>Omit.</strong> 0.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-6">Ejemplos</h3>
<pre><code>BLOAD &quot;CAS:PROG4&quot;</code></pre>
<p>Esta sentencia inicia la búsqueda de la cabecera de un programa con nombre PROG4 y en caso de encontrarlo, lo cargará en memoria.</p>
<pre><code> BLOAD &quot;A:PROG.BIN&quot;, R</code></pre>
<p>Carga un programa con nombre PROG.BIN que se encuentre en la unidad A: y lo ejecuta.</p>
<pre><code>10 SCREEN 2
 20 BLOAD &quot;a:box&quot;, S
30 GOTO 30</code></pre>
<p>La línea 20 carga el contenido de la RAM de vídeo que había sido guardado en el ejemplo incluido en la sección BSAVE. En consecuencia, aparece en pantalla un rectángulo.</p>
<h2 id="bsave">BSAVE</h2>
<p>Almacena el contenido, byte a byte, de la memoria principal especificada.</p>
<p>Almacena el contenido, byte a byte, especificado de la RAM de vídeo.</p>
<p>Almacena el contenido de la memoria principal comprendida entre la dirección inicial y la dirección final. Sirve para almacenar tanto datos como programas en lenguaje máquina que residan en ese rango de direcciones.</p>
<p>Si se especifica la dirección de inicio de ejecución, cuando se cargue el programa mediante una instrucción BLOAD con opción R, la ejecución comenzará en la dirección especificada. Si se omite, la dirección de inicio de la ejecución es la dirección inicial.</p>
<p>Cuando se especifica la opción S, almacena, en forma de fichero, el contenido de la RAM de vídeo especificada.</p>
<p>En el caso de SCREEN 5 a 13, almacenará el contenido de la página activa.</p>
<p>Direcciones de la VRAM utilizadas para visualizar la primera página:</p>
<table>
<thead>
<tr class="header">
<th><strong>SCREEN</strong></th>
<th><strong>DIRECCIÓN</strong></th>
<th><strong>Páginas con 128K VRAM</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>0 - &amp;H3C20</td>
<td>8</td>
</tr>
<tr class="even">
<td>3</td>
<td>0 - &amp;H2040</td>
<td>32</td>
</tr>
<tr class="odd">
<td>4</td>
<td>0 - &amp;H3C20</td>
<td>8</td>
</tr>
<tr class="even">
<td>5</td>
<td>0 - &amp;H76A0</td>
<td>4</td>
</tr>
<tr class="odd">
<td>6</td>
<td>0 - &amp;H76A0</td>
<td>4</td>
</tr>
<tr class="even">
<td>7</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
<tr class="odd">
<td>8</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
<tr class="even">
<td>10</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
<tr class="odd">
<td>11</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
<tr class="even">
<td>12</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
<tr class="odd">
<td>13</td>
<td>0 - &amp;HFAA0</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="versión-8">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-8">Formato</h3>
<pre><code>BSAVE &quot;[nombre del dispositivo] nombre del fichero[.extensión]&quot;, dirección inicial, dirección final { [,dirección de inicio de la ejecución] [,S] }</code></pre>
<h3 id="parámetros-7">Parámetros</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del dispositivo</th>
<th><strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 caracteres o menos. Una cadena de 8 caracteres o menos. <strong>Omit.</strong> Una cadena nula. (No se puede omitir en DISK-BASIC).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond</strong>. Una cadena de 3 caracteres o menos. <strong>Omit.</strong> Cadena nula.</td>
</tr>
<tr class="odd">
<td>Dirección inicial, dirección final</td>
<td><strong>Cond.</strong> Constantes de tipo entero; -32768≤dirección≤65535.</td>
</tr>
<tr class="even">
<td>Dirección de inicio de la ejecución</td>
<td><strong>Cond.</strong> Constantes de tipo entero; -32768≤dirección≤65535. <strong>Omit.</strong> La misma que la dirección inicial.</td>
</tr>
<tr class="odd">
<td>Opción S</td>
<td><strong>Omit.</strong> Almacena el programa que hay en la memoria RAM de vídeo.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplo">Ejemplo</h3>
<pre><code>BSAVE &quot;CAS:PROG4&quot;, &amp;HE000, &amp;HE800, &amp;HE100</code></pre>
<p>Esta sentencia guarda en casete un programa con nombre PROG4 ubicado en memoria entre la dirección &amp;HE000 y la &amp;HE800, especificando la dirección de ejecución &amp;HE100.</p>
<pre><code> BSAVE &quot;B:PROG.BIN&quot;, &amp;HE000, &amp;HE800</code></pre>
<p>Esta sentencia guarda en el disco B: un programa con nombre PROG.BIN que se encuentra ubicado entre las direcciones &amp;HE000 y &amp;HE800.</p>
<pre><code>10 SCREEN 2
20 COLOR = (15, 2, 6, 7)
30 LINE (30, 30)-(130,100),, BF
 40 BSAVE &quot;A:BOX&quot;, 0, &amp;H3FFF, S</code></pre>
<p>Este programa, tras dibujar en la pantalla un recuadro rectangular (línea 30), almacena todo el contenido de la RAM de vídeo (desde la dirección 0 a la dirección &amp;H3FFF) con el nombre de fichero “BOX” (línea 40, orden BSAVE con la opción S).</p>
<h2 id="call">CALL</h2>
<p>Ejecuta una orden extendida.</p>
<p>Cuando hay órdenes extendidas, se pueden ejecutar mediante una instrucción CALL.</p>
<p>En lugar de escribir CALL, se puede escribir el símbolo de subrayado (_).</p>
<p>Órdenes extendidas de DISK-BASIC y RAM-Disk.</p>
<p>La instrucción CALL sirve para extender el VR-BASIC, por ejemplo cuando se trabaja con un disco flexible o con RAM-Disk. Con la instrucción CALL se pueden utilizar las siguientes órdenes extendidas: FORMAT, SYSTEM, MEMINI, MFILES, MKILL, MNAME.</p>
<h3 id="versión-9">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-9">Formato</h3>
<pre><code>CALL orden extendida [(argumento, argumento, ...)]</code></pre>
<pre><code>Orden extendida [(argumento, argumento, ...)]</code></pre>
<h3 id="parámetros-8">Parámetros</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Argumento</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero). Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="call-audio">CALL AUDIO</h2>
<p>Inicializa los modos de reproducción de música utilizados en VR-BASIC. Se pueden utilizar los siguientes modos:</p>
<table>
<thead>
<tr class="header">
<th><strong>Modo</strong></th>
<th><strong>Canales música FM</strong></th>
<th><strong>Canales ritmo FM</strong></th>
<th><strong>PCM</strong></th>
<th><strong>Tipo</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>9</td>
<td>0</td>
<td></td>
<td>Normal</td>
</tr>
<tr class="even">
<td>1(por defecto)</td>
<td>6</td>
<td>3</td>
<td></td>
<td>Normal</td>
</tr>
<tr class="odd">
<td>2</td>
<td>9</td>
<td>0</td>
<td>1</td>
<td>Normal</td>
</tr>
<tr class="even">
<td>3</td>
<td>6</td>
<td>3</td>
<td>1</td>
<td>Normal</td>
</tr>
<tr class="odd">
<td>4</td>
<td>9</td>
<td>0</td>
<td></td>
<td>CSM</td>
</tr>
<tr class="even">
<td>5</td>
<td>6</td>
<td>3</td>
<td></td>
<td>CSM</td>
</tr>
<tr class="odd">
<td>6</td>
<td>9</td>
<td>0</td>
<td>1</td>
<td>CSM</td>
</tr>
<tr class="even">
<td>7</td>
<td>6</td>
<td>3</td>
<td>1</td>
<td>CSM</td>
</tr>
</tbody>
</table>
<p>En el tipo CSM (Modelado Sinusoidal Compuesto), el control de todos los sonidos de FM (melodía y ritmo) deja de ser válido. Usando todos los operadores en paralelo, este modo se puede usar para sintetizar voces. Las cadenas PLAY 5 a 7 eventualmente se usarán para los 3 canales PSG.</p>
<h3 id="versión-10">Versión</h3>
<p>MSX-AUDIO, MSXVR</p>
<h3 id="formato-10">Formato</h3>
<pre><code>CALL AUDIO (Modo, Canales Instrumento, Canales Cadena1, Canales Cadena2, ..., Canales Cadena9)</code></pre>
<h3 id="parámetros-9">Parámetros</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th>0 - 7. <strong>Omit</strong>. 1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Canales instrumento</td>
<td>Canales por instrumento.</td>
</tr>
<tr class="even">
<td>Canales cadena</td>
<td>Permite especificar cuántos canales se utilizan para cada cadena de melodía FM en la instrucción PLAY.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-7">Ejemplos</h3>
<p>MSX-AUDIO en modo 0 con 1 canal para cada cadena PLAY (1 a 9), con todos los canales asignados a un instrumento, no PCM, modo normal.</p>
<p>10 CALL AUDIO(0,9,1,1,1,1,1,1,1,1,1)</p>
<pre><code>MSX-AUDIO en modo 3 con 2 canales para la cadena PLAY 1, 1 canal para la cadena PLAY 2; y 3 canales para la cadena PLAY 3, canales no asignados a un instrumento, PCM, modo normal.</code></pre>
<pre><code>10 CALL AUDIO(3,0,2,1,3)</code></pre>
<h2 id="call-audiodriverbaseport">CALL AUDIODRIVERBASEPORT</h2>
<p>Establece los puertos a usar para los distintos chips de sonido implementados en el VR‑BASIC.</p>
<h3 id="versión-11">Versión</h3>
<p>MSXVR</p>
<h3 id="formato-11">Formato</h3>
<pre><code>CALL AUDIODRIVERBASEPORT (dispositivo, puerto)</code></pre>
<h3 id="parámetros-10">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Dispositivo</th>
<th>0 = PSG, 1 = OPLL, 2 = OPL1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Puerto</td>
<td>Puerto inicial al cual redireccionar.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-8">Ejemplos</h3>
<pre><code>10 CALL AUDIODRIVERBASEPORT(0,&amp;hA0)</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="call-audreg">CALL AUDREG</h2>
<p>Permite escribir directamente a un registro del chip de audio.</p>
<p>Notas:</p>
<ul>
<li><p>Esta instrucción puede no ser efectiva para un registro frecuentemente escrito por el software del sistema, por ejemplo, interrupciones.</p></li>
<li><p>En algunos casos, puede ser necesario reiniciar el sistema para ejecutar esta instrucción.</p></li>
<li><p>Esta instrucción no se puede usar para MSX-MIDI.</p></li>
</ul>
<h3 id="versión-12">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-12">Formato</h3>
<pre><code>CALL AUDREG (registro, valor[, dispositivo])</code></pre>
<h3 id="parámetros-11">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Registro</th>
<th>Registro del chip. Se identificará por un número entero cuyo rango irá de 0 a un valor máximo determinado por las especificaciones del chip.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valor</td>
<td>Valor que escribiremos en el registro.</td>
</tr>
<tr class="even">
<td>Dispositivo</td>
<td>Indica sobre qué chip de audio queremos escribir. 0 = OPLL (MSX-MUSIC) 1 = OPL1 (MSX-AUDIO) 2 = PSG 3 = SCC <strong>Omit.</strong> Por defecto OPLL.</td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<h2 id="call-bgm">CALL BGM</h2>
<p>Permite reproducir la música sin bloquear la ejecución de otras instrucciones VR-BASIC.</p>
<h3 id="versión-13">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-13">Formato</h3>
<pre><code>CALL BGM (modo)</code></pre>
<h3 id="parámetros-12">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th>0 = Mientras hay música sonando no se ejecutan más instrucciones. 1 = Se permite la ejecución de más instrucciones mientras la música suena en paralelo.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-9">Ejemplos</h3>
<pre><code>CALL BGM(1)</code></pre>
<h2 id="call-chdir">CALL CHDIR</h2>
<p>Permite establecer la unidad y directorio por defecto de trabajo con las funciones de disco.</p>
<h3 id="versión-14">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-14">Formato</h3>
<pre><code>CALL CHDIR (&quot;[nombre de la unidad]nombre del directorio&quot;)</code></pre>
<h3 id="parámetros-13">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del directorio</td>
<td>Indica la ruta del directorio al que queremos cambiar.</td>
</tr>
</tbody>
</table>
<h2 id="call-chdrv">CALL CHDRV</h2>
<p>Cambia la unidad por defecto.</p>
<h3 id="versión-15">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-15">Formato</h3>
<pre><code>CALL CHDRV (&quot;nombre de la unidad&quot;)</code></pre>
<h3 id="parámetros-14">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="call-debug">CALL DEBUG</h2>
<p>Invoca el depurador. En el caso de que no haya un listado en memoria, el comando no hará nada.</p>
<h3 id="versión-16">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-16">Formato</h3>
<pre><code>CALL DEBUG
_DEBUG </code></pre>
<h2 id="call-edit">CALL EDIT</h2>
<p>Invoca el editor con resaltado de sintaxis y otras funcionalidades extendidas.</p>
<h3 id="versión-17">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-17">Formato</h3>
<pre><code>CALL EDIT
_EDIT </code></pre>
<h2 id="call-format">CALL FORMAT</h2>
<p>Formatea una unidad de disco que esté conectada a un puerto USB.</p>
<p>La operación de formateado escribe unos datos específicos en el disco, que el MSX Disk BASIC utiliza como “postes indicadores” en la búsqueda de los nombres de fichero y de los contenidos de los ficheros. Por lo tanto, es imprescindible formatear un disco virgen antes de utilizarlo por primera vez.</p>
<p><strong>Formateado con dos o más unidades de disco</strong></p>
<p>Cuando se ejecuta CALL FORMAT o _FORMAT, se visualiza en pantalla el mensaje:</p>
<pre><code>Drive name? (A, B)</code></pre>
<p>Especifique el nombre de la unidad (A o B) que contiene el disco a formatear introduciendo por el teclado una A o una B. En caso de disponer de una unidad de discos de una cara, se visualizará en pantalla el siguiente mensaje:</p>
<pre><code>Strike a key when ready</code></pre>
<p>Se debe comprobar que el disco a formatear está en la unidad de discos especificada y luego pulsar cualquier tecla.</p>
<p>En caso de disponer de unidades de discos de dos caras, se visualizará en pantalla el siguiente mensaje:</p>
<pre><code>1–Single sided, 9 sectors
2–Double sided, 9 sectors</code></pre>
<p>Para formatear un disco de una sola cara se debe especificar 1, y para formatear un disco de dos caras se debe especificar 2. Una vez especificado el tipo de disco, se visualizará en pantalla el siguiente mensaje:</p>
<pre><code>Strike a key when ready</code></pre>
<p>Se debe pulsar una tecla, exactamente igual que en el caso de disponer de una sola unidad de discos. El disco será formateado y luego saldrá el mensaje:</p>
<pre><code>Format complete
OK</code></pre>
<p>Y el Disk BASIC volverá al estado de espera de comandos.</p>
<p>La operación de formateado se puede cancelar (con anterioridad al mensaje “Strike a key when ready”) pulsando CRTL+STOP.</p>
<p><strong>Formateado con una sola unidad de disco</strong></p>
<p>Se debe especificar unidad de discos A:. Si especifica B: el ordenador dará por supuesto que la unidad de discos es la unidad B: y emitirá el siguiente mensaje:</p>
<pre><code>Insert diskette for drive B:
and strike a key when ready</code></pre>
<p>Aunque se haya indicado la unidad B:, se puede insertar un disco en la unidad de que se dispone; quedará formateado según el proceso expuesto anteriormente.</p>
<h3 id="versión-18">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-18">Formato</h3>
<pre><code>CALL FORMAT [nombre de la unidad]
_FORMAT [nombre de la unidad]</code></pre>
<h3 id="parámetros-15">Parámetros:</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="call-mdr">CALL MDR</h2>
<p>Establece la correspondencia entre los números de nota MIDI y los cinco elementos de un sonido rítmico.</p>
<p>En los parámetros de la llamada, se especifican los números de nota MIDI asignados a los elementos usados en la percusión FM. Son valores entre 0 y 127, y todos los valores iniciales se establecen en 0.</p>
<p>Muchos generadores de sonido MIDI tienen una función (pista dedicada al ritmo) que asigna el sonido de un instrumento de ritmo a una nota de un canal específico. Cada cadena de la instrucción PLAY corresponde a un solo canal. Para los sonidos rítmicos que reproducen múltiples sonidos al mismo tiempo, debe usar esta pista dedicada al ritmo.</p>
<p>La asignación de este tono de ritmo difiere según cada dispositivo MIDI. Consulte el manual de su dispositivo MIDI para saber qué valores se pueden utilizar realmente.</p>
<h3 id="versión-19">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-19">Formato</h3>
<pre><code>CALL MDR (midiB, midiS, midiM, midiC, midiH)</code></pre>
<h3 id="parámetros-16">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>MidiB</th>
<th>Nota MIDI para el Bombo. 0≤valor&lt;127.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MidiS</td>
<td>Nota MIDI para la Caja. 0≤valor&lt;127.</td>
</tr>
<tr class="even">
<td>MidiM</td>
<td>Nota MIDI para el TomTom. 0≤valor&lt;127.</td>
</tr>
<tr class="odd">
<td>MidiC</td>
<td>Nota MIDI para los Platillos. 0≤valor&lt;127.</td>
</tr>
<tr class="even">
<td>MidiH</td>
<td>Nota MIDI para el Charles. 0≤valor&lt;127.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-10">Ejemplos</h3>
<pre><code>CALL MDR (35,38,45,49,42)</code></pre>
<h2 id="call-memini">CALL MEMINI</h2>
<p>Asigna una zona de memoria a utilizar como RAM-Disk. Inicializa la RAM-Disk y borra todos los ficheros de la RAM-Disk.</p>
<p>Se puede utilizar como RAM-Disk la parte de RAM comprendida entre las direcciones 0000H y 7FFFH.</p>
<p>Esta orden ha de ser ejecutada antes de utilizar la funcionalidad de RAM-Disk.</p>
<p>El parámetro tamaño especifica la cantidad de memoria de la RAM-Disk en bytes.</p>
<p>Si se ejecuta CALL MEMINI (0), quedará cancelada la funcionalidad de la RAM-Disk y esta dejará se ser utilizable.</p>
<h3 id="versión-20">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-20">Formato</h3>
<pre><code>CALL MEMINI [(tamaño)]
_MEMINI [(tamaño)]</code></pre>
<h3 id="parámetros-17">Parámetros</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Tamaño</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1023≤tamaño&lt;32768. <strong>Omit.</strong> 32767.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-11">Ejemplos</h3>
<p>Cuando se ejecuta:</p>
<pre><code>CALL MEMINI</code></pre>
<pre><code>or _MEMINI</code></pre>
<p>Se visualizará el siguiente mensaje en la pantalla:</p>
<pre><code>32767 bytes allocated</code></pre>
<h2 id="call-mfiles">CALL MFILES</h2>
<p>Visualiza en pantalla los nombres de todos los ficheros almacenados en la RAM-Disk.</p>
<h3 id="versión-21">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-21">Formato</h3>
<pre><code>CALL MFILES
_MFILES</code></pre>
<h2 id="call-mkdir">CALL MKDIR</h2>
<p>Crea un directorio en una unidad de disco.</p>
<h3 id="versión-22">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-22">Formato</h3>
<pre><code>CALL MKDIR (&quot;[nombre de la unidad]nombre del directorio&quot;)</code></pre>
<h3 id="parámetros-18">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del directorio</td>
<td>Indica la ruta al directorio que queremos crear.</td>
</tr>
</tbody>
</table>
<h2 id="call-mkill">CALL MKILL</h2>
<p>Borra un fichero especificado de la RAM-Disk.</p>
<h3 id="versión-23">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-23">Formato</h3>
<pre><code>CALL MKILL (&quot;nombre de fichero[.extensión]&quot;)
_MKILL (&quot;nombre de fichero[.extensión]&quot;)</code></pre>
<h3 id="parámetros-19">Parámetros</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de fichero</th>
<th><strong>Cond</strong>. Una cadena de 8 o menos caracteres.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del tipo</td>
<td><strong>Cond.</strong> Una cadena de 3 o menos caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-12">Ejemplos</h3>
<pre><code>CALL MKILL (&quot;TEST.BAS&quot;) </code></pre>
<p>o</p>
<pre><code>_MKILL (&quot;TEST.BAS&quot;)</code></pre>
<h2 id="call-mname">CALL MNAME</h2>
<p>Cambia el nombre de un fichero de la RAM-Disk.</p>
<h3 id="versión-24">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-24">Formato</h3>
<pre><code>CALL MNAME (&quot;nombre de fichero anterior [.extensión anterior]&quot; AS &quot;nuevo nombre de fichero [.nueva extensión]&quot;)</code></pre>
<pre><code>_MNAME (&quot;nombre de fichero anterior [.extensión anterior]&quot; AS &quot;nuevo nombre de fichero [.nueva extensión]&quot;)</code></pre>
<h3 id="parámetros-20">Parámetros</h3>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de fichero anterior, nuevo nombre de fichero</th>
<th><strong>Cond.</strong> Una cadena de 8 o menos caracteres.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Extensión anterior, nueva extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 o menos caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
</tbody>
</table>
<h2 id="call-music">CALL MUSIC</h2>
<p>Inicializa los modos de reproducción de música utilizados en VR-BASIC.</p>
<p>Se pueden utilizar los siguientes modos:</p>
<table>
<thead>
<tr class="header">
<th><strong>Modo</strong></th>
<th><strong>FM</strong></th>
<th><strong>MIDI</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Canales melodía: 9 Canales ritmo: 0</td>
<td>Canales melodía: 9 Canales ritmo: 0</td>
</tr>
<tr class="even">
<td>1</td>
<td>Canales melodía: 6 Canales ritmo: 3</td>
<td>Canales melodía: 8 Canales ritmo: 1</td>
</tr>
</tbody>
</table>
<p>Es obligatorio especificar un 0 como segundo parámetro.</p>
<p>El resto de parámetros &lt;Número de canales&gt; permite especificar cuántos canales se utilizan para cada cadena PLAY relacionada con la melodía FM o MIDI. El número de canales no puede ser cero, excepto en Turbo R con MSX-MIDI para las cuerdas séptima y octava cuando se usa el modo 1: si se especifica cero para estas cadenas, se ignorarán como sonidos FM, pero no como sonidos MIDI.</p>
<p>El número de canales de melodía FM usados ​​en una sentencia PLAY debe ser 9 o menos cuando no se usa el ritmo, o bien 6 cuando se usa el ritmo. Cuando usa MIDI, en realidad asigna un canal MIDI específico a cada cadena PLAY; incluso si especifica un valor de 2 o más, el resultado será el mismo que con el valor 1.</p>
<p>El canal del generador de tonos FM se asigna automáticamente desde el canal más pequeño. El canal MIDI se establece en 1, 2, 3, … en orden desde la primera cadena de caracteres; sin embargo, puede cambiar eso usando la instrucción @H&lt;canal&gt; MML de PLAY.</p>
<p>Si usa CALL MUSIC sin parámetro, MSX-MUSIC se inicializará como con:</p>
<p>CALL MUSIC (1, 0, 1, 1, 1), lo que significa entrar en el modo 1, y por tanto:</p>
<p>Cuando suena FM = máximo 6 canales de melodía + 3 canales de ritmo</p>
<p>1 canal para la cadena PLAY 1.</p>
<p>1 canal para la cadena PLAY 2.</p>
<p>1 canal para la cadena PLAY 3.</p>
<p>La cadena PLAY 4 se usará para ritmo FM.</p>
<p>Las cadenas PLAY 5 a 7, de existir, se usarán para los 3 canales PSG.</p>
<p>Cuando se reproducen sonidos MIDI = máximo 8 canales de melodía + 1 canal de ritmo</p>
<p>1 canal para la cadena PLAY 1.</p>
<p>1 canal para la cadena PLAY 2.</p>
<p>1 canal para la cadena PLAY 3.</p>
<p>La cadena PLAY 4 se usará para ritmo MIDI.</p>
<p>Las cadenas PLAY 5 a 7, de existir, se usarán para los 3 canales PSG.</p>
<h3 id="versión-25">Versión</h3>
<p>MSX-MUSIC, MSXVR</p>
<h3 id="formato-25">Formato</h3>
<pre><code>CALL MUSIC (Modo, 0, Canales Cadena 1, Canales Cadena 2, ..., Canales Cadena 9)</code></pre>
<h3 id="parámetros-21">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th>0 o 1. <strong>Omit</strong>. 1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Canales cadena</td>
<td>Permite especificar cuántos canales se utilizan para cada cadena de melodía FM en la instrucción PLAY (no afecta en el caso de melodía MIDI).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-13">Ejemplos</h3>
<pre><code>MSX-MUSIC en modo 0 con 1 canal para cada cadena PLAY (1 a 9):</code></pre>
<pre><code>10 CALL MUSIC(0,0,1,1,1,1,1,1,1,1,1)</code></pre>
<pre><code>MSX-MUSIC en modo 1 con 2 canales para la cadena PLAY 1, 1 canal para la cadena PLAY 2; y 3 canales para la cadena PLAY 3:</code></pre>
<pre><code>10 CALL MUSIC(1,0,2,1,3)</code></pre>
<pre><code>MSX-MUSIC en modo 1 con canal cero para las cadenas PLAY séptima y octava. Las dos últimas cadenas PLAY se ignorarán si FM, no si MIDI:</code></pre>
<pre><code>10 CALL MUSIC (1,0,1,1,1,1,1,1,0,0)</code></pre>
<pre><code></code></pre>
<h2 id="call-pcmplay">CALL PCMPLAY</h2>
<p>Reproduce un audio PCM ubicado en una zona de memoria o en un array de datos.</p>
<p>La ejecución de esta sentencia detiene el programa hasta que se pulsa la tecla STOP o se ha completado la reproducción de un audio o la reproducción del audio ha superado una duración establecida.</p>
<p>Los parámetros <strong>comienzo</strong> y <strong>final</strong> hacen referencia a una dirección de memoria del ordenador, esta puede ser RAM o memoria de vídeo (VRAM).</p>
<p>El parámetro <strong>muestreo</strong> hace referencia a la frecuencia con la que se reproducirá el audio. Podemos especificar los siguientes valores:</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>15.75 KHz</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>7.875 KHz</td>
</tr>
<tr class="even">
<td>2</td>
<td>5.25 KHz</td>
</tr>
<tr class="odd">
<td>3</td>
<td>3.9375 KHz</td>
</tr>
</tbody>
</table>
<p>El parámetro <strong>S</strong>, permite indicar si queremos reproducir desde memoria de vídeo. Esto se puede establecer estando en cualquier tipo de modo de pantalla, sin embargo, en modos de pantalla a partir del 5, solo se usará la página activa.</p>
<h3 id="versión-26">Versión</h3>
<p>MSXturboR, MSXVR</p>
<h3 id="formato-26">Formato</h3>
<pre><code>CALL PCMPLAY(@comienzo, final, muestreo [,S])</code></pre>
<pre><code>CALL PCMPLAY(array [,duración], muestreo)</code></pre>
<h3 id="parámetros-22">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Comienzo</th>
<th>Constantes de tipo entero; ‑32768≤dirección≤65535.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Final</td>
<td>Constantes de tipo entero;‑32768≤dirección≤65535.</td>
</tr>
<tr class="even">
<td>Muestreo</td>
<td>Constantes de tipo entero;0≤muestreo≤3.</td>
</tr>
<tr class="odd">
<td>Array</td>
<td>Matriz variable de tipo numérico.</td>
</tr>
<tr class="even">
<td>Duración</td>
<td><strong>Cond.</strong> Constantes de tipo entero; 0≤dirección≤65535.</td>
</tr>
<tr class="odd">
<td>Opción S</td>
<td>Almacena el programa que hay en la memoria RAM de vídeo.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-14">Ejemplos</h3>
<pre><code>10 CLEAR 300,&amp;HB000
20 BLOAD&quot;PCMTEST.BIN&quot;
30 CALL PCMPLAY(@&amp;HB000,&amp;HDFFF,1)</code></pre>
<pre><code></code></pre>
<h2 id="call-pcmrec">CALL PCMREC</h2>
<p>Captura un audio PCM y lo guarda en una zona de memoria o en un array de datos.</p>
<p>La ejecución de esta sentencia detiene el programa hasta que se pulsa la tecla STOP o se ha superado el tamaño del array o se ha superado una duración establecida.</p>
<p>Los parámetros <strong>comienzo</strong> y <strong>final</strong> hacen referencia a una dirección de memoria del ordenador, esta puede ser RAM o memoria de vídeo (VRAM).</p>
<p>El parámetro <strong>muestreo</strong> hace referencia a la frecuencia con la que se capturará el audio. Véase la tabla del comando <em>CALL PCMPLAY</em>.</p>
<p>El parámetro <strong>nivel</strong> establece el nivel mínimo de entrada de audio para comenzar a guardar los datos. Si se usa el valor 0 (por defecto) se comienza a guardar el audio de inmediato.</p>
<p>El parámetro <strong>compresión</strong> permite habilitar un método de compresión de datos que reduce el tamaño en bytes cuando se dan muchos silencios. Siendo los valores números entre 1 y 255; cuando la adquisición de datos registra que uno o más valores consecutivos están entre 126 y 128, guarda un cero y a continuación el número de veces que se da esta condición. Cuando este parámetro es 0 (valor por defecto) no se utiliza este sistema de compresión.</p>
<p>El parámetro <strong>S</strong>, permite indicar si queremos guardar en memoria de vídeo. Esto se puede establecer estando en cualquier tipo de modo de pantalla, sin embargo, en modos de pantalla a partir del 5, solo se usará la página activa.</p>
<h3 id="versión-27">Versión</h3>
<p>MSXturboR, MSXVR</p>
<h3 id="formato-27">Formato</h3>
<pre><code>CALL PCMREC(@comienzo, final, muestreo [,nivel] [,compresión] [,S])</code></pre>
<pre><code>CALL PCMREC(array, duración, muestreo [,nivel] [,compresión])</code></pre>
<h3 id="parámetros-23">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Comienzo</th>
<th>Constantes de tipo entero;‑32768≤dirección≤65535.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Final</td>
<td>Constantes de tipo entero;‑32768≤dirección≤65535.</td>
</tr>
<tr class="even">
<td>Muestreo</td>
<td>Constantes de tipo entero;0≤muestreo≤3.</td>
</tr>
<tr class="odd">
<td>Nivel</td>
<td>Constantes de tipo entero;0≤muestreo≤127.</td>
</tr>
<tr class="even">
<td>Compresión</td>
<td>Constantes de tipo entero;0≤muestreo≤1.</td>
</tr>
<tr class="odd">
<td>Array</td>
<td>Matriz variable de tipo numérico.</td>
</tr>
<tr class="even">
<td>Duración</td>
<td><strong>Cond.</strong> Constantes de tipo entero; 0≤dirección≤65535.</td>
</tr>
<tr class="odd">
<td>Opción S</td>
<td>Almacena el programa que hay en la memoria RAM de vídeo.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-15">Ejemplos</h3>
<pre><code>10 CLEAR 300,&amp;HB000
20 CALL PCMREC(@&amp;HB000,&amp;HDFFF,1,32,1)
30 BSAVE&quot;PCMTEST.BIN&quot;,&amp;HB000,&amp;HDFFF</code></pre>
<h2 id="call-pitch">CALL PITCH</h2>
<p>Especifica el tono base de los sonidos de melodía FM producidos por los generadores FM. Se puede configurar independientemente del parámetro de transposición.</p>
<p>Esta instrucción no tiene efecto en los sonidos de ritmo FM, MIDI, PCM, PSG y SCC.</p>
<h3 id="versión-28">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-28">Formato</h3>
<pre><code>CALL PITCH (gen1[, gen2])</code></pre>
<h3 id="parámetros-24">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Gen1</th>
<th>Especifica un valor entre 410 y 459 y la unidad es Hz. <strong>Omit.</strong> 440 Hz.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gen2</td>
<td>Especifica un valor entre 410 y 459 y la unidad es Hz. <strong>Omit.</strong> 440 Hz.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-16">Ejemplos</h3>
<pre><code>CALL PITCH(430)</code></pre>
<h2 id="call-play">CALL PLAY</h2>
<p>Permite saber si se está reproduciendo música a través de algún canal.</p>
<h3 id="versión-29">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-29">Formato</h3>
<pre><code>CALL PLAY (número, variable)</code></pre>
<h3 id="parámetros-25">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Número</th>
<th>Corresponde a una de las cadenas que pueden contener MML (véase PLAY): esta cadena es reproducida por un canal. Si especifica 0, entonces CALL PLAY verificará todos los canales.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variable</td>
<td>Es una variable alfanumérica, que contendrá el valor devuelto por la función CALL PLAY. Devuelve -1 (verdadero) si se está reproduciendo el canal o canales seleccionados. Si la reproducción del canal o canales consultados ha finalizado, devuelve 0 (falso).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-17">Ejemplos</h3>
<pre><code>CALL PLAY(0,A):PRINT A</code></pre>
<pre><code></code></pre>
<h2 id="call-ramdisk">CALL RAMDISK</h2>
<p>Crea una unidad de disco en memoria. Solo puede existir una unidad RAM. Sucesivas llamadas sobrescriben las propiedades de la unidad.</p>
<h3 id="versión-30">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-30">Formato</h3>
<pre><code>CALL RAMDISK[([tamaño][, nombre de variable])] </code></pre>
<h3 id="parámetros-26">Parámetros</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Tamaño</th>
<th>Cantidad de bytes de memoria a reservar para la unidad.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre de variable</td>
<td>Variable VR-BASIC donde se almacena el tamaño realmente reservado.</td>
</tr>
<tr class="even">
<td></td>
<td><strong>Omit.</strong> No se retorna el tamaño.</td>
</tr>
</tbody>
</table>
<h2 id="call-rmdir">CALL RMDIR</h2>
<p>Elimina un directorio de una unidad de disco.</p>
<h3 id="versión-31">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-31">Formato</h3>
<pre><code>CALL RMDIR (&quot;[unidad de disco]nombre del directorio&quot;)</code></pre>
<h3 id="parámetros-27">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del directorio</td>
<td>Indica la ruta al directorio que queremos crear.</td>
</tr>
</tbody>
</table>
<h2 id="call-sleep">CALL SLEEP</h2>
<p>Pausa la ejecución del programa durante un número de milisegundos.</p>
<h3 id="versión-32">Versión</h3>
<p>MSXVR</p>
<h3 id="formato-32">Formato</h3>
<pre><code>CALL SLEEP(ms)</code></pre>
<h3 id="parámetros-28">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Ms</th>
<th>Milisegundos en los que pausa el programa VR-BASIC.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="call-speed">CALL SPEED</h2>
<p>Modifica la velocidad de ejecución del programa VR-BASIC.</p>
<h3 id="versión-33">Versión</h3>
<p>MSXVR</p>
<h3 id="formato-33">Formato</h3>
<pre><code>CALL SPEED(factor)</code></pre>
<h3 id="parámetros-29">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>Factor</th>
<th>1 sería velocidad normal, 2 el doble y así en adelante. Un valor menor que cero no se admite. Tampoco valores mayores a 100.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="call-stopm">CALL STOPM</h2>
<p>Detiene los canales de música que estén sonando de fondo (véase el comando CALL BGM).</p>
<h3 id="versión-34">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-34">Formato</h3>
<pre><code>CALL STOPM</code></pre>
<h3 id="ejemplos-18">Ejemplos</h3>
<pre><code>CALL STOPM</code></pre>
<h2 id="call-system">CALL SYSTEM</h2>
<p>Devuelve el control al sistema operativo VR-DOS.</p>
<p>Devuelve el control al VR-DOS después de cerrar todos los ficheros y borrar los programas y datos de la memoria.</p>
<h3 id="versión-35">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-35">Formato</h3>
<pre><code>CALL SYSTEM</code></pre>
<pre><code>_SYSTEM</code></pre>
<h2 id="call-temper">CALL TEMPER</h2>
<p>Establece el temperamento para el sonido FM.</p>
<p>Este parámetro afecta al tono de los sonidos y determina la proporción utilizada para dividir una octava en 12 sonidos. Los temperamentos clásicos provistos son compatibles con la música clásica.</p>
<p>Esta función no es compatible con MSX-MIDI.</p>
<h3 id="versión-36">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-36">Formato</h3>
<pre><code>CALL TEMPER (modo)</code></pre>
<h3 id="parámetros-30">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Modo</th>
<th>Es un valor entre 0 y 21. <strong>Omit.</strong> 9.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-19">Ejemplos</h3>
<pre><code>CALL TEMPER(9)</code></pre>
<h2 id="call-transpose">CALL TRANSPOSE</h2>
<p>Transpone en unidades de medios tonos los sonidos FM (melodía y ritmo) producidos por los generadores FM. Se puede configurar independientemente del parámetro de tono.</p>
<p>Esta instrucción no tiene efecto en los sonidos MIDI, PCM, PSG y SCC.</p>
<h3 id="versión-37">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-37">Formato</h3>
<pre><code>CALL TRANSPOSE (gen1[, gen2])</code></pre>
<h3 id="parámetros-31">Parámetros</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>Gen1</th>
<th>Valor entre -12799 y 12799. La unidad es 1/100. Los valores extremos son aproximados debido a limitaciones de hardware. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Gen2</td>
<td>Valor entre -12799 y 12799. La unidad es 1/100. Los valores extremos son aproximados debido a limitaciones de hardware. <strong>Omit.</strong> 0.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-20">Ejemplos</h3>
<pre><code>CALL TRANSPOSE(1200)</code></pre>
<h2 id="call-vmachine">CALL VMACHINE</h2>
<p>Permite cambiar el tipo de máquina virtual que ejecutará el intérprete VR-BASIC.</p>
<p>Dependiendo del tipo de máquina, habrá funcionalidades del VR-BASIC que dejarán de funcionar o que se activarán. En el caso de una máquina MSXVR, se podrán usar todas las funcionalidades, además de las nuevas incorporadas.</p>
<h3 id="versión-38">Versión</h3>
<p>MSXVR</p>
<h3 id="formato-38">Formato</h3>
<pre><code>CALL VMACHINE(M$)</code></pre>
<h3 id="parámetros-32">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>M$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo cadena). Podrá ser una de estas: MSX1, MSX2, MSX2+, MSXTR, MSXVR.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-21">Ejemplos</h3>
<pre><code>CALL VMACHINE(&quot;MSX2&quot;)</code></pre>
<h2 id="call-voice">CALL VOICE</h2>
<p>Establece directamente un timbre de sonido (voz) para cada canal del generador de tonos FM. Los sonidos se pueden seleccionar entre 64 preajustes en ROM o por el usuario utilizando una variable de matriz.</p>
<h3 id="versión-39">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-39">Formato</h3>
<pre><code>CALL VOICE (@voz1, @voz2, ..., @voz9)</code></pre>
<pre><code>CALL VOICE (array1, array2, ..., array9)</code></pre>
<h3 id="parámetros-33">Parámetros</h3>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>Voz</th>
<th>Siempre está precedido por @ (consulte la tabla de voces en la sección de Música y Sonido). Cada voz corresponde a un instrumento definido por los parámetros internos del chip de sonido FM (hardware) o generado a partir de parámetros externos (software).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Array</td>
<td>Debe ser una matriz variable de tipo numérico que pueda contener un mínimo de 32 bytes de datos de bytes RAW (consulte el formato de la matriz de voz en la sección de Música y Sonido). El uso de matrices permite la creación de nuevos instrumentos (solo uno en MSX-MUSIC, 32 en MSX-AUDIO). El valor de la matriz también se puede definir con CALL VOICE COPY.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-22">Ejemplos</h3>
<p>Sonido definido para los canales 1, 2 y 3</p>
<pre><code>CALL VOICE (@16,@25,@40)</code></pre>
<p>Sonido definido para los canales 1 y 3 a partir de arrays.</p>
<pre><code>CALL VOICE(A,,B)  </code></pre>
<pre><code></code></pre>
<h2 id="call-voice-copy">CALL VOICE COPY</h2>
<p>Copia la definición de una voz en la ubicación deseada. El primer parámetro es el origen y el segundo parámetro es el destino.</p>
<h3 id="versión-40">Versión</h3>
<p>MSX-AUDIO, MSX-MUSIC, MSXVR</p>
<h3 id="formato-40">Formato</h3>
<pre><code>CALL VOICE COPY (@voz, array)</code></pre>
<pre><code>CALL VOICE COPY (array, @voz)</code></pre>
<pre><code>CALL VOICE COPY (@voz1, @voz2)</code></pre>
<h3 id="parámetros-34">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>Voz</th>
<th>Siempre está precedido por @ (consulte la tabla de voces en la sección de Música y Sonido). Cada voz corresponde a un instrumento definido por los parámetros internos del chip de sonido FM (hardware) o generado a partir de parámetros externos (software).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Array</td>
<td>Debe ser una matriz variable de tipo numérico que pueda contener un mínimo de 32 bytes de datos de bytes RAW (consulte el formato de la matriz de voz en la sección de Música y Sonido). El uso de matrices permite la creación de nuevos instrumentos (solo uno en MSX-MUSIC, 32 en MSX-AUDIO).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-23">Ejemplos</h3>
<pre><code>10 CALL MUSIC
20 DEFINT A-Z
30 DIM D(15)
40 CALL VOICE COPY (@1,D)
50 D(8)=0
60 CALL VOICE COPY (D,@63)
70 PLAY #2,&quot;@63V15CDE&quot;</code></pre>
<pre><code></code></pre>
<h2 id="cdbl">CDBL</h2>
<p>Convierte datos numéricos en datos de precisión doble.</p>
<p>Esta función trata internamente el dato numérico dado como dato de precisión doble.</p>
<h3 id="versión-41">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-41">Formato</h3>
<pre><code>CDBL (x)</code></pre>
<h3 id="parámetros-35">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (tipo numérico).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-4">Retorno</h3>
<p>Tipo numérico de doble precisión.</p>
<h2 id="chr">CHR$</h2>
<p>Ofrece el símbolo ASCII correspondiente a un código de carácter especificado.</p>
<h3 id="versión-42">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-42">Formato</h3>
<pre><code>CHR$(x)</code></pre>
<h3 id="parámetros-36">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤X&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-5">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-24">Ejemplos</h3>
<pre><code>PRINT CHR$ (100)
d</code></pre>
<pre><code></code></pre>
<pre><code>Para mostrar los caracteres gráficos extendidos:</code></pre>
<pre><code></code></pre>
<pre><code>PRINT CHR$ (1) ; CHR$ (67)
♥</code></pre>
<h2 id="international-codes">International Codes</h2>
<p>Códigos de control en azul. Son ignorados por la instrucción en los modos gráficos.</p>
<p>Los caracteres desde el 20h al 7Fh (morados) están codificados en 7-bit ASCII.</p>
<p>Caracteres verdes son caracteres específicos de MSX occidental.</p>
<p>El ultimo carácter (FFh) es el cursor.</p>
<p>La tabla con caracteres naranjas, son. También son específicos para el MSX occidental y el MSX ruso. Las formas de estos caracteres se encuentran en los primeros 32 caracteres.</p>
<p><img src="media/7a86e9ba8c39781aa348f33f602108f9.png" /></p>
<p>International Fonts</p>
<p><img src="media/df827227035b2a0d589e75eba62bbc73.png" /></p>
<h2 id="cint">CINT</h2>
<p>Convierte un dato numérico en entero.</p>
<p>Cuando el dato numérico X es un valor entero, lo mantiene como está, pero cuando es un valor del tipo coma flotante, lo convierte en un valor entero omitiendo los valores que siguen a la coma. Se diferencia de la función INT en que esta ofrece el número entero X, mientras que CINT convierte el número X en un entero con un procesamiento distinto.</p>
<h3 id="versión-43">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-43">Formato</h3>
<pre><code>CINT(X)</code></pre>
<h3 id="parámetros-37">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤X&lt;32768.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-6">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-25">Ejemplos</h3>
<pre><code>PRINT CINT (9/2)
 4</code></pre>
<pre><code>PRINT CINT (12*200*55)
Overflow</code></pre>
<h2 id="circle">CIRCLE</h2>
<p>Dibuja un círculo, un óvalo, un arco o una forma en abanico, en el modo gráfico (véase SCREEN).</p>
<p>Dibuja un círculo con el radio especificado que tiene como centro las coordenadas especificadas.</p>
<p>Cuando se especifica un ángulo inicial y un ángulo final, solo dibuja un arco circular.</p>
<p>Se puede dibujar una forma en abanico especificando un ángulo inicial y un ángulo final negativos (-). Se puede dibujar una elipse con una determinada relación, especificando para el radio vertical un múltiplo del radio horizontal.</p>
<p>Cuando se especifica STEP, las coordenadas X, Y son relativas al último punto especificado en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-44">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-44">Formato</h3>
<pre><code>CIRCLE [STEP] (coordenadas de centro x, y),radio [,color] [,ángulo inicial] [,ángulo final] [,relación entre ejes]</code></pre>
<h3 id="parámetros-38">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenadas del centro X, Y</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤X&lt;32768; 32768≤Y&lt;32768.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Radio</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤radio&lt;32768</td>
</tr>
<tr class="even">
<td>Color</td>
<td><strong>Cond.</strong> SCREEN 2 a 7: Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤color&lt;16. SCREEN 8-13: Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤color&lt;256. <strong>Omit.</strong> Color de escritura actual.</td>
</tr>
<tr class="odd">
<td>Ángulo inicial</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); ‑2π≤ángulo&lt;2π (en radianes). <strong>Omit.</strong> 0</td>
</tr>
<tr class="even">
<td>Ángulo final</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); ‑2π≤ángulo&lt;2π (en radianes). <strong>Omit.</strong> 2π</td>
</tr>
<tr class="odd">
<td>Relación de ejes</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numérico positivo). <strong>Omit.</strong> 1</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-26">Ejemplos</h3>
<pre><code>10 CLS
20 SCREEN 2
30 CIRCLE (50, 50), 30,,,,4
40 CIRCLE STEP (80,70), 30,,,,,25
50 GOTO 50 </code></pre>
<pre><code></code></pre>
<pre><code>10 SCREEN 2</code></pre>
<pre><code>20 CIRCLE(125,96),70</code></pre>
<pre><code>30 CIRCLE(100,30),30,1,,,1.2</code></pre>
<pre><code>40 CIRCLE(100,30),30,1,0,2*3.14,2</code></pre>
<pre><code>50 CIRCLE(100,30),30,1,0,2*3.14,5</code></pre>
<pre><code>90 GOTO 90</code></pre>
<pre><code>10 SCREEN 3</code></pre>
<pre><code>20 CIRCLE(125,96),50,1</code></pre>
<pre><code>30 PAINT(125,96),2,1</code></pre>
<pre><code>40 PAINT(10,10),10,1</code></pre>
<pre><code>50 GOTO 50</code></pre>
<pre><code></code></pre>
<pre><code>Este ejemplo dibuja figuras muy llamativas en pantalla</code></pre>
<pre><code></code></pre>
<pre><code>100 SCREEN 5</code></pre>
<pre><code>110 FOR I = 7 TO 0 STEP -1</code></pre>
<pre><code>120 CIRCLE (120,100), I*10+5, I</code></pre>
<pre><code>130 PAINT (120, 100), I, I</code></pre>
<pre><code>140 NEXT I</code></pre>
<pre><code>150 J = (J+I) MOD 8</code></pre>
<pre><code>160 FOR I = 0 TO 7</code></pre>
<pre><code>170 COLOR = (I, 0, J, 0)</code></pre>
<pre><code>180 J = (J+1) MOD 8</code></pre>
<pre><code>190 NEXT I</code></pre>
<pre><code>200 GOTO 150</code></pre>
<pre><code></code></pre>
<pre><code>asdasdasd</code></pre>
<h2 id="clear">CLEAR</h2>
<p>Inicializa todas las variables y selecciona el tamaño del área de caracteres y la dirección de memoria más alta utilizada en VR-BASIC. Además, cierra todos los ficheros abiertos, si hay alguno.</p>
<h3 id="versión-45">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-45">Formato</h3>
<pre><code>CLEAR [tamaño del área de caracteres] [,dirección más alta]</code></pre>
<h3 id="parámetros-39">Parámetros</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Tamaño del área de caracteres</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico). <strong>Omit.</strong> Valor seleccionado actual (el valor inicial es 200). De todas formas no se puede omitir independientemente el tamaño del área de caracteres.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dirección más alta</td>
<td><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico). <strong>Omit.</strong> Valor actual</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-27">Ejemplos</h3>
<pre><code>CLEAR 400,55296</code></pre>
<p>Esta instrucción inicializa todas las variables. Además, pone el tamaño del área de caracteres en 400 bytes y la dirección más alta del área del programa VR-BASIC en 55296.</p>
<h2 id="cload">CLOAD</h2>
<p>Carga un programa VR-BASIC desde una cinta de casete.</p>
<p>Si durante la carga ocurre un error, rebobine la cinta y vuelva a cargar.</p>
<h3 id="versión-46">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-46">Formato</h3>
<pre><code>CLOAD [&quot;nombre del fichero&quot;]</code></pre>
<h3 id="parámetros-40">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de fichero</th>
<th><strong>Cond</strong>. Cadena de 6 o menos caracteres. Si se especifican 7 o más caracteres, ignora todos los caracteres a partir del sexto. <strong>Omit.</strong> Carga el primer programa que encuentra.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-28">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>CLOAD “PROG1”</th>
<th>Carga de cinta casete a memoria el programa almacenado con el nombre de fichero PROG1.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="cload-1">CLOAD?</h2>
<p>Compara un programa almacenado en cinta casete con uno almacenado en memoria.</p>
<p>Se trata de una orden que comprueba si un programa está bien almacenado o no. Cuando se ejecuta, compara el programa guardado en memoria con el programa almacenado en cinta casete bajo un nombre de fichero especificado.</p>
<p>Tras hacer la comparación, si el resultado es positivo indica la correspondencia de los programas presentando en pantalla “OK”. Cuando no hay correspondencia, presenta en pantalla el mensaje “Device I/O error” (error dispositivo de entrada/salida).</p>
<p>Si se omite el nombre de fichero o se introduce CLOAD? "_", compara el primer programa que encuentre en la cinta con el programa de la memoria.</p>
<h3 id="versión-47">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-47">Formato</h3>
<pre><code>CLOAD? [&quot;nombre del fichero&quot;]</code></pre>
<h3 id="parámetros-41">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del fichero</th>
<th><strong>Cond.</strong> Cadena de 6 caracteres o menos. Si se especifican 7 o más caracteres, ignora todos los caracteres a partir del sexto. <strong>Omit.</strong> Compara el primer programa encontrado con el residente en la memoria.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-29">Ejemplos</h3>
<pre><code>CLOAD? &quot;PROG1&quot;</code></pre>
<h2 id="close">CLOSE</h2>
<p>Cierra un fichero abierto anteriormente por una instrucción OPEN.</p>
<h3 id="versión-48">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-48">Formato</h3>
<pre><code>CLOSE [#] [número de fichero][,número de fichero]...</code></pre>
<h3 id="parámetros-42">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero); 1≤número de fichero≤número especificado por la instrucción MAXFILES. <strong>Omit.</strong> Cierra todos los ficheros.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-30">Ejemplos</h3>
<pre><code>10 MAXFILES = 3
20 SCREEN 2
30 OPEN &quot;GRP:&quot; FOR OUTPUT AS #1 abre el fichero 1
40 OPEN &quot;GRP:&quot; FOR OUTPUT AS #2 abre el fichero 2
50 OPEN &quot;GRP:&quot; FOR OUTPUT AS #3 abre el fichero 3
60 PRINT #1, &quot;ABC&quot;
70 PRINT #2, &quot;DEF&quot;
80 PRINT #3, &quot;GHI&quot;
100 CLOSE                   cierra todos los ficheros</code></pre>
<h2 id="cls">CLS</h2>
<p>Limpia la pantalla. En el modo gráfico, el color del fondo cambia ejecutando CLS después de la instrucción COLOR.</p>
<h3 id="versión-49">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-49">Formato</h3>
<pre><code>CLS</code></pre>
<h2 id="color">COLOR</h2>
<p>Especifica los colores del primer plano, del fondo y de los bordes.</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>SCREEN</strong></th>
<th><strong>CÓDIGO DE COLOR</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0 - 7</td>
<td>Índice Paleta - [0-15]</td>
</tr>
<tr class="even">
<td>8</td>
<td>Código de color = 32 x (intensidad verde) + 4 x (intensidad rojo) + (intensidad azul) Intensidad verde: un entero del 0 al 7. Intensidad rojo: un entero del 0 al 7. Intensidad azul: un entero del 0 al 3.</td>
</tr>
<tr class="odd">
<td>13</td>
<td>Índice Paleta - [0 - 255]</td>
</tr>
</tbody>
</table>
<p>Para consultar la tabla de los códigos de color, ver <em>COLOR[=NEW].</em></p>
<p>Para consultar la configuración de la pantalla en la página, ver <em>SCREEN</em>.</p>
<p>En el modo gráfico no se puede cambiar el color del fondo especificándolo únicamente con una instrucción COLOR. Hay que ejecutar después la instrucción CLS.</p>
<h3 id="versión-50">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-50">Formato</h3>
<pre><code>COLOR[color del primer plano][,color del fondo][,color de los bordes]</code></pre>
<h3 id="parámetros-43">Parámetros</h3>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Color del primer plano, color del fondo, color de los bordes</th>
<th><strong>Cond.</strong> SCREEN 0 a 7 Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 0≤color&lt;16. SCREEN 8, 10 a 13 Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 0≤color&lt;256. <strong>Omit.</strong> Color actual.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-31">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>COLOR 6</th>
<th>Solo cambia el color del primer plano (el color de los caracteres en el modo texto y el color de los gráficos en el modo gráfico)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COLOR ,2</td>
<td>Solo cambia el color del fondo</td>
</tr>
<tr class="even">
<td>COLOR ,,11</td>
<td>Solo cambia el color de los bordes</td>
</tr>
<tr class="odd">
<td>COLOR 15, 4, 4</td>
<td>Colores de inicialización</td>
</tr>
</tbody>
</table>
<h2 id="color-pal-r-g-b">COLOR = (pal, r, g, b)</h2>
<p>Asigna colores a los números de la paleta de colores.</p>
<table>
<thead>
<tr class="header">
<th><strong>SCREEN</strong></th>
<th><strong>PALETA</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0-12</td>
<td>512 colores - RGB 9 bits.</td>
</tr>
<tr class="even">
<td>13</td>
<td>16M colores - RGB 24 bits.</td>
</tr>
</tbody>
</table>
<p>Los colores de los números de la paleta para los que no se ejecuta esta instrucción siguen teniendo los valores iniciales.</p>
<h3 id="versión-51">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-51">Formato</h3>
<pre><code>Color = (nº de paleta[, intensidad de rojo[, intensidad de verde[, intensidad de azul]]])</code></pre>
<h3 id="parámetros-44">Parámetros</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Nº de paleta</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); SCREEN 0 a 12 - 0≤número&lt;16. SCREEN 13 - 0≤número&lt;256.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intensidad de rojo, verde y azul</td>
<td><strong>Cond</strong>. Constantes de tipo entero; 0≤intensidad≤7. <strong>Omit.</strong> 0</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-32">Ejemplos</h3>
<pre><code>100 SCREEN 5
110 FOR I = 7 TO 0 STEP -1
120 CIRCLE (120,100), I*10+5, I
130 PAINT (120, 100), I, I
140 NEXT I
150 J = (J+I) MOD 8
160 FOR I = 0 TO 7
170 COLOR = (I, 0, J, 0)
180 J = (J+1) MOD 8
190 NEXT I
200 GOTO 150</code></pre>
<h2 id="color-new">COLOR [= NEW]</h2>
<p>Devuelve la paleta de colores a sus valores iniciales por omisión.</p>
<table>
<thead>
<tr class="header">
<th><strong>Nº paleta</strong></th>
<th><strong>Color</strong></th>
<th><strong>Intensidad rojo</strong></th>
<th><strong>Intensidad azul</strong></th>
<th><strong>Intensidad verde</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Transparente</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>Negro</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Verde</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr class="even">
<td>3</td>
<td>Verde claro</td>
<td>3</td>
<td>3</td>
<td>7</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Azul oscuro</td>
<td>1</td>
<td>7</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>Azul claro</td>
<td>2</td>
<td>7</td>
<td>3</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Rojo oscuro</td>
<td>5</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>7</td>
<td>Azul cielo</td>
<td>2</td>
<td>7</td>
<td>6</td>
</tr>
<tr class="odd">
<td>8</td>
<td>Rojo</td>
<td>7</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td>9</td>
<td>Rojo claro</td>
<td>7</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>10</td>
<td>Amarillo oscuro</td>
<td>6</td>
<td>1</td>
<td>6</td>
</tr>
<tr class="even">
<td>11</td>
<td>Amarillo claro</td>
<td>6</td>
<td>4</td>
<td>6</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Verde oscuro</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>13</td>
<td>Magenta</td>
<td>6</td>
<td>5</td>
<td>2</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Gris</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr class="even">
<td>15</td>
<td>Blanco</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody>
</table>
<h3 id="versión-52">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-52">Formato</h3>
<pre><code>COLOR [= NEW]</code></pre>
<h3 id="parámetros-45">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>New</th>
<th><strong>Omit.</strong> La misma acción.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="color-restore">COLOR = RESTORE</h2>
<p>Asigna el contenido de la tabla de colores de la RAM de vídeo al registro de la paleta de colores de la VDP.</p>
<p>La ejecución de la instrucción BSAVE con la opción S almacena el contenido de la RAM de vídeo en el disco junto con los datos de la paleta de colores. Estos datos se cargan en la RAM de vídeo mediante la instrucción BLOAD con la opción S. Pero los datos de la paleta de color solo están especificados en la tabla de datos y el color presentado actualmente no cambia con respecto al color presentado antes de la carga. La ejecución de COLOR = RESTORE asigna los datos de la tabla a la paleta de color y se visualiza en pantalla el mismo color presentado cuando se ejecutó el comando BSAVE, S.</p>
<h3 id="versión-53">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-53">Formato</h3>
<pre><code>COLOR = RESTORE</code></pre>
<h3 id="ejemplos-33">Ejemplos</h3>
<pre><code>10 SCREEN 2
20 BLOAD &quot;BOX&quot;, S
30 COLOR = RESTORE
40 GOTO 40</code></pre>
<p>La línea 20 carga el contenido de la RAM de vídeo almacenado en el ejemplo dado en la sección BSAVE, y la línea 30 cambia el color haciéndolo coincidir con el color presente cuando se ejecutó la orden BSAVE.</p>
<h2 id="color-sprite">COLOR SPRITE</h2>
<p>Asigna el color del número de paleta especificado a un plano de sprites.</p>
<p>Válido solo para SCREEN 4 a SCREEN 13.</p>
<h3 id="versión-54">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-54">Formato</h3>
<pre><code>COLOR SPRITE(nº del plano de sprites) = nº de paleta</code></pre>
<h3 id="parámetros-46">Parámetros</h3>
<div class="line-block">Nº del plano de sprites | <strong>Cond.</strong> Constantes, variables de matriz, sus expresiones (de tipo numérico); |<br />
                        | 0≤nº plano&lt;32. |</div>
<p>|————————-|————————————————————————————————| | Nº de paleta | <strong>Cond.</strong> Constantes, variables de matriz, sus expresiones (de tipo numérico); | | | 0≤nº paleta&lt;16. |</p>
<h2 id="color-sprite-1">COLOR SPRITE$</h2>
<p>Especifica los colores correspondientes a las líneas horizontales de un sprite.</p>
<p>Válido solo para SCREEN 4 a SCREEN 13.</p>
<p>Cada expresión de caracteres corresponde a una línea horizontal del sprite, y cada bit de un carácter tiene el siguiente significado:</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>b7</th>
<th>Si es 1, desplaza el sprite 32 puntos a la izquierda.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b6</td>
<td>Si es 1, ignora la posición de prioridad del sprite y presenta el color suma (función OR) en la posición donde se han solapado varios sprites.</td>
</tr>
<tr class="even">
<td>b5</td>
<td>Si es 1, ignora el choque (solape) de sprites.</td>
</tr>
<tr class="odd">
<td>b4</td>
<td>No utilizado.</td>
</tr>
<tr class="even">
<td>b3-b0</td>
<td>Código de la paleta de colores.</td>
</tr>
</tbody>
</table>
<p>Cuando la expresión de caracteres es menor de 15 caracteres, las partes no especificadas conservarán sus valores previos.</p>
<h3 id="versión-55">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-55">Formato</h3>
<pre><code>COLOR SPRITE$(nº del plano del sprite) = &quot;expresión de caracteres&quot;</code></pre>
<h3 id="parámetros-47">Parámetros</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Nº del plano del sprite</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤nº plano&lt;32.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión de caracteres</td>
<td><strong>Cond.</strong> 16 caracteres o menos.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-34">Ejemplos</h3>
<pre><code>110 SCREEN 5, 1
110 FOR I = 0 TO 7
120 A$ = A$+CHR$ (2^I-1)
130 B$ = B$+CHR$ (I*2+1)
140 NEXT I
150 SPRITE$ (0) = A$
160 COLOR SPRITE$ (2) = B$
170 FOR I =0 TO 255
180 PUT SPRITE 2, (I, 100),,0
190 NEXT I
200 GOTO 170</code></pre>
<h2 id="cont">CONT</h2>
<p>Reanuda la ejecución de un programa.</p>
<p>Reanuda un programa interrumpido anteriormente por una orden CTRL+STOP o por una instrucción STOP en un programa. Tras la ejecución de la instrucción CONT, la ejecución del programa vuelve a empezar a partir de la instrucción siguiente a la instrucción interrumpida, con una excepción: si la interrupción ha sido durante la ejecución de una instrucción INPUT, la ejecución se reanuda por el principio de la instrucción en cuestión.</p>
<h3 id="versión-56">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-56">Formato</h3>
<pre><code>CONT</code></pre>
<h2 id="copy">COPY</h2>
<p>Copia un fichero del disco en el mismo disco o en otro.</p>
<p>Copia el contenido del disco de la unidad 1 en el disco de la unidad 2.</p>
<h3 id="versión-57">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-57">Formato</h3>
<pre><code>COPY &quot;[nombre de la unidad 1]nombre del fichero[.extensión]&quot; TO &quot;[nombre de la unidad 2]nombre del fichero[.extensión]&quot;</code></pre>
<h3 id="parámetros-48">Parámetros</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad 1,2</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de hasta 8 caracteres.</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de hasta 3 caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-35">Ejemplos</h3>
<p><strong>COPIA DE UN FICHERO</strong></p>
<p>Para hacer la copia en el mismo disco:</p>
<pre><code>COPY &quot;ABC.BAS&quot; TO &quot;XYZ.BAS&quot;</code></pre>
<p>Omitiendo los nombres de la unidad 1 y 2, se puede hacer una copia en el mismo disco bajo un nombre de fichero distinto. En este ejemplo, se ha grabado en el mismo disco el fichero de nombre “XYZ.BAS” con el mismo contenido que el fichero de nombre “ABC.BAS”.</p>
<p>Si se introduce únicamente:</p>
<pre><code>COPY &quot;ABC.BAS&quot;</code></pre>
<p>y se omite todo lo que vendría a continuación de TO, con la intención de copiar el fichero en el mismo disco y bajo el mismo nombre, saldrá un mensaje de error.</p>
<p>Para hacer la copia en otro disco:</p>
<p>Cuando solo se dispone de una unidad de discos (no MSXVR)</p>
<p>Cabe la posibilidad de copiar el contenido de un disco aun en el caso de tener solo una unidad de discos. Al ejecutar:</p>
<pre><code>COPY &quot;A:ABC.BAS&quot; TO &quot;B:&quot;</code></pre>
<p>Saldrá en pantalla el siguiente mensaje (a):</p>
<pre><code>    Insert diskette for drive B:
    And strike a key when ready</code></pre>
<p>Cuando sale este mensaje, sacar el disco de la unidad de discos e insertar un nuevo disco (que esté formateado) y pulsar una tecla.</p>
<p>Mensaje (b)</p>
<pre><code>    Insert diskette for drive A:
    And strike a key when ready</code></pre>
<p>Se debe sacar el disco nuevo, insertar el disco anterior y pulsar una tecla. Cuando salga otra vez el mensaje (a), se debe insertar el disco nuevo, y cuando salga el mensaje (b), insertar otra vez el disco anterior. Este proceso se repite hasta que aparece “OK” en pantalla, indicando que el proceso ha finalizado. El fichero “ABC.BAS” ha quedado copiado en el disco nuevo con el mismo nombre de fichero.</p>
<p>El número de veces que hay que cambiar los discos depende de la longitud del fichero a copiar.</p>
<p>Repitiendo el proceso anterior, pero utilizando la orden siguiente, se copia el fichero “ABC:BAS” en el nuevo disco pero con el nombre de fichero “XYZ.BAS”.</p>
<pre><code>COPY &quot;A:ABC.BAS&quot; TO &quot;B:XYZ.BAS&quot;</code></pre>
<p>Cuando se utilizan dos o más unidades de discos</p>
<p>Se puede especificar el disco fuente y el disco destino utilizando los nombres de unidad 1 y 2 de la forma siguiente:</p>
<pre><code>COPY &quot;A:ABC.BAS&quot; TO &quot;B:XYZ.BAS&quot;</code></pre>
<p>Esta orden copia el fichero “ABC.BAS” del disco de la unidad A: en el disco de la unidad B:, bajo el nombre “XYZ.BAS”.</p>
<pre><code>COPY &quot;A:ABC.BAS&quot; TO &quot;B:&quot;</code></pre>
<p>Esta orden copia el fichero “ABC.BAS” del disco de la unidad A: en el disco de la unidad B: utilizando el mismo nombre (“ABC.BAS”).</p>
<p>Si se omite el nombre de unidad 2, de la forma siguiente:</p>
<pre><code>COPY &quot;A:ABC.BAS&quot; TO &quot;XYZ.BAS&quot;</code></pre>
<p>el fichero quedará copiado en el disco de la unidad A.</p>
<pre><code></code></pre>
<pre><code>COPY &quot;A:ABC.BAS&quot;</code></pre>
<p>Esta orden, omitiendo todo lo que vendría a continuación de TO, copia el fichero “ABC.BAS” en el disco activo (A) y con el mismo nombre. En consecuencia, el disco activo en el ejemplo anterior no puede ser el disco de la unidad A:; si lo fuera se produciría un error.</p>
<p><strong>COPIA DE MÁS DE UN FICHERO A LA VEZ</strong></p>
<p>Se puede utilizar el signo de interrogación (?) para representar una letra cualquiera del nombre de fichero o de la extensión, y el asterisco (*) se puede utilizar para representar bien un nombre de fichero entero o bien una extensión entera. Utilizando el signo de interrogación o el asterisco, o una combinación de los dos, se pueden copiar varios ficheros con una sola orden COPY.</p>
<p>Cuando solo se dispone de una unidad de discos (no MSXVR)</p>
<pre><code>COPY &quot;A:*.BAS&quot; TO &quot;B:&quot;</code></pre>
<p>Esta orden copia todos los ficheros de un disco que tengan la extensión “BAS” en un disco diferente. Al hacerlo es necesario seguir intercambiando el primer disco y el disco nuevo de acuerdo con los mensajes que aparezcan en pantalla, exactamente igual que al copiar un fichero.</p>
<pre><code>COPY &quot;A:ABC.*&quot; TO &quot;B:&quot;</code></pre>
<p>Esta orden copia todos los ficheros de un disco que tengan el nombre “ABC” en otro disco distinto.</p>
<pre><code>COPY &quot;A:PROG??.BAS&quot; TO &quot;B:&quot;</code></pre>
<p>La ejecución de esta orden copia en el disco destino todos los ficheros del disco fuente que respondan al nombre PROG seguido de dos letras y con una extensión “BAS” (por ejemplo, PROG01.BAS, PROG02.BAS, PROGAB.BAS, etc.).</p>
<pre><code>COPY &quot;A:*.*&quot; TO &quot;B:&quot;</code></pre>
<p>Esta orden es la que sirve para copiar todos los ficheros de un disco en otro disco.</p>
<p>Si solo se trabaja con una unidad de discos, es preciso intercambiar el disco fuente y el disco destino de acuerdo con los mensajes de pantalla hasta que salga el OK.</p>
<p>Cuando se dispone de dos o más unidades de discos</p>
<p>La orden COPY se utiliza en este caso de la misma forma que en el caso de trabajar con una sola unidad de discos. Se especifica como nombre de unidad 1 el nombre de la unidad donde está el disco a copiar, y como nombre de unidad 2 el nombre de la unidad que aloja al disco destino.</p>
<pre><code>COPY &quot;A:*.*&quot; TO &quot;B:&quot;</code></pre>
<p>Esta orden copia todos los ficheros del disco de la unidad A en el disco de la unidad B.</p>
<h2 id="copy-1">COPY</h2>
<p>Transfiere datos de imágenes entre la RAM de vídeo, variables de matriz y ficheros de disco.</p>
<p>Válido únicamente para SCREEN 5 a SCREEN 13.</p>
<p>Transfiere los datos desde la página fuente a la página destino usando como parámetro de dirección los siguientes códigos:</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>de arriba-izquierda a abajo-derecha</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>de arriba-derecha a abajo-izquierda</td>
</tr>
<tr class="even">
<td>2</td>
<td>de abajo-izquierda a arriba-derecha</td>
</tr>
<tr class="odd">
<td>3</td>
<td>de abajo-derecha a arriba-izquierda</td>
</tr>
</tbody>
</table>
<p>Las variables de matriz deben ser suficientemente grandes para contener todos los datos de la imagen a copiar. Se puede determinar el tamaño con la fórmula siguiente:</p>
<p>INT (((((ABS(coordenada final X-coordenada inicial X) + 1)*(ABS(coordenada final Y-coordenada inicial Y) + 1)*tamaño del pixel +7)/8)+4)/tamaño del dato)+1</p>
<p>El tamaño del pixel (el número de bits de la RAM de vídeo correspondientes a un punto de la pantalla) varía en función del modo SCREEN.</p>
<table>
<thead>
<tr class="header">
<th><strong>Modo SCREEN</strong></th>
<th><strong>Tamaño del pixel</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>4</td>
</tr>
<tr class="even">
<td>6</td>
<td>2</td>
</tr>
<tr class="odd">
<td>7</td>
<td>4</td>
</tr>
<tr class="even">
<td>8</td>
<td>8</td>
</tr>
<tr class="odd">
<td>10</td>
<td>8</td>
</tr>
<tr class="even">
<td>11</td>
<td>8</td>
</tr>
<tr class="odd">
<td>12</td>
<td>8</td>
</tr>
<tr class="even">
<td>13</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>El tamaño del dato está determinado por el tipo de variable matriz.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>Tamaño del dato</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Entero</td>
<td>2</td>
</tr>
<tr class="even">
<td>Precisión simple</td>
<td>4</td>
</tr>
<tr class="odd">
<td>Precisión doble</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>El tamaño predeterminado del dato es 8.</p>
<h3 id="versión-58">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-58">Formato</h3>
<pre><code>COPY (coordenada de comienzo)-[STEP](coordenada final) [,página fuente] TO (coordenada de comienzo de la transferencia)[,página destino][,operación lógica]</code></pre>
<pre><code> COPY (coordenada de comienzo)-[STEP](coordenada final) [,página fuente] TO &quot;[nombre de la unidad]nombre de fichero variable de matriz[.extensión]&quot;</code></pre>
<pre><code> COPY variable de matriz TO &quot;[nombre de la unidad] nombre del fichero[.extensión]&quot;</code></pre>
<pre><code> COPY &quot;[nombre de la unidad]nombre del fichero[.extensión]&quot; variable de matriz [,dirección] TO (coordenada de inicio de la transferencia)[,página de destino][,operación lógica]</code></pre>
<pre><code> COPY &quot;[nombre de la unidad] nombre del fichero [.extensión]&quot; TO variable de matriz</code></pre>
<h3 id="parámetros-49">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenada de comienzo, coordenada final</th>
<th><strong>Cond.</strong> Constantes, variables de matriz, sus expresiones (de tipo numérico): -32768≤coordenada&lt;32768</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Página fuente, página destino</td>
<td><strong>Cond.</strong> SCREEN 5,6 (64 Kb) Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤página&lt;2. SCREEN 5, 6 (128 Kb) Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤página&lt;4. SCREEN 7, 8, 10 A 13 (128 Kb) Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤página&lt;2. <strong>Omit.</strong> Página activa.</td>
</tr>
<tr class="even">
<td>Operación lógica</td>
<td><strong>Cond.</strong> PSET, PRESET, XOR, OR, AND, TPSET, TXOR, TOR, TAND. <strong>Omit.</strong> PSET.</td>
</tr>
<tr class="odd">
<td>Variable de matriz</td>
<td><strong>Cond</strong>. Numérica.</td>
</tr>
<tr class="even">
<td>Dirección</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤dirección&lt;4. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="odd">
<td>Coordenada de comienzo de la transferencia</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); ‑32768≤coordenada&lt;32768.</td>
</tr>
<tr class="even">
<td>Nombre de la unidad</td>
<td><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-36">Ejemplos</h3>
<pre><code>100 SCREEN 5
110 DIM A(89)
120 OPEN &quot;GRP:&quot; FOR OUTPUT AS #1
130 PRESET (10,10) : PRINT #1, &quot;ABCDE&quot;
140 PRESET (10, 18) : PRINT #1, &quot;HIJKL&quot;
150 COPY (10, 10) – (50, 26), 0 TO A
160 COPY A, 0 TO (80, 60), 0
170 COPY A, 1 TO (80, 100), 0
180 COPY A, 2 TO (80, 140), 0
190 COPY A, 3 TO (80, 180), 0
200 GOTO 200</code></pre>
<p>El valor 89 de la línea 110 DIM A(89) se ha calculado a partir de la siguiente fórmula:</p>
<pre><code>INT((((((50-10)+1)*((26-10)+1)*4+7)/8)+4)/4)+1 = 89</code></pre>
<p>En la línea 150, copiamos el contenido de la VRAM a la matriz de memoria A.</p>
<p>En la línea 160, copiamos el contenido de la matriz de memoria A, empezando de arriba-izquierda hacia abajo-derecha, hasta la coordenada (80, 60) de la página 0 en VRAM.</p>
<p>Del mismo modo, procedemos también a aplicar copias a VRAM, usando diferentes direcciones en las líneas 170, 180 y 190.</p>
<h2 id="copy-screen">COPY SCREEN</h2>
<p>Digitaliza una señal de vídeo externa y la escribe en el VDP. Válida solo para SCREEN 5 a SCREEN 13. Esta orden sirve para dar entrada en el ordenador a imágenes de una cámara o de una pantalla de televisión utilizando a tal efecto un dispositivo digitalizador.</p>
<p>En el modo 0, digitaliza la señal de un campo y la escribe en la página-imagen. En el modo 1, digitaliza las señales de dos campos; una se escribe en la página cuyo número de página es inmediatamente inferior al de la página-imagen y la otra se escribe en la página-imagen.</p>
<p>La máscara especifica el color en la entrada al ordenador; cuando los tres bits más altos son 1, escribe R (rojo), cuando los tres bits siguientes son 1, escribe G (verde), y cuando los dos bits más bajos son 1, escribe B (azul).</p>
<p>Con una máscara &amp;B11111111, escribe R, G y B.</p>
<h3 id="versión-59">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-59">Formato</h3>
<pre><code>COPY SCREEN [modo],[máscara]</code></pre>
<h3 id="parámetros-50">Parámetros</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤modo&lt;2. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Máscara</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤máscara&lt;256. <strong>Omit.</strong> 255.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplo-1">Ejemplo</h3>
<pre><code>100 REM /--
110 VDP (7) = &amp;HFF
120 SET VIDEO ,, 1
130 COPY SCREEN
140 SET VIDEO ,, 0
150 RETURN
160 REM /--digitize
170 VDP (7) = &amp;HFF
180 SET VIDEO
190 COPY SCREEN
200 RETURN</code></pre>
<h2 id="cos">COS</h2>
<p>Devuelve el valor del coseno de un dato numérico. El dato debe expresarse en radianes.</p>
<p>Para convertir X de grados a radianes, se debe utilizar la fórmula COS(X*3.14159/180).</p>
<h3 id="versión-60">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-60">Formato</h3>
<pre><code>COS(x)</code></pre>
<h3 id="parámetros-51">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico, en radianes).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-7">Retorno</h3>
<p>Constantes de coma flotante; -1≤valor≤1.</p>
<h3 id="ejemplos-37">Ejemplos</h3>
<pre><code>PRINT COS (3.14/3)
 .50045968900814</code></pre>
<pre><code>PRINT COS(60*3.14/180)
 .50045968900814</code></pre>
<h2 id="csave">CSAVE</h2>
<p>Almacena en una cinta de casete un programa VR-BASIC.</p>
<p>Respecto a la velocidad de transmisión (baudios), cabe decir que cuando se especifica 1 la velocidad es 1200 baudios y cuando se especifica 2 es 2400.</p>
<h3 id="versión-61">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-61">Formato</h3>
<pre><code>CSAVE &quot;nombre del fichero&quot; [,velocidad de transmisión]</code></pre>
<h3 id="parámetros-52">Parámetros</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del fichero</th>
<th><strong>Cond.</strong> Una cadena de 6 o menos caracteres. Si se especifican 7 o más caracteres, ignora los caracteres siguientes al sexto.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Velocidad de transmisión</td>
<td><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 1≤velocidad en baudios&lt;3. <strong>Omit.</strong> 1.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-38">Ejemplos</h3>
<pre><code>CSAVE &quot;PROG1&quot;</code></pre>
<p>Almacena en cinta de casete un programa VR-BASIC en memoria, bajo el nombre de “PROG1”, y a una velocidad de 1200 baudios.</p>
<h2 id="csng">CSNG</h2>
<p>Convierte datos numéricos en datos de precisión simple.</p>
<h3 id="versión-62">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-62">Formato</h3>
<pre><code> CSNG (x)</code></pre>
<h3 id="parámetros-53">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-8">Retorno</h3>
<p>Dato numérico de simple precisión.</p>
<h3 id="ejemplos-39">Ejemplos</h3>
<pre><code>10 PRINT SQR (3)
20 PRINT CSNG (SQR(3))
RUN
 1.7320508075688
 1.73205</code></pre>
<h2 id="csrlin">CSRLIN</h2>
<p>Da la coordenada Y de la posición del cursor.</p>
<h3 id="versión-63">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-63">Formato</h3>
<pre><code>CSRLIN</code></pre>
<h3 id="ejemplos-40">Ejemplos</h3>
<pre><code>10 CLS
20 INPUT A$
30 PRINT A$
40 CL = CSRLIN
50 LOCATE 0, CL+3:PRINT &quot;FIN&quot;</code></pre>
<p>El texto que presenta en pantalla la línea 30 puede ocupar una sola línea o varias líneas, en función de su longitud. Pero, en todo caso, la línea 40 guarda en la variable CL la coordenada Y (posición vertical) del cursor tras la presentación visual, y por lo tanto la palabra “FIN” se visualiza en una posición vertical (coordenada Y) de un valor superior en 3 unidades al valor de CL. La palabra " FIN" se visualiza por lo tanto 3 líneas más abajo, sea cual sea la longitud del dato A$.</p>
<h2 id="cvicvscvd">CVI/CVS/CVD</h2>
<p>Convierten una cadena de caracteres en un dato numérico.</p>
<p>En los ficheros de acceso aleatorio de disco, los datos numéricos se convierten en cadenas de caracteres y se almacenan así. Esta conversión está a cargo de las funciones MKI$, MKS$ y MKD$, y para hacer lo contrario están las funciones CVI, CVS y CVD: convierten las cadenas de caracteres leídas de ficheros de acceso aleatorio en los datos numéricos originales; CVI convierte una cadena de 2 caracteres (2 bytes) en un dato numérico entero; CVS convierte una cadena de 4 caracteres (4 bytes) en un dato numérico de coma flotantes de simple precisión; y CVD convierte una cadena de 8 caracteres (8 bytes) en un dato numérico de coma flotante y doble precisión.</p>
<h3 id="versión-64">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-64">Formato</h3>
<pre><code>CVI (X$)</code></pre>
<pre><code>CVS (X$)</code></pre>
<pre><code>CVD (X$)</code></pre>
<h3 id="parámetros-54">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>CVI</th>
<th>X$</th>
<th><strong>Cond.</strong> Dato de caracteres de 2 bytes.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CVS</td>
<td>X$</td>
<td><strong>Cond.</strong> Dato de caracteres de 4 bytes.</td>
</tr>
<tr class="even">
<td>CVD</td>
<td>X$</td>
<td><strong>Cond.</strong> Dato de caracteres de 8 bytes.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-9">Retorno</h3>
<table>
<thead>
<tr class="header">
<th>CVI (X$)</th>
<th>Tipo entero</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CVS (X$)</td>
<td>Precisión simple</td>
</tr>
<tr class="even">
<td>CVD (X$)</td>
<td>Precisión doble</td>
</tr>
</tbody>
</table>
<h2 id="data">DATA</h2>
<p>Almacena los datos que serán leídos por una instrucción READ.</p>
<p>Cuando hay varios datos en una instrucción DATA, se separan mediante comas.</p>
<p>Si los datos de una instrucción DATA se corresponden secuencialmente con las variables de una instrucción READ, la instrucción DATA se puede poner en cualquier sitio en relación con la instrucción READ correspondiente.</p>
<p>Cuando un dato de tipo alfanumérico incluye una coma (,) o un signo de dos puntos (:), o cuando hay un espacio delante o detrás, se pone entre dobles comillas(").</p>
<h3 id="versión-65">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-65">Formato</h3>
<pre><code>DATA constante[,constante][,constante][,constante]...</code></pre>
<h3 id="parámetros-55">PARÁMETROS</h3>
<table>
<thead>
<tr class="header">
<th>Constante</th>
<th><strong>Cond.</strong> De tipo numérico o alfanumérico</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-41">EJEMPLOS</h3>
<p>Un ejemplo donde leemos datos números para usar como coordenadas:</p>
<pre><code>10 CLS
20 SCREEN 2
30 READ A, B, C, D,
40 LINE (A, B) - (C, D)
50 DATA 0, 0, 255, 191
60 GOTO 60</code></pre>
<p>Otro ejemplo donde manejamos datos alfanuméricos y sacamos por pantalla nombres hasta encontrar una cadena de texto vacía:</p>
<pre><code>10 DATA &quot;ANTONIO:&quot;, &quot;JUAN:&quot;, &quot;PERICO:&quot;, &quot;&quot;
20 READ A$
30 IF A$=&quot;&quot; THEN 60
40 PRINT A$
50 GOTO 20
60 END</code></pre>
<h2 id="def-fn">DEF FN</h2>
<p>Define una función de usuario.</p>
<h3 id="versión-66">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-66">Formato</h3>
<pre><code>DEF FN nombre de función [(parámetro [,parámetro]...)] = expresión</code></pre>
<h3 id="parámetros-56">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de función</th>
<th><strong>Cond.</strong> Variables numéricas, variables de cadena (en función de la expresión).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Parámetro</td>
<td><strong>Cond.</strong> Hasta 9 variables.</td>
</tr>
<tr class="even">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas o alfanuméricas).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-42">Ejemplos</h3>
<pre><code>10 DEF FN A(X,Y) = (X*2+Y*3)/(X-Y)
20 B = FN A(4,2)
30 PRINT B
RUN
 7</code></pre>
<p>La línea 10 define la función FN A(X, Y) según la expresión del segundo término. En la línea 20 se dan los valores 4 y 2 a los parámetros X e Y, y luego se hace una llamada a la función definida. El resultado (7) se asigna a la variable B.</p>
<h2 id="defint-defsngdefdbldefstr">DEFINT/ DEFSNG/DEFDBL/DEFSTR</h2>
<p>Define la relación entre el primer carácter del nombre de variable y el tipo de variable, donde INT define variables de tipo entero, SNG define variables de tipo precisión simple, DBL define variables de tipo precisión doble y STR define variables de tipo cadena de texto.</p>
<h3 id="versión-67">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-67">Formato</h3>
<pre><code>DEFINT carácter [- carácter]
DEFSNG carácter [- carácter]
DEFDBL carácter [- carácter]
DEFSTR carácter [- carácter]</code></pre>
<h3 id="parámetros-57">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Carácter</th>
<th><strong>Cond.</strong> Un carácter alfabético.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-43">Ejemplos</h3>
<pre><code>DEFINT A-C</code></pre>
<p>El resultado de esta instrucción es que todas las variables que comiencen por los caracteres A, B y C son consideradas de tipo entero.</p>
<p>Sin embargo, los caracteres de declaración de tipo (%, !, #, $) tienen prioridad.</p>
<p>Por ejemplo, aunque se haga DEFINT A y sea considerada una variable entera, A se convertirá en una variable de precisión doble si después se la declara como A#.</p>
<div class="line-block">10 DEFINT A-C | las variables A a la C son de tipo entero |<br />
20 A = 1.23456789# | |</div>
<p>|————————————————|———————————————————————————–| | 20 A = 1.23456789# | A consecuencia de la línea 20, las variables A, ABC quedan convertidas en enteros | | 30 ABC = 1.23456789# | | | 40 B# = 1.23456789# | de doble precisión poniendo # | | 50 C! = 1.23456789 | de precisión simple poniendo ! | | 60 PRINT A;ABC;B#;C! | | | RUN | | | 1 1 1.23456789 1.23457 | |</p>
<h2 id="defusr">DEFUSR</h2>
<p>Especifica la dirección inicial de una subrutina en lenguaje máquina que se ejecutará después con una función USR.</p>
<h3 id="versión-68">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-68">Formato</h3>
<pre><code>DEFUSR[x] = dirección inicial</code></pre>
<h3 id="parámetros-58">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes enteras; 0≤X≤9. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dirección inicial</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤dirección&lt;65536.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-44">Ejemplos</h3>
<pre><code>DEFUSR1 = &amp;HE000</code></pre>
<p>El resultado de esta instrucción es la definición como USR1 de la subrutina en lenguaje máquina que empieza en la dirección &amp;HE000.</p>
<p>La dirección inicial se puede redefinir en un programa todas las veces que sea necesario sin cambiar el valor del número (X).</p>
<h2 id="delete">DELETE</h2>
<p>Borra una línea específica de un programa.</p>
<h3 id="versión-69">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-69">Formato</h3>
<pre><code>DELETE [número de línea] [-número de línea]</code></pre>
<h3 id="parámetros-59">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras; 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-45">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>DELETE 40</th>
<th>Borra la línea 40</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DELETE 20-40</td>
<td>Borra las líneas 20 a 40</td>
</tr>
<tr class="even">
<td>DELETE -50</td>
<td>Borra todas las líneas hasta la 50</td>
</tr>
<tr class="odd">
<td>DELETE</td>
<td>Borra una línea presentada en último lugar por una instrucción LIST o una línea interrumpida a consecuencia de un error.</td>
</tr>
</tbody>
</table>
<p>Cuando solo hay que borrar una línea, una alternativa es escribir el número de línea y pulsar ENTER.</p>
<h2 id="dim">DIM</h2>
<p>Define la dimensión, el tamaño, el tipo de dato y el nombre de una variable de matriz.</p>
<h3 id="versión-70">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-70">Formato</h3>
<pre><code>DIM nombre de variable (valor máximo de un subíndice[,valor máximo de un subíndice]...)[,nombre de variable (valor máximo de un subíndice [,valor máximo de un subíndice]...)]...</code></pre>
<h3 id="parámetros-60">Parámetros</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Variable numérica o de cadena</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valor máximo de un subíndice</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (enteros mayores que 0).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-46">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 81%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th>DIM A(15)</th>
<th>Reserva en memoria una zona de 16 variables de matriz numéricas desde A(0) a A(15). El valor inicial por defecto de las variables es 0.</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DIM B$ (2, 3)</td>
<td>Reserva en memoria una zona de 12 variables de cadena, mostrada en la tabla siguiente. El valor inicial por defecto de las variables es una cadena nula.</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>B$(0,0)</td>
<td>B$(1,0)</td>
<td>B$(2,0)</td>
</tr>
<tr class="odd">
<td></td>
<td>B$(0,1)</td>
<td>B$(1,1)</td>
<td>B$(2,1)</td>
</tr>
<tr class="even">
<td></td>
<td>B$(0,2)</td>
<td>B$(1,2)</td>
<td>B$(2,2)</td>
</tr>
<tr class="odd">
<td></td>
<td>B$(0,3)</td>
<td>B$(1,3)</td>
<td>B$(2,3)</td>
</tr>
</tbody>
</table>
<p><strong>Definición de múltiples variables de matriz mediante una instrucción DIM</strong></p>
<pre><code>DIM A(2), B$(4,2), C(3,3)</code></pre>
<p>Las variables están separadas por comas.</p>
<p><strong>Variables de matriz multi-dimensionales</strong></p>
<p>Las variables de matriz multi-dimensionales se generan especificando 2 o más subíndices. (Se pueden especificar 255 dimensiones como máximo).</p>
<p>DIM X(3,4,5) <em>3 dimensiones</em></p>
<p><strong>Omisión de la instrucción DIM</strong></p>
<p>Cuando se utiliza una variable de matriz sin declararla previamente con una instrucción DIM, se considera que el valor máximo del subíndice es 10.</p>
<h2 id="draw">DRAW</h2>
<p>Dibuja gráficos en la pantalla en modo gráfico, siguiendo las especificaciones de los submandatos gráficos.</p>
<p>La posición actual se almacena siempre con un mandato para dibujar una línea, con excepción de Sn, An y Cn. Por ejemplo:</p>
<pre><code>DRAW &quot;M100, 120&quot;</code></pre>
<p>Cuando el comando anterior dibuja una línea desde un punto determinado hasta otro punto (100, 120), este último punto pasa a ser el punto actual. Cuando posteriormente se ejecute una orden de dibujo de una línea, esta empezará desde este último punto actual.</p>
<p>Delante de un mandato de dibujo de una línea se pueden colocar uno de los mandatos siguientes:</p>
<p>B…Aunque desplaza el punto actual, no dibuja línea alguna. (Ejemplo: BM0,0)</p>
<p>N…Aunque dibuja una línea, no desplaza el punto actual. (Ejemplo: NU30, 30NR30, 30)</p>
<p><strong>Expresión de un comando con una variable</strong></p>
<pre><code>A$ = &quot;BM100, 150U50E50F50D50L100&quot;
DRAW A$</code></pre>
<p>En este ejemplo se asigna primero un comando a la variable de cadena A$, y después se especifica que A$ es un comando de una instrucción DRAW.</p>
<p><strong>Expresión de una parte de un comando con una variable (X variable;)</strong></p>
<pre><code>A$ = &quot;U20R20D20L20&quot;
DRAW &quot;BM50, 50XA$;&quot;
DRAW &quot;BM150, 100XA$;&quot;</code></pre>
<p>Cuando un comando asignado a una variable de cadena está puesto entre dobles comillas en una instrucción DRAW, se debe añadir “X” antes de las comillas y “;” después de tal variable. En este ejemplo, un comando asignado a A$ se utiliza en dos instrucciones DRAW.</p>
<p><strong>Expresión de n en un comando con una variable (=variable;)</strong></p>
<p>La n que expresa la distancia, el ángulo y el código de color con cada suborden puede ser una constante o una variable en una instrucción DRAW. Cuando está expresada mediante una variable, se debe añadir “=” delante y “;” detrás de dicha variable.</p>
<pre><code>X = 40
DRAW &quot;U = X;&quot;</code></pre>
<p>es lo mismo que</p>
<pre><code>DRAW &quot;U40&quot;</code></pre>
<h3 id="versión-71">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-71">Formato</h3>
<pre><code>DRAW comandos</code></pre>
<h3 id="parámetros-61">Parámetros</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 40%" />
<col style="width: 54%" />
<col style="width: 0%" />
</colgroup>
<thead>
<tr class="header">
<th>comandos</th>
<th><strong>Cond.</strong> Cadena de caracteres (constantes) encerradas entre comillas ("") o variables de cadena que tienen asignada una cadena de caracteres. Caracteres en mayúsculas o minúsculas.</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Comando</strong></td>
<td><strong>Condición</strong></td>
<td><strong>Significado</strong></td>
<td></td>
</tr>
<tr class="even">
<td>Sn (escala)</td>
<td>0≤n≤255</td>
<td>Especifica el número de puntos correspondiente a una unidad cuando se dibuja una línea. Con n = 1, ¼ de punto. El valor inicial es S4.</td>
<td></td>
</tr>
<tr class="odd">
<td>An (ángulo)</td>
<td>0≤n≤3</td>
<td>Gira el sistema de coordenadas un paso de 90º a partir de un eje de coordenadas estándar (0º). El valor inicial es A0.</td>
<td></td>
</tr>
<tr class="even">
<td>Cn (color)</td>
<td>0≤n≤15</td>
<td>Especifica un color para una línea dibujada mediante un código de color. El valor inicial es C15.</td>
<td></td>
</tr>
<tr class="odd">
<td>Mx,y (movimiento)</td>
<td>0≤x≤255 0≤y≤191</td>
<td>Traza una línea desde un punto actual hasta una posición absoluta (x,y).</td>
<td></td>
</tr>
<tr class="even">
<td>M±x,±y (movimiento)</td>
<td>0≤x≤255 0≤y≤191</td>
<td>Desplaza horizontalmente ±x y verticalmente ±y desde un punto actual. La unidad de x,y es el número de puntos especificado por el comando S.</td>
<td></td>
</tr>
<tr class="odd">
<td>Un (arriba)</td>
<td></td>
<td>Dibuja una línea en dirección negativa del eje y, desde un punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
<tr class="even">
<td>Dn (abajo)</td>
<td></td>
<td>Dibuja una línea en dirección positiva del eje y, desde un punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
<tr class="odd">
<td>Rn (derecha)</td>
<td></td>
<td>Dibuja una línea en dirección positiva del eje x, desde un punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
<tr class="even">
<td>Ln (izquierda)</td>
<td></td>
<td>Dibuja una línea en dirección negativa del eje x, desde un punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 96%" />
<col style="width: 1%" />
</colgroup>
<thead>
<tr class="header">
<th>En</th>
<th></th>
<th>Dibuja una línea en la dirección positiva del eje X y en la dirección negativa del eje Y, desde el punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Fn</td>
<td></td>
<td>Dibuja una línea en la dirección positiva del eje X y en la dirección positiva del eje Y, desde el punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
<tr class="even">
<td>Gn</td>
<td></td>
<td>Dibuja una línea en la dirección negativa del eje X y en la dirección positiva del eje Y, desde el punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
<tr class="odd">
<td>Hn</td>
<td></td>
<td>Dibuja una línea en la dirección negativa del eje X y en la dirección negativa del eje Y, desde el punto actual hasta otro punto situado a una distancia n. Esta unidad se multiplicará por la escala (comando S) para obtener el número de puntos a dibujar. El valor de n es 1 por omisión.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ejemplo-1-1">Ejemplo 1</h3>
<pre><code>10 SCREEN 2</code></pre>
<pre><code>20 OPEN &quot;GRP:&quot; AS #1</code></pre>
<pre><code>30 DRAW &quot;BM100,100&quot;</code></pre>
<pre><code>40 PRINT#1,&quot;HELP&quot;</code></pre>
<pre><code>50 DRAW &quot;BM102,102&quot;</code></pre>
<pre><code>60 PRINT#1,&quot;HELP&quot;</code></pre>
<pre><code>70 DRAW &quot;BM100,120&quot;</code></pre>
<pre><code>80 PRINT#1, USING&quot;###.######&quot;;ATN(1)*4</code></pre>
<pre><code>90 GOTO 90</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-2">Ejemplo 2</h3>
<pre><code></code></pre>
<pre><code>10 COLOR 1,15,15</code></pre>
<pre><code>20 SCREEN 2</code></pre>
<pre><code>30 OPEN &quot;GRP:&quot; AS #1</code></pre>
<pre><code>40 FOR I=0 TO 15</code></pre>
<pre><code>50 COLOR I</code></pre>
<pre><code>60 DRAW &quot;BM+8,0&quot;</code></pre>
<pre><code>70 PRINT#1,&quot;COLOUR CODE&quot;;I</code></pre>
<pre><code>80 NEXT I</code></pre>
<pre><code>90 GOTO 90</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-3">Ejemplo 3</h3>
<pre><code></code></pre>
<pre><code>5 REM $MACRO LENGUAJE GRAFICO$</code></pre>
<pre><code>10 SCREEN2</code></pre>
<pre><code>20 REM :A$ = PERFIL CASA</code></pre>
<pre><code>30 A$ = &quot;BM70,130U60BD60R60U60BL30BU40NF40NG40D2NF38NG38&quot;</code></pre>
<pre><code>40 REM:B$ = PUERTAS/VENTANAS</code></pre>
<pre><code>50 B$ = &quot;BM80,70R10D20L10U20BR30R10D20L10U20BM90,100R20D30BL20U30BM82,70D20BR2U20BR2D20BR2U20BM112,70D20BR2U20BR2D20BR2U20BM92,100D30BR2U30BR2D30BR2U30BR2D30BR2U30BR2D30BR2U30BR2D30&quot;</code></pre>
<pre><code>55 REM:C$ = CHIMENEA/HUMO</code></pre>
<pre><code>58 C$ = &quot;BM80,50U15R10D5BM90,30E10U10E10BD10R10D10L10U10DB10BR20U10F10U10BR10F5NE5D5&quot;</code></pre>
<pre><code>60 REM:D$ = PAJAROS</code></pre>
<pre><code>70 D$ = &quot;BM170,30F10E10BM190,40F10E10&quot;</code></pre>
<pre><code>80 REM:E$ = CARTEL.HITBIT 55</code></pre>
<pre><code>90 E$ = &quot;BM170,120R60D50L60U50 BM180,140U10D5R5D5BR5U5BU2U1 BM195,140U10NL2NR2BR10D10U5R5D5L5BR10U5BU2U1 BM220,140U10NL2NR2 BM190,160R5U5L5U5R5BD10BR10R5U5L5U5R5&quot;</code></pre>
<pre><code>100 REM:F$ = CAMINO</code></pre>
<pre><code>110 F$ = &quot;BM90,140F10G10F10BM110,140F10G10F10&quot;</code></pre>
<pre><code>150 DRAW&quot;XA$;&quot;</code></pre>
<pre><code>160 DRAW&quot;XB$;&quot;</code></pre>
<pre><code>170 DRAW&quot;XC$;&quot;</code></pre>
<pre><code>180 DRAW&quot;XD$;&quot;</code></pre>
<pre><code>190 DRAW&quot;XE$;&quot;</code></pre>
<pre><code>200 DRAW&quot;XF$;&quot;</code></pre>
<pre><code>250 FOR I = 0 TO 5000</code></pre>
<pre><code>260 NEXT I</code></pre>
<pre><code>270 A = RND(1)*15</code></pre>
<pre><code>280 B = RND(1)*15:C = RND(1)*15</code></pre>
<pre><code>290 COLOR A,B,C</code></pre>
<pre><code>300 GOTO 300</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-4">Ejemplo 4</h3>
<pre><code></code></pre>
<pre><code>1 REM ** COMANDOS GRAFICOS **</code></pre>
<pre><code>10 COLOR 15,1,1</code></pre>
<pre><code>15 &#39;*** ALTA RESOLUCION --&gt;SCREEN 2</code></pre>
<pre><code>20 SCREEN 2</code></pre>
<pre><code>25 &#39;*** PUNTO ***</code></pre>
<pre><code>30 PSET(32,32),15</code></pre>
<pre><code>35 &#39;*** LINEA ***</code></pre>
<pre><code>40 LINE(76,32)-(116,32),8 </code></pre>
<pre><code>45 &#39;*** RECTANGULO ***</code></pre>
<pre><code>50 LINE(135,12)-(180,52),12,B</code></pre>
<pre><code>55 &#39;*** PINTAR UN RECTANGULO *** </code></pre>
<pre><code>60 LINE(204,12)-(244,52),8, BF</code></pre>
<pre><code>65 &#39;*** CIRCULO *** </code></pre>
<pre><code>70 CIRCLE(32,96),20,5</code></pre>
<pre><code>75 &#39;*** PINTAR UN CIRCULO ***</code></pre>
<pre><code>80 CIRCLE(96,96),20,4</code></pre>
<pre><code>90 PAINT(96,96),4</code></pre>
<pre><code>95 &#39;*** ELIPSE HORIZONTAL ***</code></pre>
<pre><code>100 CIRCLE(160,96),20,15,,,.5</code></pre>
<pre><code>105 &#39;** PINTAR UNA ELIPSE HORIZONTAL ***</code></pre>
<pre><code>110 CIRCLE(224,96),20,13,,,.5</code></pre>
<pre><code>120 &#39;PAINT(224,96),13</code></pre>
<pre><code>125 &#39;*** ELIPSE VERTICAL ***</code></pre>
<pre><code>130 CIRCLE(32,160),20,2,,,2</code></pre>
<pre><code>135 &#39;*** PINTAR UNA ELIPSE VERTICAL ***</code></pre>
<pre><code>140 CIRCLE(96,160),20,11,,,2</code></pre>
<pre><code>150 DRAW &quot;c2bm140,160 rl0e20f5r10e10f5e10r5e5f10r5f10&quot;</code></pre>
<pre><code>155 &#39;*** MACROLENGUAJE GRAFICO ***</code></pre>
<pre><code>170 GOTO 170</code></pre>
<h2 id="dskf">DSKF</h2>
<p>Devuelve el espacio libre que queda en el disco en unidades de clusters.</p>
<p>El número de unidad 1 corresponde a la unidad A, el número 2 a la unidad B, el 3 a la unidad C y así sucesivamente.</p>
<p>El número de unidad 0 corresponde a la unidad en activo.</p>
<p>Da el espacio libre que queda en el disco alojado en la unidad de discos especificada por el número de la unidad.</p>
<p>1 cluster equivale a 2 sectores de un disco flexible de 3,5 pulgadas (en caso de tratarse de una unidad MSXVR, 1 cluster equivaldrá a 256 bytes). Una unidad de una sola cara tiene como máximo 355 clusters.</p>
<h3 id="versión-72">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-72">Formato</h3>
<pre><code>DSKF (número de unidad)</code></pre>
<h3 id="parámetros-62">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de unidad</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones de tipo numérico), 0≤número&lt;9.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-10">Retorno</h3>
<p>Tipo entero.</p>
<h2 id="end">END</h2>
<p>Da por terminada la ejecución de un programa y establece el estado de espera de mandatos.</p>
<p>Cuando hay un fichero abierto, lo cierra.</p>
<p>La instrucción END se pone en la última línea de un programa cuando a continuación hay una subrutina, con el objeto de evitar que la subrutina sea ejecutada otra vez tras la finalización del programa principal. Se puede poner en un programa las veces que se quiera. Por ejemplo, cuando el resultado de la ejecución de un programa tiene efectos en alguna bifurcación, se puede poner al final de cada bifurcación.</p>
<p>Una vez un programa ha terminado mediante END, para ejecutarlo otra vez se utiliza una instrucción RUN o GOTO. No se puede continuar con una instrucción CONT.</p>
<h3 id="versión-73">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-73">Formato</h3>
<pre><code>END</code></pre>
<h3 id="ejemplos-47">Ejemplos</h3>
<pre><code>    .
    .
100 GOSUB 1000
    .
    .
190
200 END
1000 SUBROUTINE
    .
    .
1100 RETURN</code></pre>
<p>En este programa, si no estuviera la instrucción END de la línea 200, al llegar a ese punto del programa se ejecutaría la subrutina de la línea 1000. Al no haberse lanzado el comando de la instrucción GOSUB, una vez lleguemos a la línea 110, el RETURN ejecutado produciría un error del tipo: RETURN WITHOUT GOSUB.</p>
<h2 id="eof">EOF</h2>
<p>Cuando ha sido leído el último dato de un fichero da un -1; en los demás casos da un 0.</p>
<h3 id="versión-74">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-74">Formato</h3>
<pre><code>EOF (número de fichero)</code></pre>
<h3 id="parámetros-63">Parámetros</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero); 1≤número de fichero&lt; número especificado por MAXFILE.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-11">Retorno</h3>
<p>Tipo entero (-1 o 0).</p>
<h3 id="ejemplos-48">Ejemplos</h3>
<pre><code>IF EOF(1) THEN CLOSE #1</code></pre>
<p>Esta sentencia mira si hemos alcanzado el final del fichero con número 1. En caso afirmativo, se cerrará.</p>
<h2 id="erase">ERASE</h2>
<p>Borra variables de matriz.</p>
<h3 id="versión-75">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-75">Formato</h3>
<pre><code>ERASE nombre de variable de matriz[,nombre de variable de matriz]...</code></pre>
<h3 id="parámetros-64">Parámetros</h3>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>nombre de variable de matriz</th>
<th>Una o varias etiquetas que hagan referencia a variables matriz.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-49">Ejemplos</h3>
<pre><code>10 DIM A(100), B$(4,3)
    .
    .
100 ERASE A, B$</code></pre>
<p>En este ejemplo, la línea 100 borra las variables de matriz A y B$ declaradas en la línea 10. De esta forma se puede utilizar esa zona de la memoria para otros fines. Además, mediante una instrucción DIM se puede volver a definir una variable de matriz con el mismo nombre.</p>
<h2 id="erl">ERL</h2>
<p>Ofrece el número de línea donde se ha producido un error.</p>
<p>Cuando no hay ningún error devuelve cero, y cuando hay un error que es consecuencia de un mandato directo, retorna un número comprendido entre 1 y 65529.</p>
<p>Se utiliza en combinación con una instrucción ON ERROR o con una instrucción ERROR para identificar el número de línea donde ha ocurrido.</p>
<h3 id="versión-76">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-76">Formato</h3>
<pre><code>ERL</code></pre>
<h3 id="retorno-12">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-50">Ejemplos</h3>
<pre><code>10 ON ERROR GOTO 50
20 MSXVR &#39; Este comando no es válido 
30 END
50 PRINT &quot;Ha ocurrido un error en la linea &quot;;ERL
60 RESUME 30

RUN
Ha ocurrido un error en la linea 20</code></pre>
<pre><code></code></pre>
<h2 id="err">ERR</h2>
<p>Ofrece el código numérico de un error detectado.</p>
<p>Se puede usar para el proceso de errores en un programa en combinación con una instrucción ERROR o con la función ERL.</p>
<p>Si no se ha producido ningún error, se obtendrá 0.</p>
<h3 id="versión-77">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-77">Formato</h3>
<pre><code>ERR</code></pre>
<h3 id="retorno-13">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-51">Ejemplos</h3>
<pre><code>PRINT 10/0
Division by zero
Ok</code></pre>
<pre><code>PRINT ERR
 11</code></pre>
<h2 id="error">ERROR</h2>
<p>Simula el error a partir de su número o define un número de error.</p>
<h3 id="versión-78">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-78">Formato</h3>
<pre><code>ERROR número</code></pre>
<h3 id="parámetros-65">Parámetros</h3>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>número</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (numéricas); 0≤número&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-52">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>ERROR 1</th>
<th>Genera un error “NEXT without FOR” (detiene la ejecución del programa)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><strong>Definición por el usuario del número de error</strong></p>
<pre><code>IF A&lt;0 THEN ERROR 250</code></pre>
<p>Cuando se asigna a una variable un número negativo, la instrucción anterior da lugar al error 250 (como en el VR-BASIC están definidos los números de error del 0 al 71, hay que utilizar números superiores al 71).</p>
<p>Cuando se introduce un número negativo en el programa siguiente, se visualiza en pantalla un mensaje de error que indica que es necesario un número positivo, y la ejecución del programa continúa.</p>
<pre><code>10 ON ERROR GOTO 90
20 FOR I = 1 TO 10
30 INPUT A
40 IF A &lt;0 THEN ERROR 250
50 SUM = SUM+A
60 NEXT I
70 PRINT SUM
80 END
90 IF ERR = 250 THEN PRINT &quot;Introduzca un número positivo&quot;  :RESUME 30
100 PRINT &quot;Error&quot;</code></pre>
<h2 id="exp">EXP</h2>
<p>Ofrece ex que es la función exponencial natural de X.</p>
<p>El número e equivale a 2.7182818284558 y es la base de los logaritmos naturales.</p>
<h3 id="versión-79">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-79">Formato</h3>
<pre><code>EXP (X)</code></pre>
<h3 id="parámetros-66">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones de tipo numérico, de valor inferior a 145.06286085862</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-14">Retorno</h3>
<p>Tipo numérico de coma flotante.</p>
<h3 id="ejemplos-53">Ejemplos</h3>
<pre><code>PRINT EXP (100)
 2.6881171418087E+43</code></pre>
<h2 id="field">FIELD</h2>
<p>Especifica el formato de los registros de entrada/salida de un fichero de acceso aleatorio.</p>
<p>El formato del registro se define mediante una instrucción FIELD antes de realizar la entrada/salida de datos de un fichero de acceso aleatorio mediante las instrucciones GET o PUT.</p>
<p>El número de fichero especifica el fichero ya abierto por una instrucción OPEN. Tras la ejecución de la instrucción FIELD, si se ejecuta una instrucción de asignación hacia una variable de cadena del FIELD, esta cadena se convierte en una variable de cadena de la memoria y la especificación de la instrucción FIELD deja de ser válida.</p>
<p>La longitud máxima para un registro es de 256 bytes; así, la suma total de las longitudes de las variables especificadas en una instrucción FIELD no debe ser superior a 256 bytes. La longitud de una variable no debe ser superior a 255 bytes.</p>
<h3 id="versión-80">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-80">Formato</h3>
<pre><code>FIELD [#] número de fichero, longitud de caracteres AS variable de cadena [,longitud de caracteres AS variable de cadena]...</code></pre>
<h3 id="parámetros-67">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤número de fichero≤número de fichero especificado por MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Longitud de caracteres</td>
<td><strong>Cond</strong>. Constantes, variables de matriz, sus expresiones (de tipo numérico); 0≤longitud de caracteres≤longitud del registro. El total de longitudes de caracteres de una instrucción FIELD no debe superar la longitud del registro.</td>
</tr>
<tr class="even">
<td>Variable de cadena</td>
<td><strong>Cond</strong>. Una variable de cadena.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-54">Ejemplos</h3>
<pre><code>FIELD #1,20 AS A$, 30 AS B$, 40 AS C$</code></pre>
<p>Esta instrucción FIELD asigna las variables de cadena A$, B$, y C$ al registro de entrada/salida que utiliza el fichero #1. La longitud de esas variables es 20, 30 y 40 bytes respectivamente. Si el total de las longitudes (en este caso 90 bytes) superara la longitud de registro especificada en la instrucción OPEN, daría un error.</p>
<h2 id="files">FILES</h2>
<p>Presenta en pantalla los nombres de los ficheros que hay en el disco especificado.</p>
<p>El signo de interrogación (?) puede sustituir a uno o más caracteres del nombre de fichero o a toda la extensión.</p>
<h3 id="versión-81">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="fomato">Fomato</h3>
<pre><code>FILES [&quot;[nombre de la unidad][nombre del fichero[.extensión]]&quot;]</code></pre>
<h3 id="parámetros-68">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de 8 o menos caracteres.</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 o menos caracteres.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-55">Ejemplos</h3>
<pre><code>FILES &quot;A: TEST.DAT&quot;</code></pre>
<p>Esta instrucción FILES pide al ordenador que busque el nombre de fichero TEST.DAT en el disco alojado en la unidad A y que saque en pantalla TEST.DAT si lo encuentra. Si no lo encuentra, saldrá en pantalla el mensaje “File not found” (fichero no encontrado).</p>
<p>Cuando se especifica: FILES “A:TEST??.DAT” saldrán en pantalla los nombres de todos los ficheros cuyos nombres tengan las letras TEST como los cuatro primeros caracteres, seguidas por otros dos caracteres cualquiera, y cuya extensión sea DAT.</p>
<p>Cuando se especifica: FILES “A:TEST.*” saldrán en pantalla todos los ficheros con el nombre TEST independientemente de su extensión.</p>
<pre><code>FILES &quot;A:&quot;</code></pre>
<p>presentará en pantalla los nombres de todos los ficheros del disco de la unidad A.</p>
<p>Cuando se omite el nombre de la unidad, como en: FILES “TEST.*”, queda especificada, por omisión, la unidad de discos en activo.</p>
<p>Si se ejecuta solo la orden FILES saldrán en pantalla todos los nombres de fichero del disco de la unidad en activo.</p>
<h2 id="fix">FIX</h2>
<p>Ofrece el entero de un dato numérico X después de eliminar las cifras situadas a la derecha del punto decimal.</p>
<h3 id="versión-82">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-81">Formato</h3>
<pre><code>FIX (X)</code></pre>
<h3 id="parámetros-69">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-15">Retorno</h3>
<p>Tipo numérico</p>
<h3 id="ejemplos-56">Ejemplos</h3>
<pre><code>PRINT FIX (3); FIX (-3); FIX(3.58); FIX(-3.58)
 3 -3 3 -3</code></pre>
<h2 id="for--next">FOR -NEXT</h2>
<p>Repite la ejecución de la parte del programa comprendida entre una instrucción FOR y su correspondiente instrucción NEXT.</p>
<p>La parte del programa comprendida entre una instrucción FOR y la instrucción NEXT correspondiente se ejecuta repetidamente mientras el valor de la variable especificada en la instrucción FOR va siendo incrementada desde un determinado valor inicial hasta que alcanza el valor final determinado. El valor de la variable es incrementado una cantidad especificada cada vez que se llega al final de la ejecución de esa parte del programa.</p>
<p>Aunque se puede omitir la variable de la instrucción NEXT, la correspondencia entre las instrucciones FOR y NEXT se puede ver más fácilmente si el listado del programa incluye tal variable.</p>
<h3 id="versión-83">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-82">Formato</h3>
<pre><code>FOR variable=valor inicial TO valor final [STEP incremento]</code></pre>
<pre><code>    .</code></pre>
<pre><code>    .</code></pre>
<pre><code>    .</code></pre>
<pre><code>NEXT [variable][,variable]...</code></pre>
<h3 id="parámetros-70">Parámetros</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Variable de tipo numérico. Las variables de la instrucción FOR deben coincidir con las de la instrucción NEXT.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valor inicial, valor final</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico).</td>
</tr>
<tr class="even">
<td>Incremento</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico). <strong>Omit.</strong> 1.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-57">Ejemplos</h3>
<pre><code>10 FOR 1 = 10 TO 50 STEP 10
20 PRINT &quot;I = &quot;; I
30 NEXT I</code></pre>
<p>La ejecución del programa sigue la secuencia siguiente:</p>
<p><strong>Bucles múltiples</strong></p>
<p>Cabe la posibilidad de poner un bucle FOR-NEXT en el interior de otro bucle FOR-NEXT. En este caso, el bucle interior debe estar alojado totalmente en el bucle exterior. En cada bucle se utiliza una variable distinta.</p>
<pre><code>10 FOR I = 1 TO 5
20 FOR J = 1 TO I
30 PRINT &quot;*&quot;;
40 NEXT J
50 PRINT
60 NEXT I
RUN
*
**
***
****
*****</code></pre>
<p>Cabe la posibilidad también de poner fin a varias instrucciones FOR con una única instrucción NEXT. En tal caso, no se puede omitir en la instrucción NEXT el nombre de la variable. Las variables están ordenadas secuencialmente (las del bucle interior en primer lugar) y separadas por comas.</p>
<pre><code>FOR I = 0 TO 10
FOR J = 0 TO 5
    .
    .
NEXT J, I</code></pre>
<h2 id="fre">FRE</h2>
<p>Ofrece el número de bytes de un área de memoria no utilizada pero que puede emplearse en VR-BASIC. Admite un parámetro y este puede ser una cadena de texto o bien un número.</p>
<p>Nótese que no importa el valor, sino el tipo.</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Valor de X</strong></th>
<th><strong>Función</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cualquier número</td>
<td>Devuelve el número de bytes disponibles para el VR‑BASIC. En el caso de un MSXVR, si el valor es -1, devolverá la cantidad de RAM disponible.</td>
</tr>
<tr class="even">
<td>Cualquier cadena de texto</td>
<td>Tamaño total de memoria disponible para almacenar cadenas de caracteres (<em>strings</em>).</td>
</tr>
</tbody>
</table>
<h3 id="versión-84">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-83">Formato</h3>
<pre><code>FRE(número)
FRE(cadena)</code></pre>
<h3 id="parámetros-71">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número</th>
<th>Expresión o valor de tipo numérico.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cadena</td>
<td>Expresión o valor de tipo cadena de texto.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-16">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-58">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>PRINT FRE (0)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Presenta en pantalla el número de bytes del área de memoria no utilizada.</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 91%" />
<col style="width: 1%" />
</colgroup>
<thead>
<tr class="header">
<th>PRINT FRE (" ")</th>
<th>Presenta en pantalla el número de bytes del área de cadena reservada que no se encuentra utilizada.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRINT FRE (-1)</td>
<td>En un MSXVR obtendría el tamaño libre total permitido. Por compatibilidad con los MSX-BASIC, el valor devuelto no supera los 32Kb, pero empleando esta forma en un VR-BASIC, el valor que obtendrá podrá ser mayor a los 32Kb.</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="get">GET</h2>
<p>Lee un registro en el fichero de acceso aleatorio y asigna valores a cada variable siguiendo el formato definido por la instrucción FIELD.</p>
<p>La instrucción</p>
<pre><code>GET #1, 3</code></pre>
<p>lee el tercer registro del fichero de datos y asigna valores a cada variable especificada por la instrucción FIELD.</p>
<h3 id="versión-85">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-84">Formato</h3>
<pre><code>GET [#] número de fichero [,número de registro]</code></pre>
<h3 id="parámetros-72">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤número de fichero≤número especificado por MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de registro</td>
<td><strong>Cond.</strong> Constantes (de tipo entero); 1≤número de registro≤65535. <strong>Omit.</strong> 1 + el número de registro utilizado en la instrucción GET o PUT ejecutada en último lugar.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-59">Ejemplos</h3>
<pre><code>10 OPEN &quot;A:TEST.DAT&quot; AS #1
20 FIELD #1, 2 AS A$, 15 AS B$, 10 AS C$
30 FOR I = 1 TO LOF(1)/255
40 GET #1, I
50 PRINT CVI(A$); &quot; &quot;; B$;&quot; &quot;; C$
60 NEXT I
70 CLOSE  #1
80 END</code></pre>
<h2 id="get-date">GET DATE</h2>
<p>Lee la fecha en el reloj interno y la asigna a una variable de cadena.</p>
<p>El formato de la fecha es DD/MM/AA, donde DD es el día, MM es el número del mes y AA es el año.</p>
<p>Cuando se especifica A se puede programar la alarma.</p>
<h3 id="versión-86">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-85">Formato</h3>
<pre><code>GET DATE T$ [,A]</code></pre>
<h3 id="parámetros-73">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>T$</th>
<th><strong>Cond.</strong> Constantes de cadena, variables, variables de matriz, sus expresiones.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td><strong>Omit.</strong> Fecha actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-60">Ejemplos</h3>
<pre><code>10 GET DATE T$
20 PRINT T$</code></pre>
<h2 id="get-time">GET TIME</h2>
<p>Lee la hora en el reloj interno y la asigna a una variable de cadena.</p>
<p>El formato de la hora es HH:MM:SS, donde HH es la hora, MM son los minutos y SS es el número de segundos.</p>
<p>Cuando se especifica A se puede programar la alarma.</p>
<h3 id="versión-87">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-86">Formato</h3>
<pre><code>GET TIME T$ [,A]</code></pre>
<h3 id="parámetros-74">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>T$</th>
<th><strong>Cond.</strong> Constantes de cadena, variables, variables de matriz, sus expresiones.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td><strong>Omit.</strong> Hora actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-61">Ejemplos</h3>
<pre><code>10 GET TIME X$
20 PRINT X$</code></pre>
<h2 id="gosub-return-1">GOSUB-RETURN</h2>
<p>Transfiere el control del programa a una subrutina especificada. La instrucción RETURN señala el fin de la subrutina y devuelve el control de ejecución al número de línea especificado a continuación de RETURN o, en su defecto, al número de línea siguiente a la instrucción GOSUB.</p>
<div class="line-block">  . | Rutina principal | Subrutina |<br />
  . | | |<br />
100 GOSUB 1000 | | |<br />
  . | | |<br />
  . | | |<br />
200 GOSUB 1000 | | |<br />
  . | | |<br />
  . | | |<br />
300 GOSUB 1000 | | |<br />
  . | | |<br />
  . | | |<br />
1000 SUBROUTINE | | |<br />
  . | | |<br />
  . | | |<br />
1100 RETURN | | |</div>
<p>|——————————————————————————–|——————|———–|</p>
<pre><code>100</code></pre>
<pre><code>200</code></pre>
<pre><code>300</code></pre>
<pre><code>1000</code></pre>
<pre><code>1100</code></pre>
<div class="line-block">  . | Rutina principal | Subrutina 1 |<br />
  . | | |<br />
100 GOSUB 1000 | | |<br />
  . | | |<br />
  . | | |<br />
200 GOSUB 2000 | | |<br />
  . | | |<br />
  . | | |<br />
1000 SUBROUTINE 1 | | |<br />
  . | | |<br />
  . | | |<br />
1100 RETURN | | |<br />
  . | | |<br />
  . | | |<br />
2000 SUBROUTINE 2 | | |<br />
  . | | |<br />
  . | | |<br />
2100 RETURN | | |</div>
<p>|————————————————————————————————–|——————|————-|</p>
<pre><code></code></pre>
<pre><code>100</code></pre>
<pre><code></code></pre>
<pre><code>200</code></pre>
<pre><code>1000</code></pre>
<pre><code>1100</code></pre>
<p>Subrutina 2</p>
<pre><code>2000</code></pre>
<pre><code></code></pre>
<pre><code>2100</code></pre>
<div class="line-block">  . | Rutina principal | Subrutina 1 | Subrutina 2 |<br />
  . | | | |<br />
100 GOSUB 1000 | | | |<br />
  . | | | |<br />
  . | | | |<br />
1000 SUBROUTINE 1 | | | |<br />
  . | | | |<br />
  . | | | |<br />
1050 GOSUB 2000 | | | |<br />
  . | | | |<br />
  . | | | |<br />
1100 RETURN | | | |<br />
  . | | | |<br />
  . | | | |<br />
2000 SUBROUTINE 2 . | | | |<br />
  . | | | |<br />
2100 RETURN | | | |</div>
<p>|—————————————————————————————————|——————|————-|————-|</p>
<pre><code>100</code></pre>
<pre><code>1000
1050
1100</code></pre>
<pre><code>2000</code></pre>
<pre><code>2100</code></pre>
<p>El uso de instrucciones GOSUB consume memoria, ya que cada llamada ha de guardar la línea de retorno, por tanto, existirá un límite de llamadas en función de la memoria disponible.</p>
<h3 id="versión-88">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-87">Formato</h3>
<pre><code>GOSUB número de línea</code></pre>
<pre><code>    .</code></pre>
<pre><code>    .</code></pre>
<pre><code>    .</code></pre>
<pre><code>RETURN [número de línea]</code></pre>
<h3 id="parámetros-75">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Enteros, 0≤número≤65529. <strong>Omit.</strong> En ausencia de número de línea en la instrucción RETURN, se da por entendido que es el número de línea siguiente a la instrucción GOSUB.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="goto-1">GOTO</h2>
<p>Transfiere la ejecución del programa a un número de línea especificado.</p>
<p>La ejecución del programa se transfiere a la línea especificada por la instrucción GOTO.</p>
<p>Al trabajar en el modo de mandatos directos, la ejecución empieza en la línea especificada.</p>
<h3 id="versión-89">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-88">Formato</h3>
<pre><code>GOTO número de línea</code></pre>
<h3 id="parámetros-76">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Enteros, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="hex">HEX$</h2>
<p>Ofrece, en formato alfanumérico, la expresión hexadecimal de un dato numérico.</p>
<h3 id="versión-90">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-89">Formato</h3>
<pre><code>HEX$(X)</code></pre>
<h3 id="parámetros-77">Parámetros</h3>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤X≤65535. En el caso de números negativos, su valor es el que resulta de sumarles 65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-17">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-62">Ejemplos</h3>
<pre><code>PRINT HEX$ (100)
 64</code></pre>
<pre><code>PRINT HEX$ (-32768)
 8000</code></pre>
<pre><code>PRINT HEX$ (255)
 FF</code></pre>
<h2 id="if--then-else">IF- THEN-ELSE</h2>
<p>Bifurca la ejecución del programa de acuerdo con el valor de una expresión.</p>
<p>Si el valor de una expresión es cierto (si se cumple esa expresión), se ejecuta la sentencia siguiente a THEN, y si es falso (si no se cumple esa expresión) se ejecuta la sentencia siguiente a ELSE; y a continuación se ejecuta la línea siguiente.</p>
<p>En caso de omisión de la instrucción ELSE, si el valor de la expresión es cierto se ejecuta la instrucción siguiente a THEN, y si el valor de la expresión es falso, se ignora la instrucción siguiente a THEN y la ejecución se transfiere a la línea siguiente.</p>
<p>En el formato IF-THEN GOTO, cabe la posibilidad de omitir THEN o GOTO.</p>
<pre><code>IF A = 0 THEN 30</code></pre>
<pre><code>IF A = 0 GOTO 30</code></pre>
<p>Ambas expresiones tienen igual significado.</p>
<p>Tras THEN va una instrucción o número de línea.</p>
<p>Tras GOTO va un número de línea.</p>
<p>Cuando GOTO va detrás de ELSE, se puede omitir.</p>
<p>Cuando después de THEN o ELSE van varias instrucciones, son ejecutadas secuencialmente comenzando por la izquierda; estas instrucciones están separadas por el signo de (:).</p>
<p><strong>Sentencias IF-THEN anidadas</strong></p>
<p>Tras THEN o ELSE puede ir otra sentencia IF-THEN. Se pueden poner múltiples instrucciones IF-THEN dentro de los límites de una línea.</p>
<h3 id="versión-91">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-90">Formato</h3>
<pre><code>IF expresión THEN instrucción [ELSE instrucción]
IF expresión THEN número de línea
IF expresión GOTO número de línea</code></pre>
<h3 id="parámetros-78">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Una expresión de relación cuyo resultado es una expresión numérica, una expresión lógica o una expresión aritmética.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ELSE sentencia</td>
<td><strong>Omit.</strong> Salta a la sentencia siguiente a THEN si el valor es cierto (se cumple) y a la línea siguiente si es falso (si no se cumple).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-63">Ejemplos</h3>
<pre><code>10 INPUT A
20 IF A&gt;=0 THEN PRINT &quot;ABS=&quot;; A ELSE PRINT &quot;ABS&quot;; -A
30 GOTO 10</code></pre>
<h2 id="inkey">INKEY$</h2>
<p>Ofrece el carácter correspondiente a la tecla pulsada y una cadena nula en caso de no haber pulsado ninguna tecla.</p>
<p>En caso de pulsación de teclas distintas a CRTL+STOP, SHIFT y CTRL, devuelve el carácter correspondiente a la tecla pulsada. Si no se ha pulsado ninguna tecla da una cadena nula.</p>
<h3 id="versión-92">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-91">Formato</h3>
<pre><code>INKEY$</code></pre>
<h3 id="retorno-18">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-64">Ejemplos</h3>
<pre><code>10 CLS
20 PRINT &quot;Pulse una tecla&quot;
30 K$ = INKEY$
40 IF K$ = &quot; &quot; THEN GOTO 30
50 PRINT K$
60 GOTO 30</code></pre>
<p>Cuando se pulsa una tecla, la línea 30 asigna el carácter correspondiente a la variable K$ y la línea 50 lo presenta en pantalla.</p>
<h2 id="inp">INP</h2>
<p>Lee datos del puerto de entrada/salida especificado.</p>
<h3 id="versión-93">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-92">Formato</h3>
<pre><code>INP (número de puerto)</code></pre>
<h3 id="parámetros-79">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de puerto</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤número&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-19">Retorno</h3>
<p>Tipo numérico.</p>
<h2 id="input">INPUT</h2>
<p>Acepta datos introducidos desde el teclado y los asigna a una variable. Los espacios en blanco introducidos antes de los datos son ignorados.</p>
<p>La instrucción INPUT correspondiente a una variable de tipo numérico ignora también los espacios dispuestos en el centro de los datos.</p>
<p>Cuando se introduce una coma, la instrucción INPUT la considera un signo de separación de datos; considera que los conceptos anteriores a la coma son un conjunto de datos asignados a una variable, y no asigna la coma.</p>
<p>Cuando se escribe un mensaje de entrada, lo presenta visualmente cuando hace la petición de entrada de datos. Si se omite el mensaje de petición de entrada, presenta únicamente el signo “?”.</p>
<p>El número de variables debe coincidir con los datos.</p>
<h3 id="versión-94">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-93">Formato</h3>
<pre><code>INPUT [&quot;mensaje&quot;;] variable [,variable] [,variable]....</code></pre>
<h3 id="parámetros-80">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Numérica, de cadena, sus variables de matriz.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mensaje</td>
<td><strong>Cond.</strong> Sentencia de comentario para la introducción de datos (cadena). <strong>Omit.</strong> Presenta visualmente solo “?” en ausencia del mensaje de petición de entrada.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-65">Ejemplos</h3>
<div class="line-block">10 INPUT A | Cuando se omite el mensaje de petición de entrada. |<br />
RUN | |<br />
? | |</div>
<p>|—————————————————————-|——————————————————————————————————————| | 10 INPUT “A =”; A | Cuando se incluye un mensaje de petición de entrada. | | RUN | | | A = ? | | | | Como el número de datos introducidos es inferior al número de variables, pide los datos que faltan con ??. | | 10 INPUT “A AND B”; A, B | Presenta ese mensaje (Extra ignored) cuando el número de datos introducidos es mayor que el número de variables. | | RUN | | | A AND B ? 1, 2, 3, 4 | | | ? Extra ignored | |</p>
<pre><code>10 INPUT &quot;A AND B&quot;; A, B
RUN
A AND B ? 7
??</code></pre>
<pre><code></code></pre>
<h2 id="input-1">INPUT$</h2>
<ol type="1">
<li><p>Acepta un número especificado de caracteres desde el teclado.</p></li>
<li><p>Acepta un número especificado de caracteres desde un fichero.</p></li>
</ol>
<p><strong>Límites de “N”</strong></p>
<p>En el estado inicial, si N sobrepasa los límites 1 a 200, se produce un error. Cuando se dispone que el área de caracteres sea de tamaño superior a 255, mediante una instrucción CLEAR, se puede seleccionar un valor comprendido entre 1 y 256.</p>
<h3 id="versión-95">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-94">Formato</h3>
<pre><code>INPUT$(N)
INPUT$(N, [#] número de fichero)</code></pre>
<h3 id="parámetros-81">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤N&lt;256.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de fichero</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤número de fichero≤ número especificado por la instrucción MAXFILES.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-20">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-66">Ejemplos</h3>
<pre><code>10 X$ = INPUT$(5)
20 PRINT X$</code></pre>
<p>La ejecución de la línea 10 acarrea el estado de espera de entrada de datos por el teclado, y tras la introducción de 5 caracteres, los asigna a la variable X$. Durante la introducción de caracteres por el teclado, no los presenta en pantalla.</p>
<pre><code>10 OPEN &quot;CAS: TEST&quot; FOR INPUT AS #1
20 X$ = INPUT$(50, #1)
30 CLOSE</code></pre>
<p>Este programa introduce 50 caracteres desde un fichero almacenado en una cinta casete y los asigna a una variable de cadena X$; luego cierra el fichero.</p>
<h2 id="input-2">INPUT#</h2>
<p>Lee datos de un fichero abierto por una instrucción OPEN y los asigna a una variable.</p>
<p>Lee los datos de un fichero. Si es numérico, ignora los códigos de espacio, de retorno y de salto de línea que preceden al dato.</p>
<p>Si el dato es una cadena, considera como un solo dato los caracteres comprendidos entre el primer carácter y el carácter anterior a un código de espacio, coma, retorno y salto de línea. Si los caracteres están encerrados entre dobles comillas (" "), solo lee y considera como datos estos caracteres.</p>
<h3 id="versión-96">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-95">Formato</h3>
<pre><code>INPUT # número de fichero, variable [,variable] ....</code></pre>
<h3 id="parámetros-82">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero); 1 ≤ número de fichero ≤ número especificado por la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variable</td>
<td><strong>Cond.</strong> Numérica o de cadena, o sus varaibles de matriz.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-67">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>10 OPEN “CAS:DATA” FOR INPUT AS #1</th>
<th>Abre un fichero para su lectura</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>20 IF EOF (1) THEN GOTO 50</td>
<td></td>
</tr>
<tr class="even">
<td>30 INPUT #1, A$: PRINT A$</td>
<td>Lee datos, asigna a la variable A$ y los presenta en pantalla</td>
</tr>
<tr class="odd">
<td>40 GOTO 20</td>
<td></td>
</tr>
<tr class="even">
<td>50 CLOSE #1</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="instr">INSTR</h2>
<p>Localiza una cadena de caracteres especificada entre otras cadenas y da su posición.</p>
<p>Ofrece en forma de datos numéricos el número de carácter de la cadena X$ (contando a partir de la izquierda) que coincide con el de la cadena Y$. Cuando se especifica N, empieza a contar desde el carácter enésimo de X$.</p>
<p>Cuando el valor de N es superior a la longitud de X$, o X$ es una cadena nula, o no encuentra Y$, devuelve el valor 0.</p>
<h3 id="versión-97">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-96">Formato</h3>
<pre><code>INSTR ([N,] X$, Y$)</code></pre>
<h3 id="parámetros-83">Parámetros</h3>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0 ≤ N &lt; 256. <strong>Omit.</strong> 1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X$, Y$</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo cadena).</td>
</tr>
</tbody>
</table>
<h3 id="retorno-21">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-68">Ejemplos</h3>
<pre><code>PRINT INSTR(3, (&quot;BASIC MSX2&quot;, &quot;SIC&quot;)
 3</code></pre>
<h2 id="int">INT</h2>
<p>Ofrece el valor entero máximo menor que el dato numérico dado.</p>
<h3 id="versión-98">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-97">Formato</h3>
<pre><code>INT(X)</code></pre>
<h3 id="parámetros-84">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-22">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-69">Ejemplos</h3>
<pre><code>PRINT INT (3); INT (-3); INT (3.58); INT (-3.58)
 3  -3 3 -4</code></pre>
<h2 id="interval-on-interval-off-interval-stop">INTERVAL ON/ INTERVAL OFF/ INTERVAL STOP</h2>
<p>Habilita, inhabilita o retiene una interrupción mediante el temporizador interno.</p>
<p>Se trata de una orden que habilita (INTERVAL ON), inhabilita (INTERVAL OFF) o retiene (INTERVAL STOP) las llamadas tras la declaración de una interrupción con el temporizador interno, utilizando ON INTERVAL GOSUB.</p>
<h3 id="versión-99">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-98">Formato</h3>
<p>INTERVAL ON Interrupción habilitada</p>
<p>INTERVAL OFF Interrupcción inhabilitada</p>
<p>INTERVAL STOP Interrupción retenida</p>
<h3 id="ejemplos-70">Ejemplos</h3>
<pre><code>10 ON INTERVAL=300 GOSUB 60
20 INTERVAL ON
30 FOR I=1 TO 10000:NEXT I
40 INTERVAL OFF
50 END
60 K=K+6:PRINT K;&quot;segundos&quot;
70 RETURN

RUN
 6 segundos
 12 segundos
 18 segundos
 24 segundos</code></pre>
<p>La interrupción se genera 50 veces por segundo (50 ticks). En la línea 10 indicamos que queremos llamar a nuestra rutina cada 300 ticks, o sea, cada 6 segundos. Lo que finalmente hará esta rutina es contabilizar los segundos que le cuesta procesar la línea 30, o sea, el bucle FOR.</p>
<h2 id="key">KEY</h2>
<p>Asigna una cadena de caracteres a una tecla de función.</p>
<p>Cuando está definida una cadena de caracteres para una tecla de función, con solo pulsar esa tecla queda introducida la cadena de caracteres.</p>
<p>Los números 1 al 5 corresponden a las teclas F1-F5, mientras que los números 6 al 10 corresponden a la pulsación de cada una de las teclas de función manteniendo pulsada al mismo tiempo la tecla SHIFT.</p>
<p>Las definiciones de las teclas de función quedan borradas e inicializadas al pulsar el botón RESET o al desconectar la alimentación.</p>
<p>Mediante la función CHR$ se puede definir un código distinto al correspondiente a un carácter (por ejemplo, el código ENTER).</p>
<h3 id="versión-100">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-99">Formato</h3>
<pre><code>KEY número de tecla de función, cadena de caracteres</code></pre>
<h3 id="parámetros-85">Parámetros</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de tecla de función</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cadena de caracteres</td>
<td><strong>Cond.</strong> Cadena de 15 caracteres o menos.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-71">Ejemplos</h3>
<p>KEY 1, “JAPAN” <em>Define “JAPAN” para F1</em></p>
<p>KEY 2, “CLS”+CHR$(13) <em>Define CLS+ENTER para F2</em></p>
<h2 id="key-list">KEY LIST</h2>
<p>Visualiza el contenido de las teclas de función.</p>
<p>La ejecución de esta orden produce la presentación en pantalla de la cadena de caracteres definida para cada una de las teclas de función.</p>
<h3 id="versión-101">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-100">Formato</h3>
<pre><code>KEY LIST</code></pre>
<h3 id="ejemplos-72">Ejemplos</h3>
<p>KEY LIST</p>
<p>color <em>F1</em></p>
<p>auto <em>F2</em></p>
<p>goto <em>F3</em></p>
<p>list <em>F4</em></p>
<p>run <em>F5</em></p>
<p>color 15,4,4 <em>SHIFT+F1</em></p>
<p>cload" <em>SHIFT+F2</em></p>
<p>cont <em>SHIFT+F3</em></p>
<p>list <em>SHIFT+F4</em></p>
<p>run <em>SHIFT+F5</em></p>
<p>Este es el listado del estado inicial por defecto. En esa lista podemos ver que la tecla de función 6 tiene definida la cadena “color 15, 4, 4” (la tecla de función 6 corresponde a la pulsación simultánea de la tecla F1 y la tecla SHIFT).</p>
<h2 id="key-on-key-off">KEY ON/ KEY OFF</h2>
<p>Visualiza o deja de mostrar en pantalla las cadenas asignadas a las teclas de función.</p>
<p>Inicialmente, se visualizan en la última línea de la pantalla las cadenas de caracteres definidas para cada una de las teclas de función. Para borrarlo, ejecutar KEY OFF.</p>
<p>Se pueden visualizar caracteres en esa última línea de la pantalla mediante una instrucción PRINT, tras ejecutar KEY OFF para borrar esa línea.</p>
<p>Para visualizar de nuevo el contenido de las teclas de función, procederemos a ejecutar KEY ON.</p>
<h3 id="versión-102">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-101">Formato</h3>
<pre><code>KEY ON</code></pre>
<pre><code>KEY OFF</code></pre>
<h2 id="key-n-onkey-n-off-key-n-stop">KEY (n) ON/KEY (n) OFF/ KEY (n) STOP</h2>
<p>Habilita, inhabilita o detiene las llamadas a rutinas tras la pulsación de las teclas de función. Estos comandos se combinan con el uso de ON KEY GOSUB.</p>
<h3 id="versión-103">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-102">Formato</h3>
<pre><code>KEY (número de tecla de función) ON
KEY (número de tecla de función) OFF
KEY (número de tecla de función) STOP</code></pre>
<h3 id="parámetros-86">Parámetros</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de tecla de función</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤número&lt;11.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-73">Ejemplos</h3>
<p>KEY (1) ON <em>Habilita la llamada si pulsamos la tecla F1.</em></p>
<p>KEY (2) OFF <em>Inhabilita la llamada para la tecla F2.</em></p>
<p>KEY (3) STOP <em>Detiene la llamada para la tecla F3.</em></p>
<h2 id="kill">KILL</h2>
<p>Borra un fichero del disco especificado.</p>
<p>El signo de interrogación (?) puede sustituir a uno o más caracteres del nombre del fichero o de la extensión. El asterisco (*) puede sustituir a todo el nombre del fichero o de la extensión.</p>
<h3 id="versión-104">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-103">Formato</h3>
<pre><code>KILL &quot;[nombre de la unidad][nombre de fichero[.extensión]]&quot;</code></pre>
<h3 id="parámetros-87">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre de fichero</td>
<td><strong>Cond.</strong> Una cadena de 8 caracteres o menos.</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 caracteres o menos.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-74">Ejemplos</h3>
<pre><code>KILL &quot;A:TEST.DAT&quot;</code></pre>
<p>Esta instrucción KILL buscará en el disco de la unidad A el fichero de nombre TEST.DAT y, si lo encuentra, lo borrará.</p>
<pre><code>KILL &quot;A:TEST??.DAT&quot;</code></pre>
<p>Esta instrucción borrará todos los ficheros cuyo nombre empieza por las letras TEST seguidas por dos caracteres cualesquiera (incluyendo el carácter nulo) y cuya extensión es DAT.</p>
<pre><code>KILL &quot;A:TEST.*&quot;</code></pre>
<p>Borra del disco todos los ficheros con el nombre de fichero TEST, sea cual sea su extensión.</p>
<pre><code>KILL &quot;A:*.*&quot;</code></pre>
<p>Borra todos los ficheros del disco de la unidad A.</p>
<p>En todos los casos, si se omite la unidad de discos, la instrucción actúa sobre la unidad actualmente en activo.</p>
<h2 id="left">LEFT$</h2>
<p>Devuelve una cadena de caracteres compuesta por un número especificado de caracteres extraídos de otra cadena, empezando por la izquierda.</p>
<h3 id="versión-105">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-104">Formato</h3>
<pre><code>LEFT$ (X$, N)</code></pre>
<h3 id="parámetros-88">Parámetros</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>N</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico). 0≤N&lt;256.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-23">Retorno</h3>
<p>Tipo alfanumérico.</p>
<h3 id="ejemplos-75">Ejemplos</h3>
<pre><code>PRINT LEFT$ (&quot;MSX-BASIC&quot;, 3)
MSX
OK</code></pre>
<div class="line-block">PRINT LEFT$ (“MSX-BASIC”, 3.8) | <em>Si N no es un número entero, ignora los números que siguen a la coma decimal.</em> |<br />
MSX | |<br />
OK | |</div>
<p>|————————————–|———————————————————————————| | PRINT LEFT$ (“MSX-BASIC”, 0) | Si N es 0, da una cadena nula. | | OK | |</p>
<pre><code></code></pre>
<h2 id="len">LEN</h2>
<p>Ofrece, en forma de datos numéricos, el número de caracteres (longitud) de una cadena de caracteres.</p>
<p>Cuando una cadena de caracteres incluye la función CHR$, esta se cuenta como un carácter.</p>
<h3 id="versión-106">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-105">Formato</h3>
<pre><code>LEN(X$)</code></pre>
<h3 id="parámetros-89">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (del tipo cadena).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-24">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-76">Ejemplos</h3>
<div class="line-block">PRINT LEN (“BASIC”) | |<br />
5 | |</div>
<p>|—————————–|————————————————————————————–| | PRINT LEN (“BASIC MSX2”) | Cuando una cadena de caracteres incluye un espacio, este se cuenta como un carácter. | | 10 | |</p>
<h2 id="let">LET</h2>
<p>Asigna datos a una variable.</p>
<p>Asigna el valor del término de la derecha al término de la izquierda.</p>
<p>Las constantes de cadena van encerradas entre dobles comillas (" ").</p>
<p>Se puede omitir LET.</p>
<p>Cuando se asigne un determinado tipo de dato numérico a una variable numérica de otro tipo distinto, convierte el dato numérico del primer tipo en el dato numérico correspondiente al tipo de la variable.</p>
<h3 id="versión-107">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-106">Formato</h3>
<pre><code>[LET] variable = X</code></pre>
<h3 id="parámetros-90">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Variables y variables de matriz de tipo numérico y de tipo de cadena.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>X</td>
<td><strong>Cond.</strong> Variables, variables de matriz, sus expresiones, de tipo numérico y tipo cadena.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-77">Ejemplos</h3>
<pre><code>LET N = N+1     Aumenta el valor de N una unidad</code></pre>
<pre><code>A% = 45.6: PRINT A%
45</code></pre>
<div class="line-block">A$ = 3+4 | Como se asigna un dato numérico a una variable de cadena surge un error y se visualiza en pantalla el mensaje de error: “Type mismatch” |<br />
Type mismatch | |</div>
<p>|————————|—————————————————————————————————————————————–|</p>
<h2 id="line">LINE</h2>
<p>En el modo gráfico, dibuja una línea recta o un rectángulo.</p>
<p>Cuando se omiten “B” y “BF”, dibuja una línea recta entre las coordenadas del punto inicial y las coordenadas del punto final.</p>
<p>Cuando se especifica “B”, dibuja un rectángulo cuya diagonal es una línea recta entre los dos puntos especificados.</p>
<p>Cuando se especifica “BF”, dibuja un rectángulo cuya diagonal es una línea recta entre los dos puntos especificados, y colorea el rectángulo.</p>
<p>Cuando se especifica “STEP”, pasa X, Y a un nuevo sistema de coordenadas cuyo origen está en el último punto especificado en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-108">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-107">Formato</h3>
<pre><code>LINE [[STEP](coordenadas del punto inicial)]-[STEP](coordenadas del punto final),[color] { [,B][,BF] } [,operación lógica]</code></pre>
<h3 id="parámetros-91">Parámetros</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenadas del punto inicial (X, Y)</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤coordenadas&lt;32767. <strong>Omit.</strong> La última posición especificada en la instrucción gráfica.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Coordenadas del punto final (X, Y)</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); -32768≤coordenadas&lt;32767.</td>
</tr>
<tr class="even">
<td>Color</td>
<td><strong>Cond.</strong> SCREEN 2 a 7: Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 0≤color&lt;16. SCREEN 8: Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 0≤color&lt;256. <strong>Omit.</strong> Color actual del primer plano.</td>
</tr>
<tr class="odd">
<td>B, BF</td>
<td><strong>Omit.</strong> Dibuja una línea recta.</td>
</tr>
<tr class="even">
<td>Operación lógica</td>
<td><strong>Cond.</strong> SCREEN 5 a 13: PSET, PRESET, XOR, OR, AND.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-78">Ejemplos</h3>
<pre><code>10 CLS
20 SCREEN 5
30 LINE (60, 60)-(100,100), 1, B, AND
40 LINE STEP (-10, -10)-(120, 160), 8, BF
50 GOTO 50</code></pre>
<h2 id="line-input">LINE INPUT</h2>
<p>Da entrada desde el teclado a una cadena de hasta 254 caracteres, en forma de variable de cadena.</p>
<p>Considera los códigos ASCII 13 (ENTER) como separación del dato, y asigna una cadena de caracteres introducida por el teclado a una variable. Cuando en una cadena de caracteres se incluye una coma, la asigna como un carácter más de la cadena.</p>
<h3 id="versión-109">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-108">Formato</h3>
<pre><code>LINE INPUT [&quot;sentencia de comentarios para la introducción de datos&quot;;]variable</code></pre>
<h3 id="parámetros-92">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Sentencia de comentario</th>
<th><strong>Cond.</strong> Constantes de cadena. <strong>Omit.</strong> Presenta en pantalla solo el signo de interrogación “?”, sin sentencia de petición de entrada.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variable</td>
<td><strong>Cond.</strong> Variables, variables de matriz, (de cadena).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-79">Ejemplos</h3>
<pre><code>10 CLS
20 LINE INPUT &quot;NOMBRE, TELEFONO?&quot;;N$
30 PRINT N$
RUN
NOMBRE, TELEFONO? PEDRO, 355338357
PEDRO, 355338357</code></pre>
<h2 id="line-input-1">LINE INPUT #</h2>
<p>Lee de un fichero una cadena de hasta 254 caracteres y la asigna a una variable de cadena.</p>
<p>Lee datos de cadena de un fichero, pero no considera los códigos de la coma, el espacio y el cambio de línea como signos de separación de los datos, lo cual la diferencia de la instrucción INPUT#: asigna las cadenas de caracteres que incluyen tales elementos a una variable, en forma de datos alfanuméricos. Solo considera signo de separación de los datos al código ASCII 13 (ENTER).</p>
<h3 id="versión-110">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-109">Formato</h3>
<pre><code>LINE INPUT # número de fichero, variable</code></pre>
<h3 id="parámetros-93">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variables</td>
<td><strong>Cond.</strong> Variables y variables de matriz alfanuméricas.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-80">Ejemplos</h3>
<p>Imaginemos que se prepara con una serie de datos un fichero de nombre DATA mediante el procedimiento siguiente:</p>
<pre><code>PRINT #1, &quot;ABC&quot; ; &quot; , &quot; ; &quot;DEF&quot;
PRINT #1, &quot;GHI JKL&quot; ;
PRINT #1, &quot;MNO&quot;
PRINT #1, &quot;PQR&quot;</code></pre>
<p>A continuación, tenemos el siguiente programa:</p>
<pre><code>10 OPEN &quot;CAS: DATA&quot; FOR INPUT AS #1
20 IF EOF(1) THEN GOTO 60
30 LINE INPUT #1, A$
40 PRINT A$
50 GOTO 20
60 CLOSE #1:END</code></pre>
<p>Cuando el programa lea los datos y los visualice en pantalla, observará que estos fueron leídos como datos de 3 caracteres, de la forma siguiente:</p>
<pre><code>ABC, DEF
GHI, JKLMNO
PQR</code></pre>
<h2 id="list">LIST</h2>
<p>Visualiza por pantalla el listado del programa almacenado en memoria.</p>
<p>Se debe pulsar STOP para detener temporalmente la visualización del listado en la pantalla, y volver a pulsar STOP para reanudarla. Para suspenderla, pulsar CTRL+STOP.</p>
<h3 id="versión-111">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-110">Formato</h3>
<pre><code>LIST
LIST número de línea inicial
LIST número de línea inicial - [número de línea final]
LIST [número de línea inicial] - número de línea final
LIST .</code></pre>
<h3 id="parámetros-94">Parámetros</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea inicial</th>
<th><strong>Cond</strong>. Constantes enteras, 0≤número&lt;65529. <strong>Omit.</strong> Número de línea más bajo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de línea final</td>
<td><strong>Cond</strong>. Constantes enteras, 0≤número&lt;65529. <strong>Omit.</strong> Número de línea más alto.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-81">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>LIST</th>
<th>Visualiza todas las líneas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LIST 40</td>
<td>Visualiza la línea 40</td>
</tr>
<tr class="even">
<td>LIST 20-40</td>
<td>Visualiza las líneas 20 a 40</td>
</tr>
<tr class="odd">
<td>LIST -50</td>
<td>Visualiza todas las líneas desde la primera hasta la 50</td>
</tr>
<tr class="even">
<td>LIST 30-</td>
<td>Visualiza todas las líneas desde la 30 hasta la última</td>
</tr>
<tr class="odd">
<td>LIST.</td>
<td>Visualiza la última línea presentada por una instrucción LIST o una línea cuya ejecución haya sido interrumpida por un error</td>
</tr>
</tbody>
</table>
<h2 id="llist">LLIST</h2>
<p>Imprime con una impresora el listado del programa almacenado en memoria.</p>
<p>Las especificaciones son idénticas a las de la instrucción LIST. La instrucción LLIST no presenta el listado del programa en pantalla.</p>
<p>Si se ejecuta una instrucción LLIST cuando la impresora no está conectada o cuando, estándolo, no funciona, el ordenador se para y no acepta entradas por teclado. En tal caso, pulse al mismo tiempo las teclas CTRL+STOP para volver al estado de entrada de comandos.</p>
<h3 id="versión-112">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-111">Formato</h3>
<pre><code>LLIST
LLIST número de línea inicial
LLIST número de línea inicial - [número de línea final]
LLIST [número de línea inicial] - número de línea final</code></pre>
<h3 id="parámetros-95">Parámetros</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea inicial</th>
<th><strong>Cond</strong>. Constantes enteras, 0≤número&lt;65529. <strong>Omit.</strong> Número de línea más bajo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de línea final</td>
<td><strong>Cond</strong>. Constantes enteras, 0≤número&lt;65529. <strong>Omit.</strong> Número de línea más alto.</td>
</tr>
</tbody>
</table>
<h2 id="load">LOAD</h2>
<p>Carga en memoria un programa VR-BASIC procedente del dispositivo especificado.</p>
<p>Cuando se especifica CAS: en el nombre del dispositivo, carga los programas que se hayan almacenado en la cinta de casete en formato ASCII mediante la instrucción SAVE “CAS: nombre de fichero”.</p>
<p>Cuando se especifica la opción R, ejecuta el programa tras su carga.</p>
<h3 id="versión-113">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-112">Formato</h3>
<pre><code>LOAD &quot;[nombre del dispositivo] [nombre de fichero[.extensión]]&quot;[,R]</code></pre>
<h3 id="parámetros-96">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de dispositivo</th>
<th><strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H:, <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 o menos caracteres. Una cadena de 8 o menos caracteres. <strong>Omit.</strong> Carga el primer fichero que encuentra (no se puede omitir el nombre de fichero cuando se trabaja con un disco flexible o con la RAM-Disk).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond</strong>. Una cadena de 3 o menos caracteres. <strong>Omit.</strong> Cadena nula.</td>
</tr>
<tr class="odd">
<td>Opción R</td>
<td><strong>Omit.</strong> Solo carga.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-82">Ejemplos</h3>
<pre><code>LOAD &quot;CAS: PROG2&quot;</code></pre>
<pre><code>LOAD &quot;A:PROG.ASC&quot;</code></pre>
<h2 id="loc">LOC</h2>
<p>Devuelve la posición del registro actual en el fichero.</p>
<p>Cuando se aplica esta función a un fichero secuencial, ofrece el número de registros leídos o escritos. En fichero secuenciales, la longitud de un registro es 256 bytes.</p>
<p>Cuando se aplica esta función a un fichero de acceso aleatorio, ofrece el número del último registro leído o escrito. En ficheros de acceso aleatorio, la longitud de un registro es configurable.</p>
<h3 id="versión-114">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-113">Formato</h3>
<pre><code>LOC (número de fichero)</code></pre>
<h3 id="parámetros-97">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-25">Retorno</h3>
<p>Tipo entero</p>
<h2 id="locate">LOCATE</h2>
<p>Desplaza el cursor a la posición especificada, en el modo texto.</p>
<p>El cursor se visualiza o no según el valor del parámetro “Interruptor del cursor” (0 = Cursor no presente; 1 = Cursor presente).</p>
<h3 id="versión-115">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-114">Formato</h3>
<pre><code>LOCATE [coordenada X][,coordenada Y][,interruptor del cursor]</code></pre>
<h3 id="parámetros-98">Parámetros</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenada X, Coordenada Y</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤coordenada&lt;256. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Interruptor del cursor</td>
<td><strong>Cond.</strong> 0 o 1. <strong>Omit.</strong> 1.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-83">Ejemplos</h3>
<pre><code>10 CLS
20 LOCATE 12, 10
30 PRINT &quot;*****&quot;</code></pre>
<h2 id="lof">LOF</h2>
<p>Ofrece, en bytes, el tamaño del fichero especificado.</p>
<h3 id="versión-116">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-115">Formato</h3>
<p>LOF (número de fichero)</p>
<h3 id="parámetros-99">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables matriciales, sus expresiones (de tipo numérico); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-26">Retorno</h3>
<p>Entero.</p>
<h2 id="log">LOG</h2>
<p>La función LOG devuelve el valor de un logaritmo natural; su base es el número e (2.7182818284588).</p>
<p>Mediante LOG (b)/LOG (a) se puede obtener el valor del logaritmo de b en base a (Logab). Si b&gt;0 y a≠1.</p>
<h3 id="versión-117">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-116">Formato</h3>
<pre><code>LOG(X)</code></pre>
<h3 id="parámetros-100">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico, mayores que 0).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-27">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-84">Ejemplos</h3>
<pre><code>PRINT LOG (10)
 2.302585092994</code></pre>
<h2 id="lpos">LPOS</h2>
<p>Ofrece la posición del cabezal de la impresora, procedente del buffer de la impresora.</p>
<p>Ofrece la posición en el buffer (memoria intermedia de la impresora) del carácter que esté escribiendo actualmente (principio = 0).</p>
<h3 id="versión-118">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-117">Formato</h3>
<pre><code>LPOS(X)</code></pre>
<h3 id="parámetros-101">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Un número cualquiera (argumento ficticio).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-28">Retorno</h3>
<p>Tipo entero.</p>
<h2 id="lprint">LPRINT</h2>
<p>Escribe por impresora el valor de una expresión.</p>
<p>La instrucción LPRINT envía datos a la impresora, mientras que la instrucción PRINT los envía a la pantalla. Para más detalles, véase PRINT.</p>
<h3 id="versión-119">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-118">Formato</h3>
<pre><code>LPRINT [expresión][separador][expresión][separador][expresión]....</code></pre>
<h3 id="parámetros-102">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas y de cadena). <strong>Omit.</strong> Avance de línea.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Separador</td>
<td><strong>Cond.</strong> “,” o “;”</td>
</tr>
</tbody>
</table>
<h2 id="lprint-using">LPRINT USING</h2>
<p>Escribe datos por impresora con un formato especificado.</p>
<p>La instrucción LPRINT USING envía datos a una impresora con un formato especificado mientras que la instrucción PRINT USING envía datos a la pantalla también con un formato especificado. Para más detalles, por ejemplo los símbolos de los formatos, véase PRINT USING.</p>
<h3 id="versión-120">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-119">Formato</h3>
<pre><code>LPRINT USING símbolo del formato;expresión[,expresión]</code></pre>
<h3 id="parámetros-103">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (de tipo numérico y de cadena).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="lset">LSET</h2>
<p>Escribe los datos en un registro de un fichero de acceso aleatorio con justificación a la izquierda.</p>
<p>Dispone los datos de cada variable en el registro especificado por la instrucción FIELD como preparación para la escritura de los datos en un fichero de acceso aleatorio con una instrucción PUT. La instrucción LSET alinea los datos desde el lado izquierdo del registro; si el dato es más corto que la variable especificada por la instrucción FIELD, los espacios vacíos se llenan con espacios en blanco, y si el dato es más largo que la longitud especificada por la instrucción FIELD, se ignora la porción derecha sobrante de la cadena.</p>
<p>En el proceso de organización del dato numérico, se convierte en primer lugar el dato numérico en dato de cadena mediante las funciones MKI$, MKS$ y MKD$.</p>
<h3 id="versión-121">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-120">Formato</h3>
<pre><code>LSET variable de cadena = expresión de cadena</code></pre>
<h3 id="parámetros-104">Parámetros</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable de cadena</th>
<th><strong>Cond.</strong> Variable de cadena.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión de cadena</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-85">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>LSET A$ = X$</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Coloca el dato de cadena X$ de la variable A$ en el registro</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 78%" />
<col style="width: 2%" />
</colgroup>
<thead>
<tr class="header">
<th>LSET B$ = MKS$ (N)</th>
<th>Convierte el dato numérico N en dato de cadena y lo coloca en la variable B$ del registro</th>
<th></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<h2 id="maxfiles">MAXFILES</h2>
<p>Declara el número de ficheros que pueden estar abiertos simultáneamente en un programa; se dice que dos ficheros están abiertos simultáneamente si se abre el segundo sin haber cerrado el primero.</p>
<h3 id="versión-122">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-121">Formato</h3>
<pre><code>MAXFILES = expresión</code></pre>
<h3 id="parámetros-105">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo numérico); 0≤expresión&lt;16.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-86">Ejemplos</h3>
<pre><code>10 MAXFILES = 3
20 OPEN &quot;GRP:&quot; FOR OUTPUT AS #1
30 OPEN &quot;CRT:&quot; FOR OUTPUT AS #2
40 OPEN &quot;LPT:&quot; FOR OUTPUT AS #3
    .
    .
    .
1000 CLOSE</code></pre>
<p>Dado que la línea 10 establece que 3 es el máximo número de ficheros que pueden abrirse simultáneamente, en la línea 20 y siguientes se pueden abrir 3 ficheros.</p>
<p>En ausencia de una instrucción MAXFILES que especifique el número de ficheros que pueden abrirse simultáneamente, solo puede estar abierto un fichero a la vez.</p>
<p>La declaración de un número innecesariamente alto de ficheros en la instrucción MAXFILES reduce el área de memoria a disposición del usuario.</p>
<h2 id="merge">MERGE</h2>
<p>Carga un programa almacenado en formato ASCII y lo fusiona con el programa almacenado en la memoria del ordenador.</p>
<p>Carga un programa almacenado por una instrucción SAVE en formato ASCII. El programa que hay en la memoria sigue ahí y la instrucción fusiona con él el programa cargado.</p>
<p>Si el programa cargado por la instrucción MERGE tiene números de línea que coinciden con otros del programa almacenado en memoria, prevalecen los números de línea cargados por la instrucción MERGE.</p>
<h3 id="versión-123">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-122">Formato</h3>
<pre><code>MERGE &quot;[nombre de dispositivo][nombre del fichero[.extensión]]&quot;</code></pre>
<h3 id="parámetros-106">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de dispositivo</th>
<th><strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H:, <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 o menos caracteres. Una cadena de 8 caracteres o menos. En MSXVR hasta 256 caracteres. <strong>Omit.</strong> Fusiona el primer fichero que encuentra. (No se puede omitir el nombre del fichero cuando se opera con disco flexible o con RAM-Disk).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 caracteres o menos. En MSXVR hasta 256 caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-87">Ejemplos</h3>
<pre><code>MERGE &quot;CAS: PROG3&quot;</code></pre>
<pre><code>MERGE &quot;A:PROG.ASC&quot;</code></pre>
<pre><code>MERGE &quot;MEM: PROG.ASC&quot;</code></pre>
<h2 id="mid">MID$</h2>
<p>Localiza y extrae una parte de los caracteres de una cadena de texto.</p>
<p>El primer parámetro X$ hace referencia a la cadena de texto sobre la que vamos a operar. El segundo parámetro M hace referencia al índice del primer carácter desde el que extraer parte de la cadena. De forma opcional, con el parámetro N, podemos indicar el número de caracteres que queremos extraer; en caso de no hacerlo, se indicará hasta el final de la cadena.</p>
<h3 id="versión-124">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-123">Formato</h3>
<pre><code>MID$ (X$, M, [,N])</code></pre>
<h3 id="parámetros-107">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>M</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤M&lt;256.</td>
</tr>
<tr class="even">
<td>N</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤N&lt;256. <strong>Omit.</strong> Ofrece todos los caracteres que siguen al carácter Mésimo.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-29">Retorno</h3>
<p>Cadena de caracteres.</p>
<h3 id="ejemplos-88">Ejemplos</h3>
<div class="line-block">PRINT MID$ (“JAPANUKFRANCE”, 6, 2) | |<br />
UK | |<br />
Ok | |</div>
<p>|——————————————-|——————————————————————————————————————————| | PRINT MID$ (“JAPANUKFRANCE”, 6, 2.6) | Si N no es un valor entero, ignora las cifras que siguen a la coma decimal | | UK | | | Ok | | | PRINT MID$ (“JAPANUK”, 6, 4) | Si tras el carácter Mésimo no hay un número N de caracteres, devuelve todos los caracteres que hay a continuación del Mésimo | | UK | | | Ok | | | PRINT MID$ (“JAPANUK”, 12, 5) | Cuando el valor de M es mayor que la longitud de X$ o cuando N es 0, devuelve una cadena nula. |</p>
<pre><code>PRINT MID$ (&quot;JAPANUK&quot;, 6, 0)
Ok</code></pre>
<h2 id="mid-y">MID$ = Y$</h2>
<p>Sustituye una parte de una cadena de caracteres por otra cadena.</p>
<p>Sustituye los caracteres Mésimo y siguientes de la cadena de caracteres X$, de izquierda a derecha, por los primeros N caracteres de Y$. En cualquier caso, esta instrucción no cambia la longitud de X$.</p>
<h3 id="versión-125">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-124">Formato</h3>
<p>MID$ (X$, M, [,N]) = Y$</p>
<h3 id="parámetros-108">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>X$, Y$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>M</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤M&lt;256.</td>
</tr>
<tr class="even">
<td>N</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤N&lt;256. <strong>Omit.</strong> Sustituye los caracteres Mésimo y siguientes de X$ por Y$.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-89">Ejemplos</h3>
<pre><code>10 X$ = &quot;ABCDEFG&quot;
20 Y$ = &quot;QRSTUVWXYZ&quot;
30 MID$ (X$, 4,2) = Y$
40 PRINT X$
RUN
ABCQRFG</code></pre>
<h2 id="mkimksmkd">MKI$/MKS$/MKD$</h2>
<p>Convierten un dato numérico en una cadena de caracteres en función de su formato interno.</p>
<p>Como en un fichero de acceso aleatorio únicamente se pueden escribir datos de cadena, hay que convertir primero los datos numéricos en datos de cadena haciendo uso de las funciones MKI$, MKS$ y MKD$. Estas conversiones se hacen cuando se asignan los datos a posiciones específicas del registro mediante las instrucciones LSET/RSET.</p>
<p>La cantidad de espacio del registro que ocupa un dato numérico depende de su tipo. Los datos de tipo entero ocupan 2 bytes, los datos de precisión simple ocupan 4 bytes, y los datos de coma flotante de precisión doble ocupan 8 bytes.</p>
<p>Cuando los datos numéricos son de tipo entero, como en</p>
<pre><code>LSET A$ = MKI$(X)   (justificación a la izquierda)</code></pre>
<p>se convierte el dato numérico entero en una cadena de caracteres (dos caracteres = dos bytes) mediante una función MKI$, y se asigna al registro. En consecuencia, es preciso haber dejado reservado, mediante una instrucción FIELD, un espacio de 2 bytes o más para alojar a la cadena A$ resultado de la conversión.</p>
<p>De una forma similar, la función MKS$ convierte los datos de precisión simple en cadenas de 4 caracteres (4 bytes), y la función MKD$ convierte los datos de precisión doble en cadenas de 8 caracteres (8 bytes).</p>
<p>A la hora de leer los datos del fichero, las cadenas de caracteres que antes eran datos numéricos son convertidas de nuevo en cadenas de caracteres mediante las funciones CVI, CVS y CVD.</p>
<h3 id="versión-126">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-125">Formato</h3>
<pre><code>MKI$ (X)
MKS$ (Y)
MKD$ (Z)</code></pre>
<h3 id="parámetros-109">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Y</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de precisión simple).</td>
</tr>
<tr class="even">
<td>Z</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de precisión doble).</td>
</tr>
</tbody>
</table>
<h3 id="retorno-30">Retorno</h3>
<table>
<thead>
<tr class="header">
<th>MKI$ (X)</th>
<th>Cadena de 2 caracteres (2 bytes)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MKS$ (Y)</td>
<td>Cadena de 4 caracteres (4 bytes)</td>
</tr>
<tr class="even">
<td>MKD$ (Z)</td>
<td>Cadena de 8 caracteres (8 bytes)</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-90">Ejemplos</h3>
<pre><code>10 D=29474
20 D$=MKI$(D)
30 PRINT D$
RUN
&quot;s</code></pre>
<pre><code></code></pre>
<h2 id="motor">MOTOR</h2>
<p>Pone en marcha y para el motor del grabador/reproductor de casetes.</p>
<p>Conecte el terminal TAPE (cinta) del ordenador al terminal de control remoto de un grabador/reproductor de casete y ponga el aparato en el modo reproducción o grabación. MOTOR ON pone la cinta en funcionamiento y MOTOR OFF la para.</p>
<p>Cuando solo se ejecuta MOTOR, si estaba ON lo pone a OFF y si estaba OFF lo pone a ON.</p>
<h3 id="versión-127">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-126">Formato</h3>
<pre><code>MOTOR { ON | OFF }</code></pre>
<h2 id="name">NAME</h2>
<p>Cambia el nombre de un fichero del disco.</p>
<p>Sirve para cambiar el nombre del fichero, pero no su contenido.</p>
<h3 id="versión-128">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-127">Formato</h3>
<pre><code>NAME &quot;[nombre de la unidad]nombre anterior de fichero[.extensión anterior]&quot; AS &quot;nuevo nombre del fichero[.nuevo nombre de la extensión]&quot;</code></pre>
<h3 id="parámetros-110">Parámetros</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de la unidad</th>
<th><strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H: <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre anterior de fichero, nombre nuevo de fichero</td>
<td><strong>Cond.</strong> Una cadena de 8 caracteres o menos.</td>
</tr>
<tr class="even">
<td>Nombre anterior de la extensión, nombre nuevo de la extensión</td>
<td><strong>Cond</strong>. Una cadena de 3 caracteres o menos. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-91">Ejemplos</h3>
<pre><code>NAME &quot;A:OLD.BAS&quot; AS &quot;NEW.BAS&quot;</code></pre>
<p>Esta orden cambia el nombre del fichero OLD.BAS del disco de la unidad A por NEW.BAS.</p>
<p>El nombre anterior de fichero [.nombre anterior de la extensión] debe existir en ese disco. El nuevo nombre de fichero [.nuevo nombre de la extensión] no debe coincidir con el nombre de un fichero existente en ese disco.</p>
<h2 id="new">NEW</h2>
<p>Borra un programa VR-BASIC de la memoria y anula todas las variables.</p>
<p>NEW se ejecuta antes de dar entrada en memoria a un nuevo programa, con objeto de borrar todos los programas existentes y pasar al estado de entrada de comandos.</p>
<p>Cuando hay en memoria un programa en lenguaje máquina, este se conserva aunque se ejecute NEW.</p>
<h3 id="versión-129">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-128">Formato</h3>
<pre><code>NEW</code></pre>
<h2 id="oct">OCT$</h2>
<p>Ofrece, en formato alfanumérico, la expresión octal de un dato numérico.</p>
<h3 id="versión-130">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-129">Formato</h3>
<pre><code>OCT$(X)</code></pre>
<h3 id="parámetros-111">Parámetros</h3>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32768≤X&lt;65536. Si se trata de un número negativo, su valor es el resultado de la suma de 65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-31">Retorno</h3>
<p>Una cadena de caracteres.</p>
<h3 id="ejemplos-92">Ejemplos</h3>
<pre><code>PRINT OCT$ (100)
 144</code></pre>
<pre><code>PRINT OCT$ (65536-32768)
 100000</code></pre>
<h2 id="on-error-goto">ON ERROR GOTO</h2>
<p>Transfiere la ejecución del programa al número de línea especificado cuando ocurre un error.</p>
<p>Sirve para evitar la interrupción de la ejecución del programa causada por un error durante la ejecución. Cuando surge un error después de la declaración de ON ERROR GOTO, la ejecución se transferirá al número de línea especificado (cuando el error sea resultado de una orden directa, el control de la ejecución del programa también se transferirá al número de línea especificado).</p>
<p>Para anular una instrucción ON ERROR GOTO, se debe ejecutar ON ERROR GOTO 0.</p>
<h3 id="versión-131">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-130">Formato</h3>
<pre><code>ON ERROR GOTO número de línea</code></pre>
<h3 id="parámetros-112">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-93">Ejemplos</h3>
<pre><code>10 ON ERROR GOTO 100
20 INPUT A
30 B = SQR(A)
40 PRINT &quot;SQR(A)=&quot;; B
50 END
100 IF ERR = 5 AND ERL = 30 THEN PRINT &quot;Introduce un valor positivo&quot;
110 RESUME 20</code></pre>
<p>En caso de ocurrir un error, se llamará a la rutina que comienza en el número de línea 100. En este punto, si el código de error es 5 (<em>Illegal Function Call</em>) y el número de línea donde se ha producido es la 30, mostraremos en pantalla el texto “Introduce un valor positivo” y a continuación volveremos a preguntar por el número.</p>
<h2 id="on-gosub">ON GOSUB</h2>
<p>Bifurca la ejecución de un programa a las subrutinas que comienzan por los números de línea especificados, dependiendo del valor de la expresión.</p>
<p><strong>Valor de la expresión y resultado de la ejecución</strong></p>
<p>Cuando el valor de la expresión no es un entero, ignora las cifras que siguen al punto decimal.</p>
<p>Cuando el valor de la expresión es un número, siempre que este sea mayor o igual a uno, saltará al número de línea con índice correspondiente este valor.</p>
<p>Cuando el valor de la expresión es 0 o mayor que el número de líneas especificadas por GOSUB, transfiere la ejecución a la instrucción siguiente a la ON GOSUB.</p>
<p>Cuando el valor de la expresión es negativo o mayor que 255, se produce un error.</p>
<h3 id="versión-132">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-131">Formato</h3>
<pre><code>ON expresión GOSUB número de línea[,número de línea]...</code></pre>
<h3 id="parámetros-113">Parámetros</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤expresión&lt;256.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de línea</td>
<td><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-94">Ejemplos</h3>
<pre><code>100 ON X GOSUB 500, 600, 700</code></pre>
<p>En este programa, si el valor de X es 1, la ejecución salta a la subrutina que empieza en la línea 500; si el valor de X es 2, la ejecución salta a la subrutina que empieza en la línea 600; y si es 3 salta a la subrutina que comienza en la línea 700.</p>
<p>La instrucción RETURN realiza el retorno del control de ejecución al programa principal.</p>
<h2 id="on-goto-1">ON GOTO</h2>
<p>Bifurca la ejecución del programa a números de línea que dependen del valor de una expresión.</p>
<p><strong>Valor de la expresión y resultado de la ejecución</strong></p>
<p>Cuando el valor de la expresión no es un entero, ignora las cifras que siguen al punto decimal.</p>
<p>Cuando el valor de la expresión es un número, siempre que este sea mayor o igual a uno, saltará al número de línea con índice correspondiente este valor.</p>
<p>Cuando el valor de la expresión es 0 o mayor que el número de líneas especificadas por GOTO, transfiere la ejecución a la instrucción siguiente a la ON GOTO.</p>
<p>Cuando el valor de la expresión es negativo o mayor que 255, se produce un error.</p>
<h3 id="versión-133">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-132">Formato</h3>
<pre><code>ON expresión GOTO número de línea[,número de línea]...</code></pre>
<h3 id="parámetros-114">Parámetros</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de línea</td>
<td><strong>Cond.</strong> Constantes enteras, 0≤número≤62259.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-95">Ejemplos</h3>
<pre><code>100 ON X GOTO 120, 130,180</code></pre>
<p>En este programa, si el valor de X es 1, la ejecución salta a la línea 120; si es 2 salta a la línea 130; y si es 3 a la línea 180.</p>
<h2 id="on-interval-gosub">ON INTERVAL GOSUB</h2>
<p>Declara la subrutina a la que salta la ejecución del programa en caso de interrupción debida al temporizador interno.</p>
<p>Se trata de una instrucción que define el número de línea al que debe saltar la ejecución del programa en caso de una interrupción, causada por el temporizador interno, con el intervalo de tiempo especificado. Cada intervalo de la interrupción es aproximadamente intervalo de tiempo x 1/50 segundo; en otras palabras, cuando se ha especificado un intervalo de 50, se produce una interrupción aproximadamente cada segundo.</p>
<p>Cuando el intervalo de tiempo especificado es un número negativo, el valor seleccionado es el resultado de sumar a ese número 65536.</p>
<h3 id="versión-134">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-133">Formato</h3>
<pre><code>ON INTERVAL=tiempo de intervalo GOSUB número de línea</code></pre>
<h3 id="parámetros-115">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Tiempo de intervalo</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32768≤tiempo≤65529, distinto a 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de línea</td>
<td><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-96">Ejemplos</h3>
<pre><code>10 ON INTERVAL = 50 GOSUB 100
20 INTERVAL ON
30 SCREEN 2, 1
40 SPRITE$ (1) = CHR$ (&amp;H18)+CHR$(&amp;H3C)+CHR$(&amp;H66)+CHR$(&amp;HDB)+CHR$(&amp;HE7)+CHR$(&amp;H7E)+CHR$(&amp;H24)+CHR$(&amp;H42)
50 GOTO 50
100 X = INT (RND(1)*256):Y = INT (RND(1)*192)
110 C = INT (RND(1)*14)+2
120 PUT SPRITE 1, (X,Y), C, 1
130 RETURN 50</code></pre>
<p>En este programa hay una interrupción cada segundo, consecuencia de las líneas 10 y 20, y cada vez que hay una interrupción, la ejecución salta a la subrutina que empieza en la línea 100. Después de que esta subrutina presente en pantalla la configuración de sprites en forma de OVNI, la línea 130 (RETURN 50) devuelve la ejecución a la línea 50.</p>
<h2 id="on-key-gosub">ON KEY GOSUB</h2>
<p>Declara la subrutina a la que se bifurcará el programa cuando se provoque una interrupción mediante una tecla de función.</p>
<p>Se trata de una instrucción que declara el número de línea de comienzo de una subrutina a la que salta el programa en caso de provocar una interrupción mediante una tecla de función. Tras GOSUB se pueden especificar hasta 10 números de línea, separados por comas, que corresponderían secuencialmente a las teclas de función F1, F2… F10.</p>
<h3 id="versión-135">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-134">Formato</h3>
<pre><code>ON KEY GOSUB número de línea[,número de línea][,número de línea]...</code></pre>
<h3 id="parámetros-116">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-97">Ejemplos</h3>
<pre><code>10 ON KEY GOSUB 1000,, 2000
20 KEY (1) ON:KEY (3) ON</code></pre>
<p>Cuando se pulsa F1 la ejecución del programa salta a la subrutina que comienza en la línea 1000, y cuando se pulsa F3 salta a la subrutina que comienza en la línea 2000.</p>
<p>La vuelta de la subrutina al programa principal se realiza mediante la instrucción RETURN.</p>
<h2 id="on-sprite-gosub">ON SPRITE GOSUB</h2>
<p>Define la subrutina a la que se bifurcará el programa cuando se produzca una interrupción por choque de dos sprites.</p>
<p>Esta instrucción define el número de línea de comienzo de una subrutina a la que salta el programa en caso de una interrupción debida al choque de dos sprites.</p>
<h3 id="versión-136">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-135">Formato</h3>
<pre><code>ON SPRITE GOSUB número de línea</code></pre>
<h3 id="parámetros-117">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplo-1-2">Ejemplo 1</h3>
<pre><code>10 ON SPRITE GOSUB 1000
20 SPRITE ON</code></pre>
<p>Cuando se produce el choque de dos sprites, las líneas anteriores transfieren la ejecución a una subrutina que comienza en la línea 1000. El retorno de la subrutina se especifica mediante una instrucción RETURN.</p>
<h3 id="ejemplo-2-1">Ejemplo 2</h3>
<pre><code>10 ON SPRITE GOSUB 110</code></pre>
<pre><code>20 SCREEN 2,0</code></pre>
<pre><code>30 SPRITE$(0)=STRING$(8,CHR$(255))</code></pre>
<pre><code>40 SPRITE$(1)=STRING$(8,CHR$(255))</code></pre>
<pre><code>50 SPRITE ON</code></pre>
<pre><code>60 FOR I=10 TO 240</code></pre>
<pre><code>70 PUT SPRITE 0,(I,100),11,0</code></pre>
<pre><code>80 PUT SPRITE 1,(250-I,100),15,0</code></pre>
<pre><code>90 NEXT I</code></pre>
<pre><code>100 GOTO 50</code></pre>
<pre><code>105 REM SPRITE COLLISION ROUTINE</code></pre>
<pre><code>110 SPRITE OFF</code></pre>
<pre><code>120 BEEP</code></pre>
<pre><code>130 RETURN</code></pre>
<pre><code></code></pre>
<p>Dos sprites que se mueven en la misma línea horizontal y en distintos planos (0 y 1), pero al cruzarse, suena un BEEP, gracias a la línea 10 que activa la detección de colisión de sprites.</p>
<h2 id="on-stop-gosub">ON STOP GOSUB</h2>
<p>Define la subrutina a la que se bifurcará el programa cuando se produce una interrupción provocada por la pulsación de CTRL+STOP.</p>
<p>Esta instrucción define el número de línea de comienzo de una subrutina a la que salta el programa en caso de una interrupción producida por la pulsación de las teclas CRTL+STOP.</p>
<h3 id="versión-137">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-136">Formato</h3>
<pre><code>ON STOP GOSUB número de línea</code></pre>
<h3 id="parámetros-118">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-98">Ejemplos</h3>
<pre><code>10 ON STOP GOSUB 1000
20 STOP ON</code></pre>
<p>Las dos líneas anteriores transfieren la ejecución del programa a la subrutina que comienza en la línea 1000 en caso de pulsación simultánea de las teclas CTRL+STOP. El retorno de la subrutina se realiza mediante una instrucción RETURN.</p>
<p>Precauciones:</p>
<p>Al ejecutar una subrutina es necesario terminar de alguna forma el programa. La única forma de poner fin al programa siguiente es pulsando la tecla RESET.</p>
<pre><code>10 ON STOP GOSUB 100
20 STOP ON
30 PRINT &quot;MAIN RUTINE&quot;
40 GOTO 40
100 PRINT &quot;CRTL+STOP EXECUTED&quot;
110 RETURN 30</code></pre>
<h2 id="on-strig-gosub">ON STRIG GOSUB</h2>
<p>Define la subrutina a la que salta el programa en caso de una interrupción causada por la pulsación de la barra espaciadora, del botón de disparo del mando de juegos o del pulsador correspondiente de otros periféricos (ratón, bola gráfica, etc).</p>
<p>Esta instrucción define el número de línea de comienzo de una subrutina a la que se bifurca el programa en caso de una interrupción debida a la pulsación de la barra espaciadora o del pulsador correspondiente de un periférico conectado en los puertos del joystick. Pueden especificarse hasta cinco números de línea separados por coma para determinar el elemento causante de la interrupción.</p>
<p>ON STRIG GOSUB Nº Línea 1, Nº Línea 2, Nº Línea 3, Nº Línea 4, Nº Línea 5</p>
<table>
<thead>
<tr class="header">
<th>Nº Línea 1</th>
<th>Bifurcación ante la pulsación de la barra espaciadora.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nº Línea 2</td>
<td>Periférico A, pulsador 1. (conector joystick A)</td>
</tr>
<tr class="even">
<td>Nº Línea 3</td>
<td>Periférico B, pulsador 1. (conector joystick B)</td>
</tr>
<tr class="odd">
<td>Nº Línea 4</td>
<td>Periférico A, pulsador 2. (conector joystick A)</td>
</tr>
<tr class="even">
<td>Nº Línea 5</td>
<td>Periférico B, pulsador 2. (conector joystick B)</td>
</tr>
</tbody>
</table>
<h3 id="versión-138">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-137">Formato</h3>
<pre><code>ON STRIG GOSUB número de línea[,número de línea]...</code></pre>
<h3 id="parámetros-119">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-99">Ejemplos</h3>
<pre><code>10 ON STRIG GOSUB 1000, 2000, 3000
20 STRIG (0) ON: STRIG (1) ON: STRIG (2) ON</code></pre>
<p>Al pulsar la barra espaciadora, transfiere la ejecución del programa a la subrutina que empieza en la línea 1000; al apretar el pulsador 1 del periférico A, transfiere la ejecución a la subrutina que empieza en la línea 2000; al apretar el pulsador 1 del periférico B, transfiere la ejecución a la subrutina que empieza en la línea 3000.</p>
<p>El retorno de la subrutina se realiza mediante una instrucción RETURN.</p>
<h2 id="open">OPEN</h2>
<p>Abre un fichero.</p>
<p>La instrucción OPEN abre el número de fichero especificado en el dispositivo a efectos de realizar una operación de entrada/salida de datos. Entre los dispositivos que se pueden especificar; CRT:, GRP: y LPT: se utilizan únicamente para escribir; por lo tanto, con estos dispositivos hay que especificar el modo OUTPUT (salida). En el caso del dispositivo CAS:, es posible la escritura y la lectura; por lo tanto se puede especificar el modo OUTPUT o el modo INPUT. El modo APPEND se puede especificar también en el caso de unidades de discos (como A: o B:) y la RAM-Disk.</p>
<p>El número de fichero puede ser cualquier número, siempre que sea menor al número especificado en la instrucción MAXFILES.</p>
<p>Omisión de FOR modo</p>
<p>La omisión de FOR modo, especifica que se abre un fichero de acceso aleatorio. Los ficheros de acceso aleatorio solo pueden existir en disco.</p>
<p>Especificación de la longitud del registro</p>
<p>En la instrucción OPEN se puede especificar la longitud máxima del registro en fichero de acceso aleatorio. El valor por omisión es 256.</p>
<h3 id="versión-139">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-138">Formato</h3>
<pre><code>OPEN &quot;[nombre de dispositivo][nombre de fichero[.extensión]]&quot; [FOR modo] AS [#] número de fichero [LEN = longitud del registro]</code></pre>
<h3 id="parámetros-120">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre del dispositivo</th>
<th><strong>Cond.</strong> CRT:, GRP:, LPT: <strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H:, <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre del fichero</td>
<td><strong>Cond</strong>. Una cadena de 6 o menos caracteres. Una cadena de 8 o menos caracteres y hasta 256 en el caso de un MSXVR. <strong>Omit.</strong> Una cadena nula (no se puede omitir el nombre del fichero cuando se opera con un disco flexible o con la RAM-Disk).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond</strong>. Una cadena de 3 caracteres o menos. En un MSXVR, hasta 256 caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
<tr class="odd">
<td>Modo</td>
<td><strong>Cond.</strong> OUTPUT, INPUT, APPEND.</td>
</tr>
<tr class="even">
<td>Número de fichero</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz y sus expresiones (numéricas); 1≤número≤número especificado en la instrucción MAXFILES.</td>
</tr>
<tr class="odd">
<td>Longitud de registro</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (enteras), 1≤longitud≤256. <strong>Omit.</strong> 256.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-100">Ejemplos</h3>
<pre><code>10 SCREEN 2
20 OPEN &quot;GRP:&quot; FOR OUTPUT AS #1
30 PSET (120, 90)
40 PRINT #1, &quot;ABC&quot;
50 GOTO 50</code></pre>
<p>Este programa visualiza caracteres en la pantalla en modo gráfico (SCREEN 2).</p>
<h2 id="out">OUT</h2>
<p>Envía un dato de 1 byte al puerto de entrada/salida especificado.</p>
<p>Esta instrucción envía datos directamente a un puerto de E/S.</p>
<h3 id="versión-140">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-139">Formato</h3>
<pre><code>OUT número de puerto, expresión</code></pre>
<h3 id="parámetros-121">Parámetros</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de puerto, expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤número&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="pad">PAD</h2>
<p>Ofrece el estado del dispositivo señalizador (touch pad, lápiz óptico, ratón y bola gráfica).</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Valor de N</strong></th>
<th><strong>Significado del valor obtenido</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Touch pad</strong></td>
<td>0 o 4 1 o 5 2 o 6 3 o 7</td>
<td>0: sin contacto -1: contacto Coordenada X de la posición de contacto Coordenada Y de la posición de contacto 0: interruptor no pulsado -1: interruptor pulsado</td>
</tr>
<tr class="even">
<td><strong>Lápiz óptico</strong></td>
<td>8 9 10 11</td>
<td>0: sin contacto -1: contacto Coordenada X de la posición de contacto Coordenada Y de la posición de contacto 0: interruptor del lápiz luminoso no pulsado -1: interruptor del lápiz luminoso pulsado</td>
</tr>
<tr class="odd">
<td><strong>Ratón o bola gráfica</strong></td>
<td>12 o 16 13 o 17 14 o 18 15 o 19</td>
<td>-1: petición de entrada Coordenada X del ratón o bola gráfica Coordenada Y del ratón o bola gráfica 0</td>
</tr>
</tbody>
</table>
<p>Cuando N es un valor comprendido entre 0 y 3 o entre 12 y 15, ofrece el estado del dispositivo señalizador conectado en el conector del controlador A. Cuando N es un valor comprendido entre 4 y 7 o entre 16 y 19, ofrece el estado del dispositivo señalizador conectado en el conector del controlador B.</p>
<p>Para leer el estado del ratón o de la bola gráfica, se debe utilizar en primer lugar PAD (12) o PAD (16) y leer las coordenadas. Para introducir el estado del botón se utiliza la función STRIG. La entrada solo es posible cuando se utiliza en primer lugar PAD (12) o PAD (16). Si el intervalo de tiempo es demasiado largo, el contador introducirá un valor de coordenadas arbitrario.</p>
<h3 id="versión-141">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-140">Formato</h3>
<pre><code>PAD(N)</code></pre>
<h3 id="parámetros-122">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤N&lt;20.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-32">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-101">Ejemplos</h3>
<pre><code>100 SCREEN 5
110 FOR I = 0 TO 7
120 A$ = A$+CHR$ (2^I-1)
130 NEXT
140 SPRITE$ (0) = A$
150 D = PAD (12)
160 X = X+PAD (13):Y = Y+PAD (14)
170 PUT SPRITE 2, (X,Y), 8, 0
180 GOTO 150 </code></pre>
<h2 id="paint">PAINT</h2>
<p>Colorea, a partir de unas coordenadas X e Y de la pantalla, el área delimitada por un contorno de la pantalla donde esté contenida dicha posición. El color de relleno es el especificado en el parámetro “color de pintura” y los límites del área a rellenar vendrán establecidos por el parámetro “color del contorno”.</p>
<p>Si la línea del contorno no es cerrada, colorea toda la pantalla.</p>
<p>En los modos SCREEN 2 y SCREEN 4 colorea toda la pantalla si no coinciden los colores de pintura y del contorno.</p>
<p>Cuando se especifica STEP, pasa X, Y a un nuevo sistema de coordenadas que tiene su origen en el último punto especificado en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-142">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-141">Formato</h3>
<pre><code>PAINT [STEP](coordenada X, coordenada Y), [color de pintura], [color del contorno]</code></pre>
<h3 id="parámetros-123">Parámetros</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenada X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤X&lt;513.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Coordenada Y</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤Y&lt;213.</td>
</tr>
<tr class="even">
<td>Color de pintura, color del contorno</td>
<td><strong>Cond.</strong> SCREEN 2 a 7: Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤color&lt;16. SCREEN 8 a 13: Constantes, variables, variables de matriz y sus expresiones (numéricas); 0≤color&lt;256. <strong>Omit.</strong> Color del primer plano actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-102">Ejemplos</h3>
<div class="line-block">10 CLS | En los modos SCREEN 2 Y SCREEN 4 hay que especificar el mismo color en los términos “color pintura” y “color contorno”. |<br />
20 SCREEN 5 | |<br />
30 CIRCLE (70, 70), 40, 1 | |<br />
40 PAINT (70, 70), 10, 1 | |<br />
50 GOTO 50 | |</div>
<p>|——————————————————————————|————————————————————————————————————————-|</p>
<h2 id="pdl">PDL</h2>
<p>Ofrece el valor procedente de un “paddle”, en forma de dato numérico. Cuando N es un número impar, proporciona los datos de un “paddle” conectado al controlador A, y cuando N es un número par proporciona los datos de un “paddle” conectado al controlador B.</p>
<h3 id="versión-143">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-142">Formato</h3>
<pre><code>PDL(X)</code></pre>
<h3 id="parámetros-124">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (enteros); 0≤X&lt;13</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-33">Retorno</h3>
<p>Tipo numérico, 0≤valor≤255.</p>
<h2 id="peek">PEEK</h2>
<p>Devuelve el contenido de una dirección de memoria especificada.</p>
<h3 id="versión-144">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-143">Formato</h3>
<pre><code>PEEK (dirección)</code></pre>
<h3 id="parámetros-125">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>Dirección</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); -32768≤dirección&lt;65536. En el caso de números negativos, su valor es el resultado de sumarlos a 65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-34">Retorno</h3>
<p>Tipo numérico en notación decimal.</p>
<h3 id="ejemplos-103">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>M = PEEK (50000)</th>
<th>Asigna el contenido de la dirección de memoria 50000 a la variable M.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="play">PLAY</h2>
<p>Emite un sonido de acuerdo con los comandos especificados.</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 41%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 9%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Comando</strong></th>
<th><strong>Condición</strong></th>
<th><strong>Significado</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tn</td>
<td>Enteros de 32≤n≤255</td>
<td>Especifica la velocidad de ejecución de la música. El valor de n indica la cuenta de un cuarto de nota durante un minuto. La selección inicial es T120.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>(tiempo)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>On</td>
<td>Enteros de 1≤n≤8</td>
<td>Especifica una de las 8 octavas. Cuando se especifica 04, ejecuta la música dentro de la escala mostrada a continuación.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>(octava)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Ln</td>
<td>Enteros de 1≤n≤64</td>
<td>Indica la duración del sonido.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>(duración)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>L1</td>
<td>L2</td>
<td>L4</td>
<td>L8</td>
<td>L16</td>
<td>L32</td>
<td>L64</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>w</td>
<td>h</td>
<td>q</td>
<td>e</td>
<td>s</td>
<td><a href="./media/image9.jpeg">./media/image9.jpeg</a></td>
<td><a href="./media/image10.jpeg">./media/image10.jpeg</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Nn</td>
<td>Enteros de 0≤n≤96</td>
<td><a href="./media/image8.png">./media/image8.png</a> Especifica una nota musical.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>(nota)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>A-G</td>
<td>Enteros de 1≤n≤64</td>
<td>Especifica la nota musical de una octava especificada.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>An-Gn</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>(nota)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Rn</td>
<td>Enteros de 1≤n≤64</td>
<td>Especifica un silencio.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>(silencio)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>R1</td>
<td>R2</td>
<td>R4</td>
<td>R8</td>
<td>R16</td>
<td>R32</td>
<td>R64</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><a href="./media/image12.png">./media/image12.png</a></td>
<td><a href="./media/image13.png">./media/image13.png</a></td>
<td><a href="./media/image14.png">./media/image14.png</a></td>
<td><a href="./media/image15.png">./media/image15.png</a></td>
<td><a href="./media/image16.png">./media/image16.png</a></td>
<td><a href="./media/image17.png">./media/image17.png</a></td>
<td><a href="./media/image18.png">./media/image18.png</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>.</td>
<td></td>
<td>Especifica el puntillo musical. La duración de la nota se amplía en ½ de la nota o silencio que lo lleva delante. C4 = j R4 = J</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>(puntillo)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Vn</td>
<td>Enteros de 0≤0≤15</td>
<td>Especifica el volumen. El volumen aumenta al aumentar n. La posición inicial es V8.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>(volumen)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Sn</td>
<td>Enteros de 0≤n≤15</td>
<td>Especifica el modelo de variación del volumen entre los siguientes: La selección inicial es S1. La generación de muchos sonidos diferentes es el resultado de la combinación del comando S con el comando M.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>(forma)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Mn (modulación)</td>
<td>Enteros de 1≤n≤65535</td>
<td>Determina el ciclo del modelo especificado por el comando S. El ciclo se alarga al aumentar el valor de n. La selección inicial es M255.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="media/0df15c51211ced1467dc52450915754a.png" /></p>
<p>La octava desciende cuando disminuye el valor de n y sube cuando el valor de n aumenta. El valor inicial es 04.</p>
<p>El valor inicial es L4.</p>
<figure>
<img src="media/3530ae52fb2d19de861a6e5cb799dfd9.png" alt="" /><figcaption>Resultado de imagen de teclados piano</figcaption>
</figure>
<p>Para el semitono se utilizan # (0+) y -.La longitud del sonido se puede especificar con n. (C4 es igual que L4C). La longitud por omisión es la especificada por Ln.</p>
<dl>
<dt>~ Resultado de imagen de silencio de semifusa</dt>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
<dd><p>Resultado de imagen de silencio de semifusa</p>
</dd>
</dl>
<pre><code>PLAY &quot;T80O3L4CDEFG2.RABO4CDC2.&quot;</code></pre>
<p>La instrucción anterior produce un sonido compuesto por las siguientes notas:</p>
<p><img src="media/122b2250fc685d00f770cea8ec35e3a8.png" /></p>
<p>03 04</p>
<p><strong>Expresión de un comando con una variable</strong></p>
<pre><code>M$ = &quot;T80O3L4CDEFG2.RABO4CDC2.&quot;
PLAY M$</code></pre>
<p>Estas instrucciones asignan un comando a la variable de cadena M$, que después se especifica en la sentencia PLAY como comando.</p>
<p><strong>Expresión de una parte de un comando con una variable (X variable;)</strong></p>
<pre><code>10 M$ = &quot;CDEFG2.R&quot;
20 PLAY &quot;O4L4XM$; GAGAG2.R&quot;
30 PLAY &quot;XM$;ABO5CDC2.&quot;</code></pre>
<p>Cuando en una instrucción PLAY se utiliza un comando asignado a una variable de cadena encerrada entre comillas (" "), se debe añadir antes X y después ;. En el ejemplo anterior, el comando asignado a M$ se utiliza en dos instrucciones PLAY.</p>
<p><strong>Expresión de un comando con una variable (=variable;)</strong></p>
<p>El valor de n especificado en un comando puede ser una constante o una variable, incluidas como tal en una instrucción PLAY. Cuando se expresan como una variable, se debe añadir “=” antes y “,” después.</p>
<pre><code>10 FOR I = 1 TO 8
20 PLAY &quot;O = I; CEG&quot;
30 NEXT I</code></pre>
<p>Este programa ejecuta una octava musical, desde PLAY “01CEG” hasta PLAY “08CEG”.</p>
<p><strong>Generación de acordes</strong></p>
<p>Se pueden ejecutar simultáneamente hasta 3 voces, por ejemplo, PLAY A$, B$, C$.</p>
<pre><code>10 A$ = &quot;O4CDO3BO4E2R4&quot;
20 B$ = &quot;O4EFDG2R4&quot;
30 C$ = &quot;O4GAGO5C2R4&quot;
40 PLAY A$, B$, C$</code></pre>
<p>Este programa toca las notas siguientes:</p>
<p><img src="media/ec3e7c175f965a6f373b17cffcfa89ab.png" /></p>
<h3 id="versión-145">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-144">Formato</h3>
<pre><code>PLAY comando [,comando][,comando]</code></pre>
<h3 id="parámetros-126">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Comando</th>
<th><strong>Cond.</strong> Constantes y variables de cadena.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="play-1">PLAY</h2>
<p>Comprueba si se está ejecutando música o no.</p>
<p>Con una instrucción PLAY se pueden ejecutar simultáneamente tres sonidos diferentes.</p>
<p>En el caso concreto de PLAY, A$, B$, C$; el sonido del comando A$ sale por el canal 1, el sonido del comando B$ sale por el canal 2 y el sonido del comando C$ sale por el canal 3.</p>
<p>La función PLAY comprueba si hay datos en el buffer (memoria intermedia) de los datos musicales del canal 1 cuando N = 1, del canal 2 cuando N = 2, y del canal 3 cuando N = 3. Cuando hay datos en la memoria intermedia devuelve un -1 y cuando no hay datos un 0. Cuando N = 0, devuelve -1 si uno cualquiera de los tres canales tiene datos en el buffer.</p>
<h3 id="versión-146">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-145">Formato</h3>
<pre><code>PLAY(N)</code></pre>
<h3 id="parámetros-127">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (enteros); 0≤Nz&lt;4.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-35">Retorno</h3>
<p>Tipo numérico.</p>
<h2 id="point">POINT</h2>
<p>Ofrece el código de color de un punto de una posición especificada.</p>
<h3 id="versión-147">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-146">Formato</h3>
<pre><code>POINT(X,Y)</code></pre>
<h3 id="parámetros-128">Parámetros</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>X,Y</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz y sus expresiones (numéricas); -32768≤coordenadas&lt;32768.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-104">Ejemplos</h3>
<pre><code>10 SCREEN 3
20 FOR I = 1 TO 250
30 X = INT (RND(1)*255)
40 Y = INT (RND(1)*191)
50 PSET (X, Y), 1
60 NEXT I
70 FOR Y = 0 TO 191 STEP 4
80 FOR X = 0 TO 255 STEP 4
90 C = POINT (X, Y)
100 IF C = 4 THEN PSET (X, Y), 15
110 NEXT X, Y
120 GOTO 120</code></pre>
<p>La línea 90 asigna el código de color correspondiente a una posición (X, Y) a la variable C, y la línea 100 lo cambia a blanco si C es 4 (azul oscuro).</p>
<h2 id="poke">POKE</h2>
<p>Escribe datos la dirección de memoria especificada.</p>
<h3 id="versión-148">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-147">Formato</h3>
<pre><code>POKE dirección, expresión</code></pre>
<h3 id="parámetros-129">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>Dirección</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32768≤dirección&lt;65536. En caso de números negativos, su valor es el resultado de sumarlos a 65536.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤expresión&lt;256.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-105">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>POKE 5000, 255</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Escribe el dato 255 en la dirección de memoria 5000.</p>
<table>
<thead>
<tr class="header">
<th>POKE &amp;HD000, &amp;HA8</th>
<th>Escribe el dato HA8 en la dirección de memoria HD000.</th>
<th></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="pos">POS</h2>
<p>Devuelve la coordenada X de la posición del cursor.</p>
<h3 id="versión-149">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-148">Formato</h3>
<pre><code>POS(X)</code></pre>
<h3 id="parámetros-130">Parámetros</h3>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constante, variable, variable de matriz o sus expresiones (numéricas) (argumento ficticio).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-36">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-106">Ejemplos</h3>
<pre><code>10 INPUT A$
20 PRINT A$;:X = POS (X)
30 IF X&gt;=5 THEN CLS
40 PRINT: GOTO 10</code></pre>
<p>La línea 20 X = POS (X), asigna el valor de la coordenada X de la posición del cursor a la variable X. En consecuencia, la pantalla se borra al asignar una cadena con cinco o más caracteres para A$.</p>
<h2 id="preset">PRESET</h2>
<p>Marca o borra un punto en la pantalla, en el modo gráfico.</p>
<p>Cuando se ejecuta omitiendo la especificación del color, marca un punto con el mismo color del fondo. En consecuencia, si hay algo dibujado en la posición especificada en un color distinto al color del fondo, da la impresión de que ha borrado un punto en esa posición.</p>
<p>Cuando se especifica un color, la función es idéntica que cuando se especifica un color con PSET.</p>
<p>Consulte el programa ejemplo de PSET.</p>
<p>Cuando se especifica STEP, pasa, X, Y a un nuevo sistema de coordenadas que tiene su origen en el punto especificado en último lugar en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-150">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-149">Formato</h3>
<pre><code>PRESET [STEP](coordenada X, coordenada Y) [,color] [operación lógica]</code></pre>
<h3 id="parámetros-131">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenada X, Y</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32768≤coordenada&lt;32768.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Color</td>
<td><strong>Cond.</strong> SCREEN 2 a 7: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤color &lt;16. <strong>Omit.</strong> Color actual del fondo.</td>
</tr>
<tr class="even">
<td>Operación lógica</td>
<td><strong>Cond.</strong> SCREEN 5 a 13: PSET, PRESET, XOR, OR, AND. <strong>Omit.</strong> PSET.</td>
</tr>
</tbody>
</table>
<h2 id="print">PRINT</h2>
<p>Visualiza datos numéricos o alfanuméricos en la pantalla en modo texto.</p>
<p><strong>Método de escritura de expresiones (datos)</strong></p>
<p>Las constantes de tipo numérico, las variables numéricas y las variables de cadena se escriben tal como son. Las constantes de cadena se escriben encerradas entre comillas (" ").</p>
<p><strong>Función del separador</strong></p>
<p>Cuando los datos están separados por una coma, la función TAB de 14 dígitos inserta espacios entre los datos, y cuando están separados por un punto y coma, los datos se visualizarán uno al lado del otro.</p>
<p>Si al final de la instrucción no se escribe ningún separador, realiza un salto de línea tras la presentación de los datos. Si al final se ha puesto un separador, los datos de la siguiente instrucción PRINT continúan en la misma línea.</p>
<p><strong>Signos y datos numéricos</strong></p>
<p>Con respecto a los signos positivo (+) y negativo (-), omite el positivo (+) y presenta el negativo (-) donde esté (si se utiliza el separador punto y coma con datos numéricos, inserta dos espacios entre los datos para dejar sitio al signo).</p>
<p><strong>Omisión del formato</strong></p>
<p>Se obtiene el mismo resultado escribiendo el signo de interrogación (?) en vez de PRINT.</p>
<h3 id="versión-151">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-150">Formato</h3>
<pre><code>PRINT [expresión][separador][expresión][separador]...</code></pre>
<pre><code>? [expresión][separador][expresión][separador]...</code></pre>
<h3 id="parámetros-132">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas o de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Separador</td>
<td><strong>Cond.</strong> Coma (,) o punto y coma(;).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-107">Ejemplos</h3>
<pre><code>10 A$ = &quot;ABC&quot; :B$ = &quot;DEFF&quot;
20 PRINT A$;B$
30 PRINT A$, B$
40 PRINT
50 PRINT &quot;MSX&quot;
60 PRINT +50, -50
70 ? &quot;PERSONAL COMPUTER&quot;
RUN</code></pre>
<pre><code>ABCDEF                  Resultado de la línea 20</code></pre>
<p>ABC DEF <em>Resultado de la línea 30</em></p>
<p>Resultado de la línea 40</p>
<p>MSX <em>Resultado de la línea 50</em></p>
<p>50 -50 <em>Resultado de la línea 60</em></p>
<p>PERSONAL COMPUTER <em>Resultado de la línea 70</em></p>
<h2 id="print-using">PRINT USING</h2>
<p>Visualiza datos a la pantalla usando un formato especificado.</p>
<p>Presenta en pantalla el valor de una expresión en un formato especificado por un símbolo de formato.</p>
<p><strong>Símbolos de formato para datos alfanuméricos</strong></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Símbolo</th>
<th>Formato de la expresión y ejemplo de ejecución</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“!”</td>
<td>Imprime el primer carácter:</td>
</tr>
<tr class="even">
<td>“\ -\” n espacios</td>
<td>Imprime n + 2 caracteres. Cuando los datos sean menores a n+2 caracteres, inserta espacios para los caracteres residuales.</td>
</tr>
<tr class="odd">
<td>“&amp;”</td>
<td>Imprime todas las cadenas de caracteres.</td>
</tr>
</tbody>
</table>
<pre><code>PRINT USING &quot;!&quot;; &quot;BASIC&quot;, &quot;MSX&quot;
BM</code></pre>
<pre><code>PRINT USING &quot;\ \&quot;; &quot;ABCDEF&quot;, &quot;GHI&quot;, &quot;JKLMN&quot; ABCDGHI JKLM</code></pre>
<pre><code>10 A$ = &quot;Norte&quot;: B$ = &quot;Sur&quot;
20 PRINT USING &quot;Polo &amp; &quot;;A$, B$
RUN
Polo Norte       Polo Sur</code></pre>
<p><strong>Símbolos de formato para datos de tipo numérico</strong></p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Símbolo</th>
<th>Formato de la expresión y ejemplo de ejecución.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>“#”</td>
<td>Escribe tantos dígitos como número de símbolos #. La coma decimal es “.”</td>
</tr>
<tr class="even">
<td>“+”</td>
<td>Antes o después del dato numérico, muestra el signo “+” si se trata de un número positivo y el signo “-” si se trata de un número negativo.</td>
</tr>
<tr class="odd">
<td>“-”</td>
<td>Muestra el signo menos “-” a continuación de un dato numérico negativo.</td>
</tr>
<tr class="even">
<td>“**”</td>
<td>Rellena con asteriscos los espacios anteriores al dato numérico. Cada asterisco usado en el formato también expresa un dígito.</td>
</tr>
<tr class="odd">
<td>“££” o “$$”</td>
<td>Añade el signo “£” justo antes del dato numérico. Cada £ usado en el formato también expresa un dígito.</td>
</tr>
<tr class="even">
<td>“**£” o “**$”</td>
<td>Añade el signo “£” justo antes del dato numérico, y rellena los espacios anteriores con asteriscos “*”.</td>
</tr>
<tr class="odd">
<td>“,”</td>
<td>Cuando se especifica la coma en algún sitio anterior a la coma decimal (el punto), inserta comas cada tres dígitos, por delante de la coma decimal (el punto).</td>
</tr>
<tr class="even">
<td>“^^^^”</td>
<td>Presenta datos numéricos con el formato de coma flotante. “^^^^” corresponde a los dígitos de la parte exponente.</td>
</tr>
</tbody>
</table>
<pre><code>PRINT USING &quot;POINT: ###.#&quot;; 123.4
POINT: 123.4</code></pre>
<p>Cuando el número de dígitos enteros es menor que el número de símbolos # especificado, presenta los datos con justificación a la derecha, y si es mayor añade el símbolo % antes del dato.</p>
<pre><code>10 PRINT USING &quot;####&quot;; 12
20 PRINT USING &quot;####&quot;; 12345
RUN
12
%12345</code></pre>
<p>Cuando el número de dígitos siguientes a la coma decimal de un dato numérico sea inferior al número de símbolos # especificados, añade un cero, y cuando es mayor, redondea el número al entero más cercano.</p>
<pre><code>10 PRINT USING &quot;##.##&quot;; 25.3
20 PRINT USING &quot;##.##&quot;; 25.345
RUN
25.30
25.35</code></pre>
<p>Ignora el signo “+” de los datos numéricos y cuenta el signo “-” como un dígito.</p>
<pre><code>10 PRINT USING &quot;###&quot;; +123
20 PRINT USING &quot;###&quot;; -123
RUN
123
%-123</code></pre>
<pre><code>PRINT USING &quot;###+&quot;; 123, -123
+123 -123
123+ 123-</code></pre>
<pre><code>PRINT USING &quot;###-&quot;; 123, -123
123  123-</code></pre>
<pre><code>10 PRINT USING &quot;**######&quot;; 123
20 PRINT USING &quot;**######&quot;;-234
RUN
*****123
****-234</code></pre>
<pre><code>10 PRINT USING &quot;££###&quot;; 1234
20 PRINT USING &quot;+££###&quot;; -1234
RUN
£ 1234
-£ 1234</code></pre>
<pre><code>PRINT USING &quot;**£###.##&quot;; 12.34
***£ 12.34</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code>PRINT USING &quot;#,######.##&quot;; 12345.67</code></pre>
<pre><code>12,345.67</code></pre>
<pre><code>PRINT USING &quot;##.##^^^^&quot;; 234.56
235E+02</code></pre>
<h3 id="versión-152">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-151">Formato</h3>
<pre><code>PRINT USING símbolo del formato;expresión[,expresión]</code></pre>
<h3 id="parámetros-133">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas y de cadena).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="print-1">PRINT #</h2>
<p>Introduce datos en un fichero abierto por una instrucción OPEN.</p>
<h3 id="versión-153">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-152">Formato</h3>
<pre><code>PRINT # número de fichero, [expresión][separador][expresión][separador]...</code></pre>
<h3 id="parámetros-134">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de tipo entero); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas y de cadena).</td>
</tr>
<tr class="even">
<td>Separador</td>
<td><strong>Cond.</strong> Coma (,) o punto y coma (;).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-108">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>10 OPEN “CAS:DATA” FOR OUTPUT AS #1</th>
<th><em>Abre un fichero para escritura</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>20 FOR I = 0 TO 4</td>
<td></td>
</tr>
<tr class="even">
<td>30 READ A$</td>
<td></td>
</tr>
<tr class="odd">
<td>40 PRINT #1, A$;“,”;</td>
<td><em>Escribe datos en el fichero</em></td>
</tr>
<tr class="even">
<td>50 NEXT I</td>
<td></td>
</tr>
<tr class="odd">
<td>60 CLOSE #1</td>
<td></td>
</tr>
<tr class="even">
<td>70 DATA TOKIO, LONDRES, PARIS, PEKIN, NUEVA YORK</td>
<td></td>
</tr>
</tbody>
</table>
<p>Este programa escribe secuencialmente en una cinta casete los datos escritos en la línea 70, en un fichero de nombre “DATA”.</p>
<h2 id="print-using-1">PRINT #USING</h2>
<p>Escribe datos con un formato especificado en un fichero abierto por una instrucción OPEN.</p>
<p>Se puede especificar este formato para enviar datos a un fichero. Para información relativa a los símbolos de formato, véase PRINT USING.</p>
<h3 id="versión-154">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-153">Formato</h3>
<pre><code>PRINT # número de fichero USING símbolo de formato; expresión[,expresión]...</code></pre>
<h3 id="parámetros-135">Parámetros</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (enteras); 1≤número de fichero≤número especificado por instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas y de cadena).</td>
</tr>
</tbody>
</table>
<h2 id="pset">PSET</h2>
<p>Marca un punto en la pantalla, en el modo de gráficos.</p>
<p>Cuando se especifica STEP, las coordenadas X, Y pasan a un nuevo sistema de coordenadas que tiene su origen en el punto especificado en último lugar en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-155">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-154">Formato</h3>
<pre><code>PSET [STEP](coordenada X, coordenada X) [,color],[operación lógica] </code></pre>
<h3 id="parámetros-136">Parámetros</h3>
<div class="line-block">Coordenada X, Y | <strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); |<br />
                 | -32768≤coordenadas&lt;32768. |</div>
<p>|——————|—————————————————————————————————————————————————————————————————————————————————————-| | Color | <strong>Cond.</strong> SCREEN 2 a 7: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤color&lt;16. SCREEN 8 a 13: Constantes, variables, variables matriciales, sus expresiones (numéricas); 0≤color&lt;256. <strong>Omit.</strong> Color actual del primer plano. | | Operación lógica | <strong>Cond.</strong> SCREEN 5 a 13: PSET, PRESET, XOR, OR, AND. <strong>Omit.</strong> PSET. |</p>
<h3 id="ejemplo1">Ejemplo1</h3>
<pre><code>10 SCREEN 2
20 FOR X = 0 TO 255
30 PSET (X+1, 100)  Dibuja un punto
40 PRESET (X, 100)  Borra el punto dibujado por la línea 30
50 NEXT X</code></pre>
<h3 id="ejemplo-2-2">Ejemplo 2</h3>
<pre><code>10 REM Puntos</code></pre>
<pre><code>20 R=TIME</code></pre>
<pre><code>30 RDRST=RND(-R)</code></pre>
<pre><code>40 SCREEN 3</code></pre>
<pre><code>50 REM Puntos de colores aleatorios</code></pre>
<pre><code>60 FOR I%=1 TO 300</code></pre>
<pre><code>70 GOSUB 1000</code></pre>
<pre><code>80 PSET(X%,Y%),Z%</code></pre>
<pre><code>90 NEXT I%</code></pre>
<pre><code>100 REM Borrar los puntos</code></pre>
<pre><code>110 RDRST=RND(-R)</code></pre>
<pre><code>120 FOR J%=1 TO 300</code></pre>
<pre><code>130 GOSUB 1000</code></pre>
<pre><code>140 PRESET(X%,Y%)</code></pre>
<pre><code>150 NEXT J%</code></pre>
<pre><code>160 END</code></pre>
<pre><code>999 REM Subrutina aleatoria</code></pre>
<pre><code>1000 X%=RND(1)*256</code></pre>
<pre><code>1010 Y%=RND(1)*192</code></pre>
<pre><code>1020 Z%=RND(1)*16</code></pre>
<pre><code>1030 RETURN</code></pre>
<pre><code></code></pre>
<p>Este ejemplo dibuja y borra puntos en pantalla, pero esta vez, los puntos son de colores aleatorios y además hacemos uso del modo gráfico SCREEN.</p>
<h3 id="ejemplo-3-1">Ejemplo 3</h3>
<pre><code></code></pre>
<pre><code>80 SCREEN 2</code></pre>
<pre><code>90 COLOR 1,7,7</code></pre>
<pre><code>100 CLS</code></pre>
<pre><code>120 DIM A(12),B(12)</code></pre>
<pre><code>130 FOR N=1 TO 12</code></pre>
<pre><code>135 K=N/6*3.1415927#</code></pre>
<pre><code>140 A(N)=128+80*SIN(K):B(N)=88+80*COS(K)</code></pre>
<pre><code>150 PSET(A(N),B(N))</code></pre>
<pre><code>160 NEXT N</code></pre>
<pre><code>170 FOR N=1 TO 12</code></pre>
<pre><code>180 FOR M=1 TO 12</code></pre>
<pre><code>190 LINE(A(N),B(N))-(A(M),B(M))</code></pre>
<pre><code>200 NEXT M</code></pre>
<pre><code>210 NEXT N</code></pre>
<pre><code>220 GOTO 220</code></pre>
<pre><code></code></pre>
<pre><code>Un ejemplo dibujando una figura geométrica.</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="put">PUT</h2>
<p>Escribe el registro definido por la instrucción FIELD en un fichero de acceso aleatorio.</p>
<h3 id="versión-156">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-155">Formato</h3>
<pre><code>PUT [#] número de fichero [,número de registro]</code></pre>
<h3 id="parámetros-137">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Número de registro</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤número &lt;65536. <strong>Omit.</strong> El número de registro utilizado en la instrucción GET o PUT ejecutada en último lugar más uno.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-109">Ejemplos</h3>
<pre><code>10 OPEN &quot;A: TEST.DAT&quot; AS #1
20 FIELD #1, 2 AS CODE$, 15 AS NAM$, 10 AS TEL$
30 READ A%, B$, C$
40 LSET CODE$ = MKI$ (A%)
50 LSET NAM$ = B$
60 LSET TEL$ = C$
70 PUT #1, 1
80 CLOSE #1
90 DATA 100, JORGE, 211-71-71
100 END</code></pre>
<p>La ejecución de la instrucción de la línea 70 graba en el fichero de acceso aleatorio, preparado por las instrucciones LSET/RSET, el registro número 1.</p>
<h2 id="put-sprite">PUT SPRITE</h2>
<p>Visualiza un sprite en una posición arbitraria del plano de sprite especificado.</p>
<p>Cuando se especifica STEP, las coordenadas X, Y pasan a un nuevo sistema de coordenadas que tiene su origen en el punto especificado en último lugar en la instrucción gráfica inmediatamente anterior.</p>
<h3 id="versión-157">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-156">Formato</h3>
<pre><code>PUT SPRITE número de plano del sprite, [[STEP](coordenada X, coordenada Y)][,color][,número de sprite]</code></pre>
<h3 id="parámetros-138">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de plano de sprite</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número&lt;32.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Coordenada X</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32≤X &lt;256.</td>
</tr>
<tr class="even">
<td>Coordenada Y</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); -32≤Y&lt;212.</td>
</tr>
<tr class="odd">
<td>Color</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤color&lt;16. <strong>Omit.</strong> Color actual del primer plano.</td>
</tr>
<tr class="even">
<td>Número de sprite</td>
<td><strong>Cond.</strong> Para 8x8 puntos: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número &lt;256. Para 16x16 puntos: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número &lt;64. <strong>Omit.</strong> El mismo que el número de plano de sprite.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplo-1-3">Ejemplo 1</h3>
<pre><code>10 SCREEN 2
20 SPRITE$ (1) = CHR$(&amp;H18)+CHR$(&amp;H3C)+CHR$(&amp;H66)+CHR$(&amp;HDB)+CHR$(&amp;HE7)+CHR$(&amp;H7E)+CHR$(&amp;H24)+CHR$(&amp;H42)
30 X = 0: Y = 0: DX = 1: DY = 1
40 PUT SPRITE 0, (X, Y),, 1
50 X = X+DX: Y= Y+DY
60 IF X&gt;250 OR X&lt;0 THEN DX = -DX
70 IF Y&gt;190 OR Y&lt;0 THEN DY = -DY
80 GOTO 40</code></pre>
<p>La línea 20 define un sprite en forma de OVNI, asignado al sprite número 1. La instrucción 40, PUT SPRITE, presenta este sprite en pantalla; el número del plano de sprite es el 0. Como se ha omitido el color, es el mismo que el color de primer plano seleccionado anteriormente. El OVNI da la impresión de volar por la pantalla debido al cambio de los valores de las coordenadas X, Y, que especifican su posición.</p>
<h3 id="ejemplo-2-3">Ejemplo 2</h3>
<pre><code>10 SCREEN 2,2</code></pre>
<pre><code>20 FOR I=1 TO 32</code></pre>
<pre><code>30 READ B%</code></pre>
<pre><code>40 S$=S$+CHR$(B%)</code></pre>
<pre><code>50 NEXT I</code></pre>
<pre><code>60 SPRITE$(0)=S$</code></pre>
<pre><code>70 PUT SPRITE 0,(100,100),15,0</code></pre>
<pre><code>80 GOTO 80</code></pre>
<pre><code>90 DATA 31,63,96,199,200,104,100,51</code></pre>
<pre><code>100 DATA 52,27,24,12,12,6,3,1</code></pre>
<pre><code>110 DATA 248,252,6,227,19,22,38,204</code></pre>
<pre><code>120 DATA 44,216,24,48,48,96,192,128</code></pre>
<pre><code></code></pre>
<pre><code>Dibujamos en pantalla un sprite y lo mostramos.</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-3-2">Ejemplo 3</h3>
<pre><code></code></pre>
<pre><code>10 SCREEN 2,0</code></pre>
<pre><code>20 SPRITE$(0)=STRING$(8,CHR$(255))</code></pre>
<pre><code>30 FOR X=200 TO -200 STEP -1</code></pre>
<pre><code>40 PUT SPRITE 0,(X,100),1,0</code></pre>
<pre><code>50 FOR D=1 TO 50:NEXT</code></pre>
<pre><code>60 NEXT</code></pre>
<pre><code>70 END</code></pre>
<pre><code></code></pre>
<pre><code>Usamos el carácter 255 (cursor) como sprite y lo desplazamos de derecha a izquierda.</code></pre>
<h3 id="ejemplo-4-1">Ejemplo 4</h3>
<pre><code>10 SCREEN 2</code></pre>
<pre><code>20 FOR I=1 TO 8</code></pre>
<pre><code>30 READ A$</code></pre>
<pre><code>40 S$=S$+CHR$(VAL(&quot;&amp;B&quot;+A$))</code></pre>
<pre><code>50 NEXT I</code></pre>
<pre><code>60 SPRITE$(0)=S$</code></pre>
<pre><code>70 PUT SPRITE 0,(100,100),15,0</code></pre>
<pre><code>80 GOTO 80</code></pre>
<pre><code>90 REM BINARY DATA</code></pre>
<pre><code>100 DATA 00010000</code></pre>
<pre><code>110 DATA 00110000</code></pre>
<pre><code>120 DATA 01110000</code></pre>
<pre><code>130 DATA 11111111</code></pre>
<pre><code>140 DATA 11111111</code></pre>
<pre><code>150 DATA 01110000</code></pre>
<pre><code>160 DATA 00110000</code></pre>
<pre><code>170 DATA 00010000</code></pre>
<p>Otro modo de crear un sprite usando DATA con valores binarios.</p>
<h3 id="ejemplo-5">Ejemplo 5</h3>
<pre><code>10 SCREEN 2,0</code></pre>
<pre><code>20 SPRITE$(0)=CHR$(16)+CHR$(48)+CHR$(112)+CHR$(255)+CHR$(255)+CHR$(112)+CHR$(48)+CHR$(16)</code></pre>
<pre><code>30 SPRITE$(1)=CHR$(224)+CHR$(192)+CHR$(128)+CHR$(0)+CHR$(0)+CHR$(128)+CHR$(192)+CHR$(224)</code></pre>
<pre><code>40 PUT SPRITE 0,(20,20),15,0</code></pre>
<pre><code>50 PUT SPRITE 1,(40,40),10,1</code></pre>
<pre><code>60 PUT SPRITE 2,(60,60),15,0</code></pre>
<pre><code>70 PUT SPRITE 3,(60,60),10,1</code></pre>
<pre><code>80 GOTO 80</code></pre>
<pre><code></code></pre>
<pre><code>Mezclando sprites.</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-6">Ejemplo 6</h3>
<pre><code></code></pre>
<pre><code>05 REM The Fifth Sprite Rule</code></pre>
<pre><code>10 SCREEN 2,0</code></pre>
<pre><code>20 SPRITE$(0)=STRING$(8,CHR$(255))</code></pre>
<pre><code>30 PUT SPRITE 0,(20,100),15,0</code></pre>
<pre><code>40 PUT SPRITE 1,(40,100),15,0</code></pre>
<pre><code>50 PUT SPRITE 2,(60,100),15,0</code></pre>
<pre><code>60 PUT SPRITE 3,(80,100),15,0</code></pre>
<pre><code>70 PUT SPRITE 4,(100,100),15,0</code></pre>
<pre><code>80 GOTO 80</code></pre>
<pre><code></code></pre>
<pre><code>La regla del quinto sprite. Que se pinta, pero no se ve.</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-7">Ejemplo 7</h3>
<pre><code></code></pre>
<pre><code>05 REM How To Animate your Sprites</code></pre>
<pre><code>10 SCREEN 2,1</code></pre>
<pre><code>20 SPRITE$(0)=CHR$(60)+CHR$(126)+CHR$(129)+CHR$(219)+CHR$(126)+CHR$(36)+CHR$(36)+CHR$(36)</code></pre>
<pre><code>30 SPRITE$(1)=CHR$(60)+CHR$(126)+CHR$(129)+CHR$(219)+CHR$(126)+CHR$(36)+CHR$(60)+CHR$(129) </code></pre>
<pre><code>40 PUT SPRITE 0,(100,100),11,0</code></pre>
<pre><code>50 FOR I=1 TO 500:NEXT</code></pre>
<pre><code>60 PUT SPRITE 0,(100,100),11,1</code></pre>
<pre><code>70 FOR I=1 TO 500:NEXT</code></pre>
<pre><code>80 GOTO 40</code></pre>
<pre><code></code></pre>
<pre><code>Un ejempo de animación de un sprite con dos frames (fotogramas).</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-8">Ejemplo 8</h3>
<pre><code></code></pre>
<pre><code>05 REM Two planets orbiting a Sun</code></pre>
<pre><code>10 SCREEN 2,0</code></pre>
<pre><code>20 COLOR 15,1,1</code></pre>
<pre><code>30 CLS</code></pre>
<pre><code>40 SPRITE$(0)=CHR$(126)+STRING$(6,CHR$(255))+CHR$(126)</code></pre>
<pre><code>50 SPRITE$(1)=STRING$(3,CHR$(0))+CHR$(24)+CHR$(24)+STRING$(3,CHR$(0))</code></pre>
<pre><code>60 FOR I=0 TO 6.28 STEP 0.2</code></pre>
<pre><code>70 X=X+1.5</code></pre>
<pre><code>80 Y=Y+1</code></pre>
<pre><code>90 X1=30*COS(I)</code></pre>
<pre><code>100 Y1=30*SIN(I)</code></pre>
<pre><code>110 X2=15*COS(I)</code></pre>
<pre><code>120 Y2=15*SIN(I)</code></pre>
<pre><code>130 PUT SPRITE 0,(X,Y),11,0</code></pre>
<pre><code>140 PUT SPRITE 1,(X1+X,Y1+Y),9,1</code></pre>
<pre><code>150 PUT SPRITE 2,(X2+X,Y2+Y),15,1</code></pre>
<pre><code>160 NEXT</code></pre>
<pre><code>170 GOTO 60</code></pre>
<pre><code></code></pre>
<pre><code>Una pequeña animación de tres sprites simulando un sol y dos planetas orbitando.</code></pre>
<pre><code></code></pre>
<h3 id="ejemplo-9">Ejemplo 9</h3>
<pre><code></code></pre>
<pre><code>10 COLOR 15,4,7</code></pre>
<pre><code>20 SCREEN 1,0</code></pre>
<pre><code>30 CLS:KEY OFF</code></pre>
<pre><code>40 FOR L=0 TO 4</code></pre>
<pre><code>50 FOR I=1 TO 8</code></pre>
<pre><code>60 READ D$(L)</code></pre>
<pre><code>70 S$(L)=S$(L)+CHR$(VAL(&quot;&amp;B&quot;+D$(L)))</code></pre>
<pre><code>80 NEXT I</code></pre>
<pre><code>90 SPRITE$(L)=S$(L)</code></pre>
<pre><code>100 NEXT L</code></pre>
<pre><code>110 PUT SPRITE 0,(120,90),15,0</code></pre>
<pre><code>120 FOR I=0 TO L-1</code></pre>
<pre><code>130 PUT SPRITE 0,STEP(2,0),15,I</code></pre>
<pre><code>140 FOR T=1 TO 20:NEXT</code></pre>
<pre><code>150 NEXT I:GOTO 120</code></pre>
<pre><code>160 DATA 00001000</code></pre>
<pre><code>170 DATA 00001000</code></pre>
<pre><code>180 DATA 00011100</code></pre>
<pre><code>190 DATA 00101000</code></pre>
<pre><code>200 DATA 00001100</code></pre>
<pre><code>210 DATA 00001010</code></pre>
<pre><code>220 DATA 00010010</code></pre>
<pre><code>230 DATA 00010000</code></pre>
<pre><code>240 REM</code></pre>
<pre><code>250 REM</code></pre>
<pre><code>260 DATA 00001000</code></pre>
<pre><code>270 DATA 00001000</code></pre>
<pre><code>280 DATA 00011100</code></pre>
<pre><code>290 DATA 00001010</code></pre>
<pre><code>300 DATA 00001000</code></pre>
<pre><code>310 DATA 00010100</code></pre>
<pre><code>320 DATA 00010010</code></pre>
<pre><code>330 DATA 00000010</code></pre>
<pre><code>340 REM</code></pre>
<pre><code>350 REM</code></pre>
<pre><code>360 DATA 00001000</code></pre>
<pre><code>370 DATA 00001000</code></pre>
<pre><code>380 DATA 00011110</code></pre>
<pre><code>390 DATA 00001000</code></pre>
<pre><code>400 DATA 00001000</code></pre>
<pre><code>410 DATA 00110100</code></pre>
<pre><code>420 DATA 00000100</code></pre>
<pre><code>430 DATA 00000100</code></pre>
<pre><code>440 REM</code></pre>
<pre><code>450 REM </code></pre>
<pre><code>460 DATA 00001000</code></pre>
<pre><code>470 DATA 00001000</code></pre>
<pre><code>480 DATA 00001100</code></pre>
<pre><code>490 DATA 00001010</code></pre>
<pre><code>500 DATA 00000100</code></pre>
<pre><code>510 DATA 00000100</code></pre>
<pre><code>520 DATA 00000100</code></pre>
<pre><code>530 DATA 00001000</code></pre>
<pre><code>540 REM</code></pre>
<pre><code>550 REM</code></pre>
<pre><code>560 DATA 00001000</code></pre>
<pre><code>570 DATA 00001000</code></pre>
<pre><code>580 DATA 00001100</code></pre>
<pre><code>590 DATA 00001000</code></pre>
<pre><code>600 DATA 00010100</code></pre>
<pre><code>610 DATA 00000100</code></pre>
<pre><code>620 DATA 00001000</code></pre>
<pre><code>630 DATA 00010000</code></pre>
<pre><code></code></pre>
<pre><code>En este ejemplo, tenemos un sprite en movimiento usando cinco frames y en SCREEN 1.</code></pre>
<pre><code></code></pre>
<pre><code>Ejemplo</code></pre>
<pre><code></code></pre>
<pre><code>Code</code></pre>
<pre><code></code></pre>
<pre><code>Description</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="read">READ</h2>
<p>Lee los datos especificados por una instrucción DATA.</p>
<p>Lee los datos secuencialmente, empezando por el primer dato de la instrucción DATA de número de línea más bajo del programa, y los asigna secuencialmente a variables de la instrucción READ.</p>
<p>Cuando en una instrucción READ hay más de una variable numérica o de cadena, van separadas por comas.</p>
<p>El tipo de variable debe coincidir con el dato correspondiente.</p>
<pre><code>10 READ A, B, C, D$, E$
20 PRINT A, B, C, D$, E$
100 DATA 5, 10, 20, ABC, XYZ</code></pre>
<p>Cuando en un programa hay varias instrucciones READ, la segunda instrucción READ comienza a leer el dato siguiente al último dato leído por la anterior instrucción READ.</p>
<p>La ejecución de una instrucción RESTORE hace que la lectura de la instrucción READ ejecutada a continuación vaya a la instrucción DATA de número más pequeño después del número de línea especificado por la instrucción RESTORE.</p>
<h3 id="versión-158">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-157">Formato</h3>
<pre><code>READ variable[,variable][,variable]</code></pre>
<h3 id="parámetros-139">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Numérica o de cadena.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-110">Ejemplos</h3>
<pre><code>10 READ A, B, C
20 READ D$, E$
30 PRINT A; B; C; D$; E$
100 DATA 10, 20, 30, ABC, DEF
RUN
 10 20 30 ABCDEF</code></pre>
<h2 id="rem">REM</h2>
<p>Inserta un comentario en un programa.</p>
<p>La instrucción REM sirve para insertar un comentario con vistas a facilitar la lectura del listado del programa.</p>
<h3 id="versión-159">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-158">Formato</h3>
<pre><code>REM comentario</code></pre>
<h3 id="ejemplos-111">Ejemplos</h3>
<div class="line-block">10 REM MUSIC | Aunque en el listado del programa aparece la instrucción REM, al ejecutar el programa se ignora esta línea. |<br />
20 PLAY “T60CEGEC1” | |</div>
<p>|—————————————————–|————————————————————————————————————-| | 10 ’ MUSIC | En vez de escribir REM, se puede poner apóstrofe (‘) | | 20 PLAY “T60CEGEC1” | | | 10 PRINT “MSX” : REM Output | Es obligatorio escribir los dos puntos (:) cuando se utiliza una sentencia REM junto con otra instrucción. | | 20 PRINT “HI” :’ Output | |</p>
<pre><code>RUN
MSX
HI</code></pre>
<pre><code></code></pre>
<h2 id="renum">RENUM</h2>
<p>Renumera las líneas de un programa.</p>
<p>Sirve para volver a numerar las líneas tras una corrección del programa.</p>
<p>La instrucción RENUM renumera correctamente los números de línea a los que se salta o a los que se hace referencia en las instrucciones RETURN, RESUME, RESTORE, GOTO y GOSUB. De todas formas, si el número de línea especificado al que se hace referencia con alguna de estas instrucciones no existe en el momento de la ejecución de la instrucción RENUM, no cambia ese número de línea y por lo tanto se producirá un error.</p>
<h3 id="versión-160">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-159">Formato</h3>
<pre><code>RENUM [nuevo número de línea inicial ][,antiguo número de línea inicial][,incremento]</code></pre>
<h3 id="parámetros-140">Parámetros</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Nuevo número de línea inicial</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65539. <strong>Omit.</strong> 10.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Antiguo número de línea inicial</td>
<td><strong>Cond.</strong> Constantes enteras, 0≤número≤65529. <strong>Omit.</strong> Número de línea más bajo antes de la ejecución.</td>
</tr>
<tr class="even">
<td>Incremento</td>
<td><strong>Cond.</strong> Constantes enteras, 0≤número≤65529. <strong>Omit.</strong> 10.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-112">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>RENUM</th>
<th>Renumera todas las líneas a partir de la 10 con un incremento de 10.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RENUM 100,,100</td>
<td>Renumera todas las líneas que comienzan a partir de 100 con incrementos de 100.</td>
</tr>
<tr class="even">
<td>RENUM 100</td>
<td>Renumera todas las líneas con números que empiezan por el 100, con incrementos de 10.</td>
</tr>
<tr class="odd">
<td>RENUM 100, 38, 20</td>
<td>Renumera la línea 38 y siguientes con números de línea que comienzan por el 100, con incrementos de 20.</td>
</tr>
</tbody>
</table>
<h2 id="restore">RESTORE</h2>
<p>Especifica la instrucción DATA que será leída por una instrucción READ.</p>
<p>La instrucción RESTORE sirve para leer varias veces los mismos datos.</p>
<p>La ejecución de la instrucción RESTORE hace que la siguiente instrucción READ empiece a leer datos a partir de la instrucción DATA con el número de línea más bajo siguiente al número de línea especificado en la instrucción RESTORE.</p>
<h3 id="versión-161">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-160">Formato</h3>
<pre><code>RESTORE [número de línea]</code></pre>
<h3 id="parámetros-141">Parámetros</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529. <strong>Omit.</strong> Instrucción DATA con el número de línea más bajo.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-113">Ejemplos</h3>
<pre><code>10 READ A, B, C
20 READ D, E, F
30 RESTORE 110
40 READ G, H, I
50 PRINT A; B; C; D; E; F; G; H; I;
100 DATA 10, 20, 30
110 DATA 40, 50, 60
RUN
 10   20   30   40   50   60   40   50   60</code></pre>
<h2 id="resume">RESUME</h2>
<p>Devuelve la ejecución al programa principal tras la ejecución de una rutina de proceso de errores.</p>
<h3 id="versión-162">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-161">Formato</h3>
<pre><code>RESUME { 0 | número de línea | NEXT }</code></pre>
<h3 id="parámetros-142">Parámetros</h3>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes enteras, 0≤número≤65529. <strong>Omit.</strong> Línea donde haya ocurrido el error.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-114">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>RESUME 0 or RESUME</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Devuelve la ejecución a la sentencia donde se haya producido el error.</p>
<table>
<thead>
<tr class="header">
<th>RESUME 100</th>
<th>Devuelve la ejecución a la línea 100.</th>
<th></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>(Ver el programa ejemplo de ON ERROR GOTO).</p>
<h2 id="right">RIGHT$</h2>
<p>Ofrece un número determinado de caracteres, en forma de datos alfanuméricos, tomados a partir del extremo derecho de una cadena de caracteres.</p>
<h3 id="versión-163">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-162">Formato</h3>
<pre><code>RIGHT$ (X$, N)</code></pre>
<h3 id="parámetros-143">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>N</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;256.</td>
</tr>
</tbody>
</table>
<h3 id="retorno-37">Retorno</h3>
<p>Tipo cadena.</p>
<h3 id="ejemplos-115">Ejemplos</h3>
<div class="line-block">PRINT RIGHT$ (“HIT-BIT”, 3) |<br />
BIT |</div>
<p>|———————————|</p>
<pre><code></code></pre>
<div class="line-block">PRINT RIGHT$ (“HIT-BIT”, 5.3) | Cuando N no es un valor entero, omite las cifras siguientes a la coma decimal. | |<br />
T-BIT | | |</div>
<p>|————————————-|——————————————————————————–|—| | PRINT RIGHT$ (“HIT-BIT”, 0) | Cuando N es 0 da una cadena nula. | | | Ok | | |</p>
<pre><code></code></pre>
<h2 id="rnd">RND</h2>
<p>Ofrece un número aleatorio positivo menor que 1 (incluyendo el 0).</p>
<p>Este comando admite un parámetro X que admitirá valores enteros. Según este valor, tendremos las siguientes funcionalidades:</p>
<p><strong>Cuando X es negativo</strong></p>
<p>Usará X como semilla de generación de números aleatorios. Esto quiere decir que, a partir de una semilla, se genera siempre la misma secuencia de números aleatorios, y esta secuencia será distinta para diferentes semillas.</p>
<p><strong>Cuando X es mayor que 0</strong></p>
<p>Genera siempre números aleatorios en la misma secuencia utilizando la semilla de generación que haya establecida.</p>
<p><strong>Cuando X es 0</strong></p>
<p>Se obtendrá el mismo valor que el generado anteriormente.</p>
<h3 id="versión-164">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-163">Formato</h3>
<pre><code>RND(X)</code></pre>
<h3 id="parámetros-144">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-38">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-116">Ejemplos</h3>
<pre><code>10 PRINT RND (1)
20 PRINT RND (0)
30 PRINT RND (-1)
40 PRINT RND (0)
RUN
 .59521943994623
 .59521943994623
 .04389820420821
 .04389820420821</code></pre>
<h2 id="rset">RSET</h2>
<p>Escribe datos en un registro de un fichero de acceso aleatorio alineándolos a la derecha.</p>
<p>Pone los datos de cada variable en el registro especificado por la instrucción FIELD como preparación para la escritura de datos en un fichero de acceso aleatorio mediante una instrucción PUT. La instrucción RSET alinea los datos en el lado derecho del registro; si el dato es más corto que la longitud de la variable especificada, rellena con espacios en blanco los sitios vacíos; si el dato es más largo que el espacio especificado, ignorará la parte derecha del dato de cadena.</p>
<p>Al organizar los datos numéricos, pasa primero los datos a cadenas mediante las funciones MKI$, MKS$ y MKD$.</p>
<h3 id="versión-165">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-164">Formato</h3>
<pre><code>RSET variable de cadena = expresión de cadena</code></pre>
<h3 id="parámetros-145">Parámetros</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable de cadena</th>
<th><strong>Cond.</strong> Variable de cadena.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión de cadena</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-117">Ejemplos</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>RSET A$ = X$</th>
<th>Pone el dato de cadena X$ en la variable A$ del registro.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RSET B$ = MKS$(N)</td>
<td>Pasa el dato numérico N a cadena asignándolo a la variable B$ del registro.</td>
</tr>
</tbody>
</table>
<h2 id="run">RUN</h2>
<ol type="1">
<li><p>Ejecuta un programa a partir de una línea especificada. La instrucción RUN pone todos los valores numéricos a 0, las variables alfanuméricas a cadena nula y las variables de matriz en una condición indefinida; luego ejecuta el programa.</p></li>
<li><p>Carga un fichero de disco o de la RAM-Disk y lo ejecuta. La ejecución de la instrucción RUN pone a 0 a todos los valores numéricos, a cadena nula las variables alfanuméricas, y en una condición indefinida las variables de matriz, y cierra todos los ficheros. Luego carga del disco especificado el programa especificado, y lo ejecuta.</p></li>
</ol>
<p>En ambos casos, tras completar la ejecución del programa, entra en el estado de espera de comandos.</p>
<p>Es posible pulsar la tecla STOP para detener temporalmente la ejecución del programa. La ejecución se reanuda pulsando STOP otra vez.</p>
<p>También se puede CTRL+STOP para interrumpir el programa. El programa se puede reanudar introduciendo la orden CONT.</p>
<h3 id="versión-166">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-165">Formato</h3>
<pre><code>1. RUN [número de línea]
2.   RUN &quot;[nombre de unidad]nombre de fichero[.extensión]&quot;[,R]</code></pre>
<h3 id="parámetros-146">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de línea</th>
<th><strong>Cond.</strong> Constantes de tipo entero, 0≤número≤65529.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre de unidad</td>
<td><strong>Cond.</strong> CRT:, GRP:, LPT: <strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H:, <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</td>
</tr>
<tr class="even">
<td>Nombre de fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 caracteres o menos. Una cadena de 8 caracteres o menos. <strong>Omit.</strong> Una cadena nula (no se puede omitir el nombre de fichero cuando se trabaja con discos flexibles o con RAM-Disk).</td>
</tr>
<tr class="odd">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 o menos caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
<tr class="even">
<td>Opción R</td>
<td><strong>Omit.</strong> Cierra todos los ficheros de datos.</td>
</tr>
</tbody>
</table>
<h2 id="save">SAVE</h2>
<p>Almacena un programa VR-BASIC en el dispositivo especificado.</p>
<p>Cuando se especifica CAS: como nombre de dispositivo, almacena el programa VR-BASIC de memoria en la cinta casete en formato ASCII.</p>
<p>Cuando se especifica una unidad de discos (por ejemplo A:, o B:), almacena el programa en el formato ASCII cuando se especifica la opción A, y en formato binario cuando se omite la opción A.</p>
<p>La instrucción CSAVE sirve para almacenar un programa en cinta de casete en formato binario.</p>
<h3 id="versión-167">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-166">Formato</h3>
<pre><code>SAVE &quot;[nombre de unidad][nombre de fichero[.extensión]]&quot; [,A]</code></pre>
<h3 id="parámetros-147">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Nombre de unidad</th>
<th><strong>Cond.</strong> CRT:, GRP:, LPT: <strong>Cond.</strong> CAS: <strong>Cond.</strong> A:, B:, C:, D:, E:, F:, G:, H:, <strong>Cond.</strong> &lt;unidad&gt;: en el MSXVR. <strong>Cond.</strong> MEM: <strong>Omit.</strong> Unidad de disco actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Nombre de fichero</td>
<td><strong>Cond.</strong> Una cadena de 6 caracteres o menos. Una cadena de 8 caracteres o menos. <strong>Omit.</strong> Una cadena nula (no se puede omitir el nombre de fichero cuando se trabaja con discos flexibles o con RAM-Disk).</td>
</tr>
<tr class="even">
<td>Extensión</td>
<td><strong>Cond.</strong> Una cadena de 3 o menos caracteres. <strong>Omit.</strong> Una cadena nula.</td>
</tr>
<tr class="odd">
<td>Opción A</td>
<td><strong>Omit.</strong> Almacena el programa en formato binario.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-118">Ejemplos</h3>
<pre><code>SAVE &quot;CAS:PROG2&quot;
 SAVE &quot;PROG2&quot;, A</code></pre>
<p>El programa a fusionar con un programa en memoria mediante la instrucción MERGE, se debe almacenar en formato ASCII. Los programas se almacenan en la RAM-Disk en formato ASCII.</p>
<h2 id="screen">SCREEN</h2>
<p>Establece el modo de visualización de pantalla, el tamaño de los sprites, la activación o no del sonido de las teclas, la velocidad de transmisión del casete (en baudios), el modo de entrelazado, y el tipo de impresora.</p>
<p><strong>Modos</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor</th>
<th>Modo</th>
<th>Compatible</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0*</td>
<td>Modo texto; 40 caracteres x 24 líneas u 80 caracteres</td>
<td>1,2,2+,TR,VR</td>
</tr>
<tr class="even">
<td>1</td>
<td>Modo texto; 32 caracteres x 24 líneas</td>
<td>1,2,2+,TR,VR</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Modo patrón 256 x 192 - 16 colores</td>
<td>1,2,2+,TR,VR</td>
</tr>
<tr class="even">
<td>3</td>
<td>Modo multicolor; 64 x 48 - 16 colores</td>
<td>1,2,2+,TR,VR</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Modo patrón 256 x 192 + color sprites</td>
<td>2,2+,TR,VR</td>
</tr>
<tr class="even">
<td>5</td>
<td>Modo bitmap 256x212 - 16 de 512 colores</td>
<td>2,2+,TR,VR</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Modo bitmap 512x212 - 4 de 512 colores</td>
<td>2,2+,TR,VR</td>
</tr>
<tr class="even">
<td>7</td>
<td>Modo bitmap 512x212 - 16 de 512 colores</td>
<td>2,2+,TR,VR</td>
</tr>
<tr class="odd">
<td>8</td>
<td>Modo bitmap 256x212 - 256 colores</td>
<td>2,2+,TR,VR</td>
</tr>
<tr class="even">
<td>9</td>
<td>Reservado</td>
<td></td>
</tr>
<tr class="odd">
<td>10</td>
<td>Modo bitmap 256x212 - 16 de 512 colores + 12499 YAE</td>
<td>2+,TR,VR</td>
</tr>
<tr class="even">
<td>11</td>
<td>Modo bitmap 256x212 - 16 de 512 colores + 12499 YAE</td>
<td>2+,TR,VR</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Modo bitmap 256x212 - 19268 YJK</td>
<td>2+,TR,VR</td>
</tr>
<tr class="even">
<td>13</td>
<td>Modo bitmap 256x212 - 256 de 16.7M colores</td>
<td>VR</td>
</tr>
</tbody>
</table>
<p>* Si la anchura especificada en la instrucción WIDTH es 40 caracteres o menos, se selecciona el modo texto de 40 caracteres x 24 líneas, y si la anchura es 41 caracteres o más selecciona el modo texto de 80 caracteres x 24 líneas.</p>
<p><strong>Tamaño del sprite</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor especificado</th>
<th>Tamaño</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>8 x 8 puntos</td>
</tr>
<tr class="even">
<td>1</td>
<td>8 x 8 puntos ampliado</td>
</tr>
<tr class="odd">
<td>2</td>
<td>16 x 16 puntos</td>
</tr>
<tr class="even">
<td>3</td>
<td>16 x 16 puntos ampliado</td>
</tr>
</tbody>
</table>
<p><strong>Interruptor del sonido de las teclas</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor especificado</th>
<th>Clic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>NO</td>
</tr>
<tr class="even">
<td>Distinto de 0 (entre 1 y 255)</td>
<td>SI</td>
</tr>
</tbody>
</table>
<p><strong>Velocidad de transmisión (baudios)</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor especificado</th>
<th>Velocidad (baudios)*</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1200 baudios</td>
</tr>
<tr class="even">
<td>2</td>
<td>2400 baudios</td>
</tr>
</tbody>
</table>
<p>* Velocidad en baudios del interfaz de casete.</p>
<p><strong>Tipo de impresora</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor especificado</th>
<th>Impresora</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Impresora MSX*</td>
</tr>
<tr class="even">
<td>Distinto de 0 (entre 1 y 255)</td>
<td>Impresora no MSX**</td>
</tr>
</tbody>
</table>
<p>* Impresora con caracteres gráficos compatible con ordenadores MSX.</p>
<p>** Las impresoras no-MSX convierten los caracteres gráficos en espacios en blanco.</p>
<p><strong>Modo de entrelazado</strong></p>
<table>
<thead>
<tr class="header">
<th>Valor especificado</th>
<th>Entrelazado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Normal</td>
</tr>
<tr class="even">
<td>1</td>
<td>Entrelazado</td>
</tr>
<tr class="odd">
<td>2*</td>
<td>Par/impar</td>
</tr>
<tr class="even">
<td>3*</td>
<td>Par/impar, entrelazado</td>
</tr>
</tbody>
</table>
<p>* La página de visualización debe ser una página de número impar. Presenta alternativamente la página de visualización y la página de número inmediatamente inferior a la página de visualización.</p>
<p><strong>Valores iniciales y especificaciones por omisión</strong></p>
<p>En caso de omisión de una especificación, no cambia el modo actual, pero si se omiten todas las especificaciones, no se ejecutará la instrucción SCREEN.</p>
<p>Los valores iniciales (en la puesta en marcha del VR-BASIC) se pueden cambiar con una instrucción SET SCREEN. En cualquier caso, los valores iniciales seleccionados en fábrica son:</p>
<p>Modo: modo texto de 40 caracteres x 24 líneas (WIDTH 37).</p>
<p>Tamaño del sprite: 8 x 8 puntos.</p>
<p>Interruptor de sonido de las teclas: Sí.</p>
<p>Velocidad de transmisión en baudios: 1200 baudios.</p>
<p>Tipo de impresora: Impresora MSX.</p>
<p>Modo de entrelazado: Normal.</p>
<h3 id="versión-168">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-167">Formato</h3>
<pre><code>SCREEN [modo][,tamaño del sprite][,interruptor de chasquido de teclas][,velocidad de transmisión en baudios][,tipo de impresora][,modo de entrelazado]</code></pre>
<h3 id="parámetros-148">Parámetros</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤modo≤13. <strong>Omit.</strong> Modo actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tamaño del sprite</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤tamaño&lt;4. <strong>Omit.</strong> Tamaño actual.</td>
</tr>
<tr class="even">
<td>Interruptor de chasquido de teclas</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤interruptor&lt;256. <strong>Omit.</strong> Estado actual.</td>
</tr>
<tr class="odd">
<td>Velocidad en baudios</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤velocidad&lt;3. <strong>Omit.</strong> Velocidad actual.</td>
</tr>
<tr class="even">
<td>Tipo de impresora</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤tipo&lt;256. <strong>Omit.</strong> Tipo de impresora actual.</td>
</tr>
<tr class="odd">
<td>Modo de entrelazado</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤modo&lt;4. <strong>Omit.</strong> Modo actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-119">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>10 SCREEN 0,, 1</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Modo texto de 40 caracteres x 24 líneas, teclas con el sonido activado.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 47%" />
<col style="width: 2%" />
</colgroup>
<thead>
<tr class="header">
<th>10 SCREEN ,,, 2</th>
<th>Especificación de la velocidad de 2400 baudios.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10 SCREEN 2, 3</td>
<td>Modo alta resolución; el sprite es de 16x16 puntos ampliados.</td>
<td></td>
</tr>
<tr class="even">
<td>10 SCREEN 2</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>20 FOR I = 0 TO 255</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>30 PSET (I, 100)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>40 NEXT I</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>50 GOTO 50</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Al final de un programa la pantalla vuelve al modo texto (SCREEN 0 o 1). Para seguir en el modo gráfico hay que añadir al final del programa una instrucción que mantenga el ordenador en este estado, como es el caso de la línea 50 del programa anterior. Esta línea mantiene el programa en ejecución; para poner término a la ejecución, se debe pulsar CRTL+STOP.</p>
<p>Un ejemplo de cómo mostrar texto en distintos modos gráficos:</p>
<pre><code>10 FOR M=0 TO 3</code></pre>
<pre><code>20 SCREEN M</code></pre>
<pre><code>30 IF M&lt;2 THEN OPEN &quot;CRT:&quot; AS #1 ELSE OPEN &quot;GRP:&quot; AS #1</code></pre>
<pre><code>40 PRINT#1,&quot;THIS IS MODE &quot;;M</code></pre>
<pre><code>50 IF NOT STRIG(0) THEN 50</code></pre>
<pre><code>60 CLOSE#1</code></pre>
<pre><code>70 NEXT M</code></pre>
<pre><code></code></pre>
<h2 id="set-adjust">SET ADJUST</h2>
<p>Ajusta la posición de la imagen en la pantalla.</p>
<p>Los valores positivos producen el desplazamiento correspondiente de la coordenada X hacia la derecha y de la coordenada Y hacia abajo, cambiando la posición de la imagen la pantalla. Los valores por omisión son 0 para las dos coordenadas.</p>
<h3 id="versión-169">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-168">Formato</h3>
<pre><code>SET ADJUST (coordenada X, coordenada Y)</code></pre>
<h3 id="parámetros-149">Parámetros</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Coordenada X, coordenada Y</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), -8≤coordenada&lt;9.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-120">Ejemplos</h3>
<pre><code>SET ADJUST (8, 8)</code></pre>
<pre><code>SET ADJUST (0, 0)</code></pre>
<h2 id="set-beep">SET BEEP</h2>
<p>Selecciona el tipo de pitido.</p>
<p>Hay cuatro sonidos diferentes disponibles.</p>
<p>Especificando el volumen 1 se selecciona el nivel de volumen más bajo, y especificando el volumen 4 se selecciona el nivel de volumen más alto.</p>
<h3 id="versión-170">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-169">Formato</h3>
<pre><code>SET BEEP [sonido],volumen</code></pre>
<h3 id="parámetros-150">Parámetros</h3>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>Sonido</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 1≤sonido&lt;5. <strong>Omit.</strong> 1.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Volumen</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 1≤volumen&lt;5.</td>
</tr>
</tbody>
</table>
<h2 id="set-date">SET DATE</h2>
<p>Ajusta la fecha en el reloj interno.</p>
<p>El formato es DD/MM/AA; DD es el número correspondiente al día, MM el número correspondiente al mes, y AA el número correspondiente al año.</p>
<p>Cuando se especifica A se puede programar la alarma.</p>
<p>Cuando se ejecuta SET TIME X$, A, se borrará la fecha seleccionada para la alarma. Para ajustar la fecha y la hora de la alarma, se debe ejecutar en primer lugar SET TIME y después SET DATE.</p>
<h3 id="versión-171">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-170">Formato</h3>
<pre><code>SET DATE &quot;T$&quot; [,A]</code></pre>
<h3 id="parámetros-151">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>T$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td><strong>Omit.</strong> Fecha actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-121">Ejemplos</h3>
<pre><code>10 T$ = &quot;15/05/17&quot;
20 SET DATE T$
30 PRINT T$</code></pre>
<h2 id="set-page">SET PAGE</h2>
<p>Selecciona la página de escritura de datos y la página de presentación en pantalla cuando se opera con múltiples páginas de RAM de vídeo.</p>
<p>Válida únicamente para SCREEN 5 hasta SCREEN 13.</p>
<p>La página donde se escriben los datos recibe el nombre de página activa y la página que en un determinado momento se muestra en pantalla recibe el nombre de página de visualización.</p>
<table>
<thead>
<tr class="header">
<th>Número de páginas disponibles según modo de pantalla y cantidad de VRAM</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SCREEN</td>
<td>64 KB</td>
<td>128KB</td>
<td>512KB</td>
</tr>
<tr class="even">
<td>5</td>
<td>0-1</td>
<td>0-3</td>
<td>0-15</td>
</tr>
<tr class="odd">
<td>6</td>
<td>0-1</td>
<td>0-3</td>
<td>0-15</td>
</tr>
<tr class="even">
<td>7</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
<tr class="odd">
<td>8</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
<tr class="even">
<td>10</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
<tr class="odd">
<td>11</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
<tr class="even">
<td>12</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
<tr class="odd">
<td>13</td>
<td>No disponible</td>
<td>0-1</td>
<td>0-7</td>
</tr>
</tbody>
</table>
<h3 id="versión-172">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-171">Formato</h3>
<pre><code>SET PAGE [página de visualización],[página activa]</code></pre>
<h3 id="parámetros-152">Parámetros</h3>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>Página de visualización, página activa</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤página&lt;4 (con &lt;= 128Kb VRAM). <em>Este número podrá ser mayor en caso de disponer de más VRAM y un MSXVR</em>.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-122">Ejemplos</h3>
<pre><code>100 SCREEN 5
110 SET PAGE 0, 1 :CLS
120 LINE (70, 50)- (170, 150),, BF
130 SET PAGE 0, 0
140 LINE (60, 60)-(180, 140),, BF
150 DP = 0 : AP = 1
160 SET PAGE DP, AP: SWAP DP, AP
170 FOR I = 0 TO 100 : NEXT I
180 GOTO 160</code></pre>
<h2 id="set-password">SET PASSWORD</h2>
<p>Selecciona la contraseña del sistema.</p>
<p>Si hay una contraseña seleccionada, el ordenador pedirá la introducción de esa contraseña al ser conectado. Si se introduce correctamente, el sistema funcionará con normalidad, pero si se introduce erróneamente, el sistema no pasará de ese punto y seguirá solicitando la introducción de la contraseña correcta. La selección de una contraseña impide que extraños pongan en marcha el sistema.</p>
<p>En caso de olvido de la contraseña, cabe la posibilidad de poner en marcha el sistema manteniendo pulsadas las teclas GRAPH y STOP mientras se pulsa el botón RESET.</p>
<h3 id="versión-173">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-172">Formato</h3>
<pre><code>SET PASSWORD &quot;contraseña&quot;</code></pre>
<h3 id="parámetros-153">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Contraseña</th>
<th><strong>Cond.</strong> Una cadena de hasta 255 caracteres.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="set-prompt">SET PROMPT</h2>
<p>Especifica el mensaje (prompt) que se visualizará en pantalla cuando el VR-BASIC entre en el estado de espera de comandos.</p>
<h3 id="versión-174">Versión</h3>
<p>MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-173">Formato</h3>
<pre><code>SET PROMPT &quot;mensaje&quot;</code></pre>
<h3 id="parámetros-154">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>Mensaje</th>
<th><strong>Cond.</strong> Una cadena de 32 caracteres o menos.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="set-screen">SET SCREEN</h2>
<p>Registra los valores actuales seleccionados por las instrucciones SCREEN, COLOR, WIDTH y KEY ON/OFF como valores iniciales de puesta en marcha.</p>
<p>Los valores que pueden seleccionarse para la inicialización son:</p>
<table>
<thead>
<tr class="header">
<th>Screen (modo texto)</th>
<th>0 / 1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Anchura de la imagen (modo texto)</td>
<td>1 a 80</td>
</tr>
<tr class="even">
<td>Color del primer plano</td>
<td>1 a 15</td>
</tr>
<tr class="odd">
<td>Color del fondo</td>
<td>1 a 15</td>
</tr>
<tr class="even">
<td>Color del borde</td>
<td>1 a 15</td>
</tr>
<tr class="odd">
<td>Conmutador de las teclas de función</td>
<td>Encendido / Apagado</td>
</tr>
<tr class="even">
<td>Sonido de las teclas</td>
<td>Encendido / Apagado</td>
</tr>
<tr class="odd">
<td>Impresora</td>
<td>MSX o no-MSX</td>
</tr>
<tr class="even">
<td>Velocidad de transmisión (en baudios)</td>
<td>1200 o 2400</td>
</tr>
<tr class="odd">
<td>Modo de entrelazado</td>
<td>0 a 3</td>
</tr>
</tbody>
</table>
<h3 id="versión-175">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-174">Formato</h3>
<pre><code>SET SCREEN</code></pre>
<h2 id="set-scroll">SET SCROLL</h2>
<p>Aplicar un desplazamiento horizontal y/o vertical sobre el contenido de la pantalla tanto en modos de texto como gráfico. La actualización de los registros de desplazamiento no se aplica hasta que la pantalla se ha refrescado por completo.</p>
<p>El <strong>modo máscara</strong> permite indicar que ocurre con los pixeles de la parte izquierda de la pantalla. Si este parámetro vale 0, los pixeles se muestran y en caso de ser 1 se ocultan. En los modos de pantalla 5, 8, 10, 11, 12 y 13 son 8 pixeles, y en los modos 6 y 7 son 16 pixeles.</p>
<p>El <strong>modo página</strong> especifica si se quiere usar una sola página o dos de forma secuencial para los modos de pantalla 5, 6, 7, 8, 10, 11, 12 y 13.</p>
<h3 id="versión-176">Versión</h3>
<p>MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-175">Formato</h3>
<pre><code>SET SCROLL [X], [Y], [Modo Máscara], Modo Página</code></pre>
<h3 id="parámetros-155">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤X&lt;511. <strong>Omit.</strong> El último valor especificado. Inicialmente es 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Y</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤X&lt;255. <strong>Omit.</strong> El último valor especificado. Inicialmente es 0.</td>
</tr>
<tr class="even">
<td>Modo Máscara</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤Modo&lt;1.</td>
</tr>
<tr class="odd">
<td>Modo Página</td>
<td><strong>Cond</strong>. Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤Modo&lt;1.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-123">Ejemplos</h3>
<pre><code>10 SCREEN 8:COLOR 15,1,1
20 CLS
30 Y=0:ANGLE=0:RAD=128
40 LINE (10,10)-(100,100),8,BF
50 SET SCROLL 0,Y,0,0
60 Y=RAD+SIN(ANGLE)*RAD
70 ANGLE=ANGLE+0.2
80 IF RAD&gt;0 THEN RAD=RAD-1
90 GOTO 50</code></pre>
<h2 id="set-time">SET TIME</h2>
<p>Pone el reloj en hora.</p>
<p>El formato es HH:MM:SS; donde HH es la hora, MM los minutos y SS los segundos.</p>
<p>Cuando se especifica A, se puede programar la alarma.</p>
<p>Cuando se ejecuta SET TIME X$ se borra la fecha de la alarma. Para poner la fecha y la hora de activación de la alarma, se debe ejecutar en primer lugar SET TIME y luego SET DATE.</p>
<h3 id="versión-177">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-176">Formato</h3>
<pre><code>SET TIME &quot;X$&quot; [,A]</code></pre>
<h3 id="parámetros-156">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td><strong>Omit.</strong> Hora actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-124">Ejemplos</h3>
<pre><code>10 X$ = &quot;11:00:00&quot;
20 SET TIME X$
30 PRINT X$</code></pre>
<h2 id="set-title">SET TITLE</h2>
<p>Selecciona el título a presentar en pantalla cuando se pone en marcha el ordenador. También podemos establecer el color del mismo.</p>
<h3 id="versión-178">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-177">Formato</h3>
<pre><code>SET TITLE [&quot;título&quot;],[color]</code></pre>
<h3 id="parámetros-157">Parámetros</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Título</th>
<th><strong>Cond.</strong> Una cadena de 256 o menos caracteres. <strong>Omit.</strong> La cadena de caracteres actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Color</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤color &lt;15. <strong>Omit.</strong> El color actual.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-125">Ejemplos</h3>
<pre><code>SET TITLE &quot;Es el ordenador de Juan&quot;</code></pre>
<h2 id="set-video">SET VIDEO</h2>
<p>Especifica los modos de trabajo relativos a superposición de imágenes de vídeo, mezcla de sonidos, etc. NOTA: Para poder usar este comando, el sistema debe disponer de un mecanismo de adquisición de vídeo y audio externos.</p>
<p>Modo</p>
<table>
<thead>
<tr class="header">
<th><strong>Modo</strong></th>
<th><strong>S1</strong></th>
<th><strong>S0</strong></th>
<th><strong>TP</strong></th>
<th><strong>Sinc</strong></th>
<th><strong>Función</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>Interno</td>
<td>Ordenador</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>Externo</td>
<td>Ordenador</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>Externo</td>
<td>Sobreimpresión</td>
</tr>
<tr class="even">
<td>3</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>Externo</td>
<td>TV</td>
</tr>
</tbody>
</table>
<p>No se puede seleccionar el sinc externo en el modo 0.</p>
<p>En los modos 1-3 no se puede utilizar la salida compuesta del VDP, pero sí se puede utilizar la salida RGB analógica.</p>
<p>YM: 0: Brillo normal</p>
<p>1: Reducción del brillo de la TV a la mitad.</p>
<p>CB: 0: Bus de color del VDP en estado de salida.</p>
<p>1: Bus de color del VDP en estado de entrada.</p>
<p>Sinc: 0: Sinc interno.</p>
<p>1: Sinc externo.</p>
<p>Sonido</p>
<table>
<thead>
<tr class="header">
<th><strong>Sonido</strong></th>
<th><strong>Función</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Señal de sonido externa no mezclada</td>
</tr>
<tr class="even">
<td>1</td>
<td>Señal de sonido externa del canal derecho mezclada</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Señal de sonido externa del canal izquierdo mezclada</td>
</tr>
<tr class="even">
<td>3</td>
<td>Señal de sonido externa de ambos canales mezclada</td>
</tr>
</tbody>
</table>
<p>Entrada de vídeo</p>
<p>0: Selecciona la entrada del multiconector de RGB.</p>
<p>1: Selecciona la entrada del conector de entrada de vídeo.</p>
<p>Control/Audio/Vídeo</p>
<blockquote>
<p>Especifica la salida de señal de control del terminal de control AV del multiconector de RGB. Esta señal controla el circuito interno de la TV conectada al multiconector de RGB y sirve para superponer la imagen del ordenador sobre una imagen de vídeo.</p>
</blockquote>
<p>0: Selecciona la señal TV como vídeo de fondo.</p>
<blockquote>
<p>1: Selecciona una señal de vídeo externa, suministrada desde el ordenador, como vídeo de fondo.</p>
</blockquote>
<h3 id="versión-179">Versión</h3>
<p>MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-178">Formato</h3>
<pre><code>SET VIDEO [modo],[brillo],[colorbus],[sinc],[sonido],[entrada de vídeo],control AV</code></pre>
<h3 id="parámetros-158">Parámetros</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>Modo</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤modo&lt;4. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brillo</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤brillo&lt;2. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="even">
<td>Colorbus</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤colorbus&lt;2. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="odd">
<td>Sinc</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤sinc&lt;2. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="even">
<td>Sonido</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤sonido&lt;4. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="odd">
<td>Entrada de vídeo</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤entrada&lt;2. <strong>Omit.</strong> 0.</td>
</tr>
<tr class="even">
<td>Control AV</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas), 0≤control&lt;2. <strong>Omit.</strong> 1.</td>
</tr>
</tbody>
</table>
<h2 id="sgn">SGN</h2>
<p>Devuelve un 1 cuando el dato numérico es positivo, un 0 cuando es 0, y un -1 cuando es negativo.</p>
<h3 id="versión-180">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-179">Formato</h3>
<pre><code>SGN(X)</code></pre>
<h3 id="parámetros-159">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-39">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-126">Ejemplos</h3>
<pre><code>10 INPUT A
20 IF SGN (A) = -1 THEN PRINT &quot;Negativo&quot;
30 GOTO 10</code></pre>
<p>La línea 20 visualizará en pantalla “Negativo” únicamente cuando el valor asignado a A es negativo.</p>
<h2 id="sin">SIN</h2>
<p>Devuelve el valor del seno de un dato numérico. El dato debe expresarse en radianes.</p>
<p>Para convertir X de grados a radianes, se debe utilizar la fórmula SIN(X*3.14159/180).</p>
<h3 id="versión-181">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-180">Formato</h3>
<pre><code>SIN(X)</code></pre>
<h3 id="parámetros-160">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas, en radianes).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-40">Retorno</h3>
<p>Constantes en coma flotante comprendidas entre -1 y 1.</p>
<h3 id="ejemplos-127">Ejemplos</h3>
<pre><code>PRINT SIN (3.14/3)
 .86575983949239</code></pre>
<pre><code>PRINT SIN (60*3.14/180)
 .8655983949239</code></pre>
<h2 id="sound">SOUND</h2>
<p>Genera efectos sonoros escribiendo datos directamente en los registros del PSG (Generador de Sonidos Programable).</p>
<p><strong>Funciones de los registros PSG</strong></p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 54%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Registro</strong></th>
<th><strong>Función</strong></th>
<th><strong>Gama de datos</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Frecuencia del canal A</td>
<td>0-255</td>
</tr>
<tr class="even">
<td>1</td>
<td></td>
<td>0-15</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Frecuencia del canal B</td>
<td>0-255</td>
</tr>
<tr class="even">
<td>3</td>
<td></td>
<td>0-15</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Frecuencia del canal C</td>
<td>0-255</td>
</tr>
<tr class="even">
<td>5</td>
<td></td>
<td>0-15</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Frecuencia de ruido</td>
<td>0-31</td>
</tr>
<tr class="even">
<td>7</td>
<td>Activa, desactiva y selecciona canales para para generación de tonos y ruido</td>
<td>0-63</td>
</tr>
<tr class="odd">
<td>8</td>
<td>Volumen canal A</td>
<td>0-15 volumen y 16 si se usa variación de volumen</td>
</tr>
<tr class="even">
<td>9</td>
<td>Volumen canal B</td>
<td></td>
</tr>
<tr class="odd">
<td>10</td>
<td>Volumen canal C</td>
<td></td>
</tr>
<tr class="even">
<td>11</td>
<td>Frecuencia del patrón de variación del volumen</td>
<td>0-255</td>
</tr>
<tr class="odd">
<td>12</td>
<td></td>
<td>0-255</td>
</tr>
<tr class="even">
<td>13</td>
<td>Selección del patrón de variación de volumen</td>
<td>0-14</td>
</tr>
</tbody>
</table>
<p><strong>Determinación de la frecuencia del sonido</strong></p>
<p>Las frecuencias generadas por los tres diferentes canales se determinan mediante seis registros, numerados del 0 al 5. Los datos escritos en los registros se pueden obtener con la siguiente fórmula:</p>
<p><br /><span class="math display">$$\frac{1789772.5\ 8\text{Hz})}{16\ x\ \left( \text{frecuencia}\ \text{de}\
\text{salida}\ \left( \text{Hz} \right) \right)} = 256\ x\left( \text{datos}\
\text{de}\ \text{los}\ \text{registros}\ 1,\ 3,\ 5 \right) + \left(
\text{datos}\ \text{de}\ \text{los}\ \text{registros}\ 0,\ 2,\ 4 \right)$$</span><br /></p>
<p>Por ejemplo, cuando se desea generar un sonido de 300 Hz por el canal A, se cumple la siguiente expresión:</p>
<p><br /><span class="math display">$$
\frac{1789772,5}{16\ x\ 300} = 373 = 256\ x\ 1 + 117
$$</span><br /></p>
<p>Por lo tanto, hay que escribir un 117 en el registro 0 y un 1 en el registro 1.</p>
<p><strong>Determinación de la frecuencia de ruido</strong></p>
<p>En el registro 6, que determina la frecuencia del ruido, se pueden escribir datos comprendidos entre 0 y 31. El dato y la frecuencia están relacionados por la siguiente expresión:</p>
<p>Valor del dato <br /><span class="math display">$$= \frac{1789772,5(Hz)}{16\ x\ frecuencia\ de\ ruido\ (Hz)}$$</span><br /></p>
<p>Por ejemplo, cuando en el registro 6 se ha escrito el dato 15</p>
<p>15<br /><span class="math display">$$= \frac{1789772,5}{16\ x\ 7457}$$</span><br /></p>
<p>Por lo tanto, la frecuencia de ruido es aproximadamente 7457 Hz.</p>
<p><strong>Especificación del canal</strong></p>
<p>El canal utilizado está determinado por el dato escrito en el registro 7.</p>
<table>
<thead>
<tr class="header">
<th><strong>Ruido</strong></th>
<th><strong>Sonido</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Canal C</td>
<td>B</td>
<td>A</td>
<td>C</td>
<td>B</td>
<td>A</td>
</tr>
<tr class="even">
<td>32</td>
<td>16</td>
<td>8</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Se deben sumar los datos numéricos que corresponden al canal utilizado en base a la tabla anterior y restar el resultado de 63 para obtener el dato a escribir. Por ejemplo, cuando los canales A y B han de generar únicamente sonido y el canal C sonido y ruido, se cumple la siguiente expresión (24 es el dato a escribir):</p>
<p>63 – (32+4+2+1)=24</p>
<p><strong>Generación de sonido tras la determinación del volumen</strong></p>
<p>Se deben escribir los datos que determinan el volumen de los canales A, B y C en los registros 8, 9 y 10, respectivamente. Se pueden escribir datos comprendidos entre 0 y 15 (15 corresponde al volumen máximo).</p>
<p><strong>Generación de efectos sonoros mediante patrones de variación de volumen</strong></p>
<p>Con una instrucción SOUND se pueden poner en práctica funciones idénticas a las de los comandos S y M de una instrucción PLAY. Los patrones de variación de volumen están determinados por los datos escritos en el registro 13, que es el mismo que corresponde a la especificación n del comando S de una instrucción PLAY (Sn).</p>
<p>Para información relativa a los valores de n de los patrones correspondientes, véase el comando PLAY.</p>
<p>El ciclo de un patrón de variación de volumen está determinado por los datos escritos en los registros 11 y 12, para los que se cumple la siguiente expresión:</p>
<p><br /><span class="math display">$$
\frac{1789772,5\ (Hz)}{256\ x\ ciclo\ (Hz)} = 256\ x\left( dato\ registro\ 12 \right) + (dato\ registro\ 11)
$$</span><br /></p>
<p>Por ejemplo, cuando el ciclo ha de ser 10 Hz, se debe escribir 187 en el registro 11 y 2 en el registro 12, pues se cumple la siguiente expresión:</p>
<p><br /><span class="math display">$$
\frac{1789772,5}{256\ x\ 10} = 699 = 256x\ 2 + 187
$$</span><br /></p>
<h3 id="versión-182">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-181">Formato</h3>
<pre><code>SOUND número de registro, expresión</code></pre>
<h3 id="parámetros-161">Parámetros</h3>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de registro</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número&lt;14.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas) comprendidas en la gama especificada para cada registro.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-128">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>10 SOUND 0, 56</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code>20 SOUND 1, 1</code></pre>
<p>Selecciona la frecuencia del canal A en 400 Hz</p>
<table>
<thead>
<tr class="header">
<th>30 SOUND 7, 62</th>
<th>Selecciona un tono del canal A</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>40 SOUND 8, 8</td>
<td>Selecciona el volumen del canal A</td>
<td></td>
</tr>
</tbody>
</table>
<p>La ejecución de este programa produce un sonido continuo de 400 Hz. Para detener el sonido se debe pulsar CTRL+STOP.</p>
<h2 id="space">SPACE$</h2>
<p>Devuelve un determinado número de espacios en forma de dato alfanumérico.</p>
<p>Cuando N no es un valor entero, no se tienen en cuenta las cifras siguientes a la coma decimal.</p>
<h3 id="versión-183">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-182">Formato</h3>
<pre><code>SPACE$(N)</code></pre>
<h3 id="parámetros-162">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-41">Retorno</h3>
<p>Tipo cadena.</p>
<h3 id="ejemplos-129">Ejemplos</h3>
<pre><code>PRINT SPACE$ (5); &quot;ABC&quot;</code></pre>
<pre><code>     ABC    </code></pre>
<h2 id="spc">SPC</h2>
<p>Devuelve un número determinado de espacios. Esta función solo se puede utilizar en instrucciones PRINT y LPRINT.</p>
<p>Cuando N no es un valor entero, no se tienen en cuenta las cifras siguientes a la coma decimal.</p>
<h3 id="versión-184">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-183">Formato</h3>
<pre><code>SPC(N)</code></pre>
<h3 id="parámetros-163">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-42">Retorno</h3>
<p>Tipo cadena.</p>
<h3 id="ejemplos-130">Ejemplos</h3>
<pre><code>PRINT &quot;ABC&quot;: SPC (10); &quot;DEF&quot;</code></pre>
<pre><code>ABC          DEF</code></pre>
<p>10 espacios</p>
<h2 id="sprite-onsprite-offsprite-stop">SPRITE ON/SPRITE OFF/SPRITE STOP</h2>
<p>Activa, desactiva o detiene una interrupción provocada por la colisión de sprites.</p>
<p>Esta instrucción se utiliza para activar (SPRITE ON), desactivar (SPRITE OFF) o detener (SPRITE STOP) una interrupción tras la declaración de una interrupción provocada por la colisión de sprites (ON SPRITE GOSUB).</p>
<h3 id="versión-185">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-184">Formato</h3>
<pre><code>SPRITE ON</code></pre>
<pre><code>SPRITE OFF</code></pre>
<pre><code>SPRITE STOP</code></pre>
<h2 id="sprite">SPRITE$</h2>
<p>Define los datos de un sprite.</p>
<p>Cuando una variable SPRITE$ define un modelo de sprite, este se mantiene con un número especificado. Para detalles relativos a la definición del sprite, véase PUT SPRITE.</p>
<h3 id="versión-186">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-185">Formato</h3>
<pre><code>SPRITE$(Número de sprite) = cadena de caracteres</code></pre>
<h3 id="parámetros-164">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de sprite</th>
<th><strong>Cond.</strong> Caso de 8 x 8 puntos: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número&lt;256. Caso de 16 x 16 puntos: Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número&lt;64.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cadena de caracteres</td>
<td>Cadena de caracteres donde cada uno de ellos representa 8 pixeles del gráfico. Un carácter ocupa 1 byte, es decir, 8 bits. Cada uno de estos bits define el estado de un pixel (1 es color, 0 es transparencia).</td>
</tr>
</tbody>
</table>
<h3 id="ejemplo-10">Ejemplo</h3>
<pre><code>10 SPRITE$(0) = CHR$(&amp;hFF) + CHR$(&amp;h00) + CHR$(&amp;hFF) + CHR$(&amp;h00) + CHR$(&amp;hFF) + CHR$(&amp;h00) + CHR$(&amp;hFF) + CHR$(&amp;h00)</code></pre>
<p>Esto define un sprite de 8x8 pixeles.</p>
<h2 id="sqr">SQR</h2>
<p>Devuelve la raíz cuadrada de un dato numérico.</p>
<h3 id="versión-187">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-186">Formato</h3>
<pre><code>SQR(X)</code></pre>
<h3 id="parámetros-165">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤X.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-43">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-131">Ejemplos</h3>
<pre><code>PRINT SQR (100)
 10</code></pre>
<h2 id="stick">STICK</h2>
<p>Ofrece la dirección de las teclas del cursor y de los mandos para juegos (joysticks).</p>
<p>La gama de valores correspondientes a la dirección va desde 0 a 8. Cuando no se pulsa ninguna tecla o no se activa ningún mando, devuelve 0.</p>
<table>
<thead>
<tr class="header">
<th><strong>Valor de N</strong></th>
<th><strong>Dispositivo</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Dirección teclas del cursor</td>
</tr>
<tr class="even">
<td>1</td>
<td>Dirección joystick puerto A</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Dirección joystick puerto B</td>
</tr>
</tbody>
</table>
<h3 id="versión-188">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-187">Formato</h3>
<pre><code>STICK(N)</code></pre>
<h3 id="parámetros-166">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-44">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-132">Ejemplos</h3>
<pre><code>10 CLS
20 X = 14
30 LOCATE X, 10 : PRINT &quot; &quot;;
40 D = STICK (0)
50 IF D = 0 THEN LOCATE X, 10: PRINT &quot;*&quot;
60 IF D = 3 THEN X = X+1: IF X&gt;28 THEN X =28
70 IF D = 7 THEN X = X-1: IF X&lt;0 THEN X = 0
80 LOCATE X, 10: PRINT &quot;*&quot;;
90 GOTO 30</code></pre>
<p>Este programa mueve un asterisco (*) a la izquierda y derecha de la pantalla mediante las teclas del cursor derecha e izquierda. El valor asignado a la variable D en la línea 40 depende de si la tecla está pulsada o no. Las líneas 50, 60, y 70 modifican la coordenada X, donde está ubicada el *, según un valor dado.</p>
<h2 id="stop">STOP</h2>
<p>La ejecución de una instrucción STOP produce la interrupción de la ejecución del programa.</p>
<p>Cuando se ejecuta una instrucción CONT en modo directo, la ejecución se reanuda a partir de la instrucción siguiente a la interrumpida.</p>
<h3 id="versión-189">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-188">Formato</h3>
<pre><code>STOP</code></pre>
<h2 id="stop-onstop-offstop-stop">STOP ON/STOP OFF/STOP STOP</h2>
<p>Activa, desactiva o detiene una interrupción debida a la pulsación de las teclas CTRL+STOP.</p>
<p>Órdenes que activan (STOP ON), desactivan (STOP OFF) o detienen (STOP STOP) una interrupción tras su declaración con la instrucción ON STOP GOSUB (interrupción provocada al pulsar las teclas CTRL+STOP).</p>
<h3 id="versión-190">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-189">Formato</h3>
<pre><code>STOP ON</code></pre>
<pre><code>STOP OFF</code></pre>
<pre><code>STOP STOP</code></pre>
<h2 id="strig">STRIG</h2>
<p>Devuelve un -1 cuando se pulsa la barra espaciadora o el botón de un dispositivo señalizador (joystick, ratón, etc.), y un 0 en caso contrario.</p>
<p>Devuelve el estado de la barra espaciadora cuando N = 0, el estado del botón del dispositivo conectado en el puerto A cuando N = 1, y el estado del botón del dispositivo conectado en el puerto B cuando N = 2. El valor resultante es 0 cuando no están pulsados y -1 cuando lo están.</p>
<h3 id="versión-191">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-190">Formato</h3>
<pre><code>STRIG(N)</code></pre>
<h3 id="parámetros-167">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;5.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-45">Retorno</h3>
<p>Tipo entero.</p>
<h3 id="ejemplos-133">Ejemplos</h3>
<pre><code>10 CLS
20 COLOR ,C, C
30 IF STRIG (0) = 0 THEN GOTO 20
40 C = C+1: IF C&gt;15 THEN C = 0
50 GOTO 20</code></pre>
<p>Este programa cambia el color de la pantalla cada vez que se pulsa la barra espaciadora.</p>
<h2 id="strig-onstrig-offstrig-stop">STRIG ON/STRIG OFF/STRIG STOP</h2>
<p>Activa, desactiva o detiene una interrupción provocada por la pulsación de la barra espaciadora o del botón de un dispositivo señalizador (joystick, ratón, etc.).</p>
<p>Especifica, según el valor de N, la barra espaciadora o el botón del dispositivo señalizador A o B utilizados en una interrupción. El número de línea de la subrutina correspondiente debe estar especificado por una instrucción ON STRIG GOSUB.</p>
<table>
<thead>
<tr class="header">
<th><strong>Valor de N</strong></th>
<th><strong>Especifica</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Barra espaciadora</td>
</tr>
<tr class="even">
<td>1</td>
<td>Botón 1 del dispositivo A</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Botón 2 del dispositivo A</td>
</tr>
<tr class="even">
<td>3</td>
<td>Botón 1 del dispositivo B</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Botón 2 del dispositivo B</td>
</tr>
</tbody>
</table>
<h3 id="versión-192">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-191">Formato</h3>
<table>
<thead>
<tr class="header">
<th>STRIG(N) ON</th>
<th>Activa interrupción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STRIG(N) OFF</td>
<td>Desactiva interrupción</td>
</tr>
<tr class="even">
<td>STRIG(N) STOP</td>
<td>Detiene interrupción</td>
</tr>
</tbody>
</table>
<h3 id="parámetros-168">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;5.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-134">Ejemplos</h3>
<table>
<thead>
<tr class="header">
<th>STRIG (0) ON</th>
<th>Activa una interrupción de la barra espaciadora</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STRIG (1) OFF</td>
<td>Desactiva una interrupción de botón 1 del dispositivo A</td>
</tr>
<tr class="even">
<td>STRIG (2) STOP</td>
<td>Detiene una interrupción de botón 2 del dispositivo A</td>
</tr>
</tbody>
</table>
<h2 id="str">STR$</h2>
<p>Convierte datos de tipo numérico en datos alfanuméricos.</p>
<p>Cuando el dato numérico es negativo, el primer carácter de la cadena resultante es el -, y cuando es 0 o positivo, el primer carácter es un espacio en blanco.</p>
<h3 id="versión-193">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-192">Formato</h3>
<pre><code>STR$(X)</code></pre>
<h3 id="parámetros-169">Parámetros</h3>
<table>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-46">Retorno</h3>
<p>Tipo cadena.</p>
<h3 id="ejemplos-135">Ejemplos</h3>
<pre><code>10 X = 100: Y = 200
20 X$ = STR$ (X):Y$ = STR$ (Y)
30 PRINT X+Y
40 PRINT X$+Y$
RUN
 300
 100 200</code></pre>
<h2 id="string">STRING$</h2>
<p>Ofrece, en forma de datos alfanuméricos (de cadena), el carácter de un código de carácter dado, o el de comienzo de una cadena, un número especificado de veces de forma consecutiva.</p>
<h3 id="versión-194">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-193">Formato</h3>
<pre><code>STRING$(N, J)</code></pre>
<pre><code>STRING$(N, X$)</code></pre>
<h3 id="parámetros-170">Parámetros</h3>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;256.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>J</td>
<td><strong>Cond.</strong> Un código de carácter.</td>
</tr>
<tr class="even">
<td>X$</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (de cadena).</td>
</tr>
</tbody>
</table>
<h3 id="retorno-47">Retorno</h3>
<p>Tipo cadena.</p>
<h3 id="ejemplos-136">Ejemplos</h3>
<pre><code>PRINT STRING$ (10, 70)
FFFFFFFFFF</code></pre>
<pre><code>PRINT STRING$ (5, &quot;ABC&quot;)
AAAAA</code></pre>
<h2 id="swap">SWAP</h2>
<p>Intercambia el valor de dos variables.</p>
<h3 id="versión-195">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-194">Formato</h3>
<pre><code>SWAP variable, variable</code></pre>
<h3 id="parámetros-171">Parámetros</h3>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Variables, variables de matriz numéricas o de cadena. Las dos variables deben ser del mismo tipo.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-137">Ejemplos</h3>
<pre><code>10 A = 3: B = 5
20 SWAP A, B
30 PRINT &quot;A =&quot;; A
40 PRINT &quot;B =&quot;; B
RUN
A = 5
B = 3</code></pre>
<h2 id="tab">TAB</h2>
<p>Mueve el cursor hacia la derecha desde el principio de una línea el número de caracteres especificado.</p>
<p>La función TAB solo se puede utilizar en instrucciones PRINT o LPRINT. Cuando N es 0 corresponde al extremo izquierdo y cuando es un valor que coincide con el número de caracteres de una línea menos 1, corresponde al extremo derecho.</p>
<h3 id="versión-196">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-195">Formato</h3>
<pre><code>TAB(N)</code></pre>
<h3 id="parámetros-172">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤N&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-138">Ejemplos</h3>
<pre><code>PRINT TAB (5); &quot;AAA&quot;
     AAA</code></pre>
<p>5 espacios</p>
<h2 id="tan">TAN</h2>
<p>Ofrece el valor de la tangente de un dato numérico.</p>
<p>Para obtener X en grados, se debe utilizar la fórmula TAN (X*π/180).</p>
<h3 id="versión-197">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-196">Formato</h3>
<pre><code>TAN(X)</code></pre>
<h3 id="parámetros-173">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas, en radianes).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-48">Retorno</h3>
<p>Constantes de coma flotante.</p>
<h3 id="ejemplos-139">Ejemplos</h3>
<pre><code>PRINT TAN (3.14/3)
 1.72992922009</code></pre>
<pre><code>PRINT TAN (60*3.14/180)
 1.72992922009</code></pre>
<h2 id="time">TIME</h2>
<p>Contiene el valor del temporizador incorporado.</p>
<p>Esta variable contiene el valor del temporizador incorporado, activado en el momento de inicializarse el VR-BASIC, y suma una unidad cada 1/50 seg., en un rango que va desde 0 hasta 65536. Cuando llega a 65536, salta a 0 otra vez.</p>
<p>El valor de la variable se puede reescribir mediante una instrucción LET. Cuando la CPU está en un estado de prohibición de interrupciones (por ejemplo, durante la entrada/salida de cinta de casete), el temporizador está parado. Cuando la alimentación está desconectada tampoco funciona el temporizador.</p>
<h3 id="versión-198">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-197">Formato</h3>
<pre><code>TIME</code></pre>
<pre><code>TIME = expresión</code></pre>
<h3 id="parámetros-174">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Expresión</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤expresión&lt;65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-140">Ejemplos</h3>
<pre><code>10 CLS: TIME = 0
20 LOCATE 12, 8: PRINT INT (TIME/50)
30 GOTO 20</code></pre>
<p>Este programa presenta en pantalla continuamente el valor entero de TIME/50; el valor de TIME se divide por 50 tras hacer inicializar a cero la variable TIME. El número aumenta una unidad cada segundo, aproximadamente.</p>
<h2 id="troff">TROFF</h2>
<p>Desactiva TRON y detiene por lo tanto la presentación en pantalla de los números de línea ejecutados.</p>
<p>La ejecución de una instrucción TROFF en el modo directo o indirecto, mientras se ejecuta una instrucción TRON, anula la presentación de los números de línea en pantalla.</p>
<h3 id="versión-199">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-198">Formato</h3>
<pre><code>TROFF</code></pre>
<h2 id="tron">TRON</h2>
<p>Presenta en pantalla los números de línea ejecutados.</p>
<p>La ejecución de la instrucción TRON, en modo directo o indirecto, produce la presentación en pantalla, en el modo texto y entre corchetes, del número de línea ejecutado a continuación.</p>
<p>Cuando la pantalla está en modo gráfico, consecuencia de una instrucción SCREEN, no se visualizará el número de línea.</p>
<h3 id="versión-200">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-199">Formato</h3>
<pre><code>TRON</code></pre>
<h3 id="ejemplos-141">Ejemplos</h3>
<pre><code>10 TRON
20 FOR I = 0 TO 3
30 A = I+1: PRINT A
40 NEXT I
50 TROFF
RUN
[20] [30] 1
[40] [30] 2
[40] [30] 3
[40] [30] 4
[40] [50] </code></pre>
<h2 id="usr">USR</h2>
<p>Devuelve el resultado obtenido tras la ejecución de una subrutina en lenguaje máquina que comienza en una dirección definida por una instrucción DEFUSR.</p>
<p>X es el número de la subrutina de usuario, concretamente el número especificado por DEFUSR. I es una constante o una variable que indica el valor a transferir desde el VR‑BASIC a la subrutina.</p>
<p><strong>EJECUCIÓN DE SUBRUTINAS EN LENGUAJE MÁQUINA</strong></p>
<p><strong>Variable = USR X (I)</strong></p>
<p>La subrutina en lenguaje máquina definida por el usuario se ejecuta mediante la instrucción anterior. Cuando esta subrutina ha sido ejecutada, el valor del resultado queda asignado a una variable, y se sigue ejecutando el programa VR-BASIC.</p>
<p>Cuando la ejecución resulta transferida a una subrutina en lenguaje máquina, se pasa a esa subrutina el valor de I especificado como parámetro de una función USR.</p>
<p>N = USR 1 (I)</p>
<p>La instrucción anterior llama a nuestra rutina en código máquina y antes de hacerlo prepara los registros de la CPU. Por un lado, en el registro A (y en la dirección de memoria RAM &amp;HF663) encontraremos el tipo de dato; y por otro lado, en el registro HL, hallaremos la dirección a partir de la cual se encuentra el dato. Según el tipo de dato observamos la siguiente tabla:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 26%" />
<col style="width: 29%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Tipo de I</strong></th>
<th><strong>Datos introducidos al registro A *</strong></th>
<th><strong>Indicación de la dirección; registro HL</strong></th>
<th><strong>Direcciones donde se almacena el valor de I</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Entero</td>
<td>2</td>
<td>&amp;HF7F6</td>
<td>&amp;HF7F8-&amp;HF7F9</td>
</tr>
<tr class="even">
<td>Precisión simple</td>
<td>4</td>
<td></td>
<td>&amp;HF7F6-&amp;HF7F9</td>
</tr>
<tr class="odd">
<td>Precisión doble</td>
<td>8</td>
<td></td>
<td>&amp;HF7F6-&amp;HF7FD</td>
</tr>
</tbody>
</table>
<p>*Introduce el mismo dato en la dirección de memoria &amp;HF663.</p>
<p>En el caso de que I sea una variable de cadena, el proceso es:</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 22%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Datos introducidos al registro A</strong></th>
<th><strong>Datos introducidos en registro DE</strong></th>
<th><strong>Descriptor de la cadena</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>Dirección inicial del descriptor de la cadena</td>
<td>1er byte: Longitud de la cadena. 2º y 3er bytes: Dirección inicial de la zona donde se almacena la cadena de caracteres.</td>
</tr>
</tbody>
</table>
<p>Cuando la ejecución de la subrutina en lenguaje máquina ha llegado a su fin, el valor del resultado queda asignado a la variable X y los registros y la memoria quedarán de la siguiente forma:</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 20%" />
<col style="width: 7%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Tipo del valor del resultado</strong></th>
<th><strong>Dirección de memoria &amp;HF663</strong></th>
<th><strong>Registro DE</strong></th>
<th><strong>Registro HL</strong></th>
<th><strong>Direcciones de almacenamiento del resultado</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Entero</td>
<td>2</td>
<td></td>
<td>&amp;HF7F6</td>
<td>&amp;HF7F8-&amp;HF7F9</td>
</tr>
<tr class="even">
<td>Precisión simple</td>
<td>4</td>
<td></td>
<td>&amp;HF7F6</td>
<td>&amp;HF7F6-&amp;HF7F9</td>
</tr>
<tr class="odd">
<td>Precisión doble</td>
<td>8</td>
<td></td>
<td>&amp;HF7F6</td>
<td>&amp;HF7F6-&amp;HF7FD</td>
</tr>
<tr class="even">
<td>Cadena</td>
<td>3</td>
<td>Dirección inicial del descriptor de la cadena</td>
<td></td>
<td>Dirección inicial del área de memoria indicada por el 2º y 3º byte del descriptor de la cadena.</td>
</tr>
</tbody>
</table>
<h3 id="versión-201">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-200">Formato</h3>
<pre><code>USR [X] (I)</code></pre>
<h3 id="parámetros-175">Parámetros</h3>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>X</th>
<th><strong>Cond.</strong> Constantes de tipo entero; 0≤X&lt;9. <strong>Omit.</strong> 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>I</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas o de cadena).</td>
</tr>
</tbody>
</table>
<h3 id="retorno-49">Retorno</h3>
<p>Depende de la función de usuario definida.</p>
<h3 id="ejemplos-142">Ejemplos</h3>
<pre><code>DEFUSR0 = &amp;HE000
X = USR0 (I)</code></pre>
<p>Las instrucciones anteriores producen la ejecución de la subrutina que comienza en la dirección &amp;HE000 y la asignación del resultado al VR-BASIC.</p>
<h2 id="val">VAL</h2>
<p>Devuelve un dato alfanumérico en forma de dato numérico.</p>
<p>En el caso de que la cadena de texto no pueda convertirse a un valor numérico, el resultado numérico devuelto será 0.</p>
<h3 id="versión-202">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-201">Formato</h3>
<pre><code>VAL(X$)</code></pre>
<h3 id="parámetros-176">Parámetros</h3>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>X$</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones que expresan números (de cadena).</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-50">Retorno</h3>
<p>Tipo numérico.</p>
<h3 id="ejemplos-143">Ejemplos</h3>
<pre><code>PRINT VAL(&quot;5&quot;)
 5</code></pre>
<div class="line-block">PRINT VAL(" 5") | Ignora los espacios |<br />
5 | |</div>
<p>|———————-|———————| | PRINT VAL(“aa”) | | | 0 | |</p>
<h2 id="varptr-1">VARPTR (1)</h2>
<p>Devuelve la dirección inicial de memoria donde está almacenado el dato asignado a una variable.</p>
<p>Devuelve la dirección inicial (decimal) de la zona de memoria donde está almacenado un valor asignado a una variable dada. Si la dirección decimal es un número negativo, la dirección real es la que resulta de sumar a ese número 65536. La función VARPTR se utiliza, por ejemplo, en el caso de transferir una dirección de memoria con datos a una subrutina en lenguaje máquina.</p>
<p>Antes de hacer uso de la función VARPTR, se debe asignar un valor a la variable.</p>
<h3 id="versión-203">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-202">Formato</h3>
<pre><code>VARPTR(variable)</code></pre>
<h3 id="parámetros-177">Parámetros</h3>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz (numéricas y alfanuméricas)</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-51">Retorno</h3>
<p>Constantes de tipo entero; -32768≤valor32767.</p>
<h3 id="ejemplos-144">Ejemplos</h3>
<pre><code>10 A% = 15
20 X = VARPTR (A%)
30 M$ = HEX$ (X): PRINT M$
RUN
802E</code></pre>
<p>Este programa comprueba la dirección de memoria donde está almacenado el valor asignado a una variable (A%) y la presenta en pantalla tras su conversión al sistema hexadecimal.</p>
<h2 id="varptr-2">VARPTR (2)</h2>
<p>Devuelve la dirección inicial del bloque de control de ficheros asignado al fichero especificado. La dirección inicial de la zona de memoria (memoria intermedia de ficheros) especificada para entrada al fichero está almacenada en el bloque de control de ficheros.</p>
<h3 id="versión-204">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-203">Formato</h3>
<pre><code>VARPTR(# número de fichero)</code></pre>
<h3 id="parámetros-178">Parámetros</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de fichero</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 1≤número de fichero≤número especificado en la instrucción MAXFILES.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-52">Retorno</h3>
<p>Tipo entero; -32768≤valor≤-1.</p>
<h2 id="vdp">VDP</h2>
<p>Lee o escribe el contenido de los registros del procesador de vídeo VDP.</p>
<p>En los MSX1 el VDP es el TMS9929 o compatible. En los MSX2 encontramos el VDP9938, en los MSX2+ y MSXturboR el VDP9958 y finalmente, en los MSXVR, encontramos el VDP9968.</p>
<p>Con este comando podemos leer y/o escribir en los registros del procesador de vídeo de un ordenador MSX. La siguiente tabla muestra el código numérico para acceder a los registros de los diferentes VDP:</p>
<table>
<thead>
<tr class="header">
<th><strong>N</strong></th>
<th><strong>VDP</strong></th>
<th><strong>Registro</strong></th>
<th><strong>Función</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0 al 7</td>
<td>Todos</td>
<td>0 al 7</td>
<td>Lectura / Escritura</td>
</tr>
<tr class="even">
<td>8</td>
<td>Todos</td>
<td>Registro de estado 0</td>
<td>Solo lectura</td>
</tr>
<tr class="odd">
<td>9 al 24</td>
<td>Todos</td>
<td>8 al 23</td>
<td>Lectura / Escritura</td>
</tr>
<tr class="even">
<td>33 al 47</td>
<td>Todos</td>
<td>32 al 46</td>
<td>Lectura / Escritura</td>
</tr>
<tr class="odd">
<td>48 al 63</td>
<td>VDP9968</td>
<td>48 al 63</td>
<td>Lectura / Escritura</td>
</tr>
<tr class="even">
<td>-1 al -9</td>
<td>Todos</td>
<td>Registro de estado 1 al 9</td>
<td>Solo lectura</td>
</tr>
</tbody>
</table>
<p>PRECAUCIÓN</p>
<p>Para realizar operaciones con una variable VDP y reescribir el valor de los registros del VDP, es necesario conocer adecuadamente el procesador de vídeo. Si se reescriben inadecuadamente los registros del VDP, no podrá conseguir la visualización normal de la pantalla.</p>
<h3 id="versión-205">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-204">Formato</h3>
<pre><code>VDP (N) [= expresión]</code></pre>
<h3 id="parámetros-179">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>N</th>
<th><strong>Cond.</strong> Constantes de tipo entero; 0≤N≤24, 33≤N≤47, -9≤N≤-1. Con el VDP9968, 33≤N≤63.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤expresión&lt;255.</td>
</tr>
</tbody>
</table>
<h3 id="ejemplos-145">Ejemplos</h3>
<pre><code>PRINT VDP(7)    </code></pre>
<p>Muestra el color de tinta y fondo activos.</p>
<h2 id="vpeek">VPEEK</h2>
<p>Lee datos de la VRAM (memoria de vídeo).</p>
<p>Devuelve el dato escrito en la dirección especificada de la VRAM. Para los modos SCREEN 5 a 13, suma la dirección inicial de la página activa a la dirección especificada para componer la dirección absoluta de la VRAM.</p>
<table>
<thead>
<tr class="header">
<th><strong>SCREEN</strong></th>
<th><strong>Página activa</strong></th>
<th><strong>Dirección inicial</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5,6</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td>&amp;H08000</td>
</tr>
<tr class="odd">
<td></td>
<td>2</td>
<td>&amp;H10000</td>
</tr>
<tr class="even">
<td></td>
<td>3</td>
<td>&amp;H18000</td>
</tr>
<tr class="odd">
<td>7,8,10,11,12,13</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td></td>
<td>1</td>
<td>&amp;H10000</td>
</tr>
</tbody>
</table>
<h3 id="versión-206">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-205">Formato</h3>
<pre><code>VPEEK (dirección)</code></pre>
<h3 id="parámetros-180">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Dirección</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤dirección&lt;65536.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="retorno-53">Retorno</h3>
<p>Tipo entero, 0≤valor≤255.</p>
<h3 id="ejemplos-146">Ejemplos</h3>
<p>El siguiente programa presentará en pantalla el contenido de la dirección &amp;H10200 (SCREEN 6).</p>
<pre><code>10 SCREEN 6
20 SET PAGE ,2
30 A = VPEEK(&amp;H200)
40 SCREEN 0
50 PRINT A</code></pre>
<p>La línea 20 especifica la página 2 como página activa.</p>
<p>La línea 30 lee el contenido de la VRAM. La dirección absoluta de la VRAM es &amp;H10200:</p>
<p>&amp;H200 (Dirección VPEEK) + &amp;H10000 (dirección inicial de la página activa).</p>
<h2 id="vpoke">VPOKE</h2>
<p>Escribe un byte de datos en la VRAM (memoria de vídeo).</p>
<p>Escribe el dato designado en la dirección especificada de la VRAM. Para los modos SCREEN 5 a 13, suma la dirección inicial de la página activa a la dirección especificada para componer la dirección absoluta de la VRAM (véase comando VPEEK).</p>
<p>Para la composición del mapa de direcciones de la VRAM, la dirección base de cada tabla se puede determinar con la función BASE. Por lo tanto, al hacer uso de la instrucción VPOKE, determine la dirección de la VRAM con la función BASE.</p>
<h3 id="versión-207">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-206">Formato</h3>
<pre><code>VPOKE dirección, expresión</code></pre>
<h3 id="parámetros-181">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Dirección</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤dirección≤65536.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Expresión</td>
<td><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤expresión&lt;256.</td>
</tr>
</tbody>
</table>
<h2 id="wait">WAIT</h2>
<p>Espera hasta que la entrada del puerto E/S alcanza un valor determinado.</p>
<p>Cuando se ejecute esta sentencia, los datos se introducirán a través del puerto de Entrada/Salida especificado, se realizará la operación XOR (suma lógica exclusiva) con el valor de la expresión 2, y se obtendrá el resultado final de la operación AND (producto lógico) del resultado anterior y el valor de la expresión 1. Si el valor del resultado final es 0, seguirán introduciéndose los datos procedentes del puerto de E/S, y si es cualquier otro, se pasará a ejecutar la siguiente línea del programa. Cuando se omita la expresión 2, su valor se considerará cero.</p>
<h3 id="versión-208">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-207">Formato</h3>
<pre><code>WAIT número de puerto, expresión 1,[,expresión 2]....</code></pre>
<h3 id="parámetros-182">Parámetros</h3>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de puerto, Expresión 1, Expresión 2</th>
<th><strong>Cond.</strong> Constantes, variables, variables de matriz, sus expresiones (numéricas); 0≤número/expresión&lt;256.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="width">WIDTH</h2>
<p>Especifica el número de caracteres por línea en el modo texto.</p>
<p>En el modo SCREEN 0, cuando el número de caracteres especificado es 40 o menos de 40, selecciona el modo texto de 40 caracteres x 24 líneas. Cuando es superior a 40, selecciona el modo texto de 80 caracteres x 24 líneas.</p>
<h3 id="versión-209">Versión</h3>
<p>MSX, MSX2, MSX2+, MSXturboR, MSXVR</p>
<h3 id="formato-208">Formato</h3>
<pre><code>WIDTH número de caracteres</code></pre>
<h3 id="parámetros-183">Parámetros</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Número de caracteres</th>
<th><strong>Cond.</strong> SCREEN 0: Constantes, variables, variables de matriz, sus expresiones; numéricas, 1≤número&lt;81. SCREEN 1: Constantes, variables, variables de matriz, sus expresiones; numéricas, 1≤número&lt;32.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h3 id="ejemplos-147">Ejemplos</h3>
<pre><code>SCREEN 0</code></pre>
<pre><code>WIDTH 40</code></pre>
<p>Estas sentencias inicializan el modo texto SCREEN 0, con 40 caracteres por línea.</p>
<h2 id="mensajes-de-error">MENSAJES DE ERROR</h2>
<p>En caso de producirse un error, la ejecución del programa se detendrá. Se entrará en el estado de espera de comandos y se visualizará en pantalla un mensaje de error. El mensaje de error explica de una forma concisa la causa del error. A continuación se indican los posibles mensajes de error y su significado (los números de los errores están encerrados entre paréntesis).</p>
<h4 id="bad-fat-60">Bad FAT (60)</h4>
<p>El disco no está formateado.</p>
<h4 id="bad-drive-name-62">Bad drive name (62)</h4>
<p>Se ha especificado como nombre de dispositivo una unidad de discos que no está en uso.</p>
<h4 id="bad-file-mode-61">Bad file mode (61)</h4>
<p>Se ha utilizado una instrucción PUT, una instrucción GET o una función LOF con un fichero secuencial.</p>
<p>Se ha ejecutado una instrucción LOAD con un fichero de acceso aleatorio.</p>
<p>Se ha especificado un modo inadecuado en una instrucción OPEN.</p>
<h4 id="bad-file-name-56">Bad file name (56)</h4>
<p>El nombre del archivo es erróneo.</p>
<p>Se ha especificado, mediante una sentencia OPEN, SAVE o LOAD, un nombre de dispositivo erróneo.</p>
<h4 id="bad-file-number-52">Bad file number (52)</h4>
<p>Se ha utilizado un número de archivo que supera el rango especificado en la instrucción MAXFILES.</p>
<p>Se ha intentado ejecutar una instrucción PRINT# con un número de fichero no abierto.</p>
<h4 id="bad-sector-number-63">Bad sector number (63)</h4>
<p>El número de registro especificado en una instrucción PUT o en una instrucción GET es 0 o mayor que 32767.</p>
<h4 id="cant-continue-17">Can´t CONTINUE (17)</h4>
<p>Se ha intentado reanudar un programa modificado tras una interrupción.</p>
<p>No hay ningún programa en la memoria del ordenador.</p>
<p>Se ha utilizado una instrucción CONT en un programa.</p>
<h4 id="device-io-error-19">Device I/O error (19)</h4>
<p>Carga imposibilitada por causa de la cinta o problemas del reproductor/grabador de casetes.</p>
<p>Nivel de volumen del casete inadecuado.</p>
<p>Orden interrumpida con anterioridad a la terminación de la carga.</p>
<p>Error del dispositivo de entrada/salida.</p>
<h4 id="direct-statement-in-file-57">Direct statement in file (57)</h4>
<p>Una instrucción de un programa ASCII en proceso de carga no tiene número de línea.</p>
<p>Se ha intentado cargar un fichero que no está escrito en VR-BASIC, por ejemplo un fichero de datos.</p>
<h4 id="disk-full-66">Disk full (66)</h4>
<p>El disco está lleno.</p>
<h4 id="disk-io-error-69">Disk I/O error (69)</h4>
<p>Se ha producido un “error fatal” en el proceso de entrada/salida de disco.</p>
<h4 id="disk-offline-70">Disk offline (70)</h4>
<p>No hay disco en la unidad.</p>
<h4 id="disk-write-protected-68">Disk write protected (68)</h4>
<p>Se ha intentado escribir en un disco protegido contra la escritura.</p>
<h4 id="division-by-zero-11">Division by zero (11)</h4>
<p>Se ha intentado hacer una división por cero.</p>
<p>Se ha intentado hacer una división por una variable indefinida.</p>
<h4 id="field-overflow-50">Field overflow (50)</h4>
<p>El área especificada en la instrucción FIELD es superior a la longitud del registro.</p>
<h4 id="file-already-exists-65">File already exists (65)</h4>
<p>El nombre de fichero especificado como nombre de nuevo fichero en una instrucción NAME ya existe en el disco.</p>
<h4 id="file-already-open-54">File already open (54)</h4>
<p>Se ha intentado abrir un fichero que ya está abierto.</p>
<p>Se ha intentado utilizar la orden KILL con un fichero abierto.</p>
<h4 id="file-not-found-53">File not found (53)</h4>
<p>El fichero especificado en una instrucción LOAD, KILL o OPEN no existe en ese disco.</p>
<h4 id="file-not-open-59">File not open (59)</h4>
<p>Se ha intentado ejecutar una instrucción PRINT#, INPUT#, etc. con un fichero que no había sido abierto por la instrucción OPEN.</p>
<h4 id="file-still-open-64">File still open (64)</h4>
<p>El fichero no ha sido cerrado.</p>
<h4 id="illegal-direct-12">Illegal direct (12)</h4>
<p>Se ha intentado ejecutar, en el modo “mandato directo”, una instrucción que solo puede ir dentro de un programa, por ejemplo una instrucción DEF FN.</p>
<h4 id="illegal-function-call-5">Illegal function call (5)</h4>
<p>Se ha utilizado un valor erróneo en un comando.</p>
<p>El valor de una función excede los límites del rango permitido.</p>
<h4 id="input-past-end-55">Input past end (55)</h4>
<p>Se ha intentado leer otra vez un fichero cuando ya han sido leídos todos los datos.</p>
<p>No hay datos en el fichero.</p>
<h4 id="internal-error-51">Internal error (51)</h4>
<p>Hay un defecto en el intérprete VR-BASIC.</p>
<h4 id="line-buffer-overflow-25">Line buffer overflow (25)</h4>
<p>La memoria intermedia de entrada (buffer) está llena.</p>
<h4 id="missing-operand-24">Missing operand (24)</h4>
<p>No hay ningún parámetro a continuación de un mandato.</p>
<p>Los parámetros necesarios están incompletos.</p>
<h4 id="next-without-for-1">NEXT without FOR (1)</h4>
<p>No hay ninguna instrucción FOR correspondiente a la instrucción NEXT ejecutada.</p>
<p>La ejecución del programa se ha bifurcado al interior de un bucle FOR-NEXT a causa de una instrucción GOTO.</p>
<h4 id="no-resume-21">NO RESUME (21)</h4>
<p>Una rutina de procesamiento de errores no tiene ninguna instrucción RESUME (las rutinas de procesamiento de errores deben terminar con END, RESUME u ON ERROR GOTO 0).</p>
<h4 id="out-of-data-4">Out of DATA (4)</h4>
<p>No hay instrucciones DATA o las que hay son insuficientes con respecto a las instrucciones READ.</p>
<h4 id="out-of-memory-7">Out of memory (7)</h4>
<p>Programa demasiado largo.</p>
<p>Demasiadas variables.</p>
<p>Matriz demasiado larga.</p>
<p>El programa contiene demasiadas instrucciones FOR-NEXT o GOSUB.</p>
<h4 id="out-of-string-space-14">Out of string space (14)</h4>
<p>Área de caracteres rebasada.</p>
<p>Área de caracteres especificada por una instrucción CLEAR demasiado pequeña.</p>
<h4 id="overflow-6">Overflow (6)</h4>
<p>Un dato numérico o un resultado aritmético rebasa el rango permitido.</p>
<p>Un parámetro de dirección rebasa los límites del rango especificado.</p>
<h4 id="rename-across-disk-71">Rename across disk (71)</h4>
<p>Se ha intentado la ejecución de un mandato NAME entre unidades de disco diferentes.</p>
<h4 id="ram-disk-full-66">RAM disk full (66)</h4>
<p>Se ha utilizado toda la capacidad de la RAM-Disk (en Disk-BASIC el mensaje emitido será “Disk full”).</p>
<h4 id="ram-offline-70">RAM offline (70)</h4>
<p>Se ha utilizado la RAM-Disk antes de ejecutar una instrucción CALL MEMINI (en Disk-BASIC el mensaje emitido será “Disk offline”).</p>
<h4 id="resume-without-error-22">RESUME without error (22)</h4>
<p>Hay una instrucción RESUME que no tiene su correspondiente instrucción ON ERROR.</p>
<p>Transferencia a una rutina de procesamiento de errores por una instrucción GOTO.</p>
<p>Como no hay ninguna instrucción END al final de una rutina principal, ejecuta continuamente una rutina de procesamiento de errores.</p>
<h4 id="return-without-gosub-3">RETURN without GOSUB (3)</h4>
<p>Hay una instrucción RETURN que no tiene su correspondiente instrucción GOSUB.</p>
<p>Transferencia a una subrutina por una instrucción GOTO.</p>
<p>Como no hay ninguna instrucción END al final de una rutina principal, ejecuta continuamente una subrutina.</p>
<h4 id="redimensioned-array-10">Redimensioned array (10)</h4>
<p>Se ha intentado definir matrices con el mismo nombre.</p>
<p>Se han utilizado variables de matriz sin haber sido definidas mediante la instrucción DIM, y después se han definido.</p>
<h4 id="sequential-io-only-58">Sequential I/O only (58)</h4>
<p>Se ha utilizado una orden de fichero de acceso aleatorio para un fichero secuencial.</p>
<h4 id="string-formula-too-complex-16">String formula too complex (16)</h4>
<p>Expresión de caracteres de una línea demasiado complicada.</p>
<h4 id="string-too-long-15">String too long (15)</h4>
<p>Se ha asignado más de 255 caracteres a una variable alfanumérica.</p>
<h4 id="subscript-out-of-range-9">Subscript out of range (9)</h4>
<p>Se ha utilizado un subíndice mayor que 11 para una variable matricial no declarada por una instrucción DIM.</p>
<h4 id="syntax-error-2">Syntax error (2)</h4>
<p>Hay una instrucción que no cumple las reglas sintácticas del VR-BASIC.</p>
<h4 id="too-many-files-67">Too many files (67)</h4>
<p>El número de ficheros del disco es superior a 112.</p>
<p>El número de ficheros de la RAM-Disk es superior a 32.</p>
<h4 id="type-mismatch-13">Type mismatch (13)</h4>
<p>Se ha intentado asignar un valor numérico a una variable alfanumérica, o al revés.</p>
<p>Se ha intentado efectuar una operación lógica con datos de cadena.</p>
<p>El tipo de dato especificado por una función es erróneo.</p>
<h4 id="undefined-line-number-8">Undefined line number (8)</h4>
<p>Se ha especificado un número de línea no existente en una instrucción GOTO, GOSUB o RESUME.</p>
<p>En la ejecución de una instrucción RENUM, en el programa se había especificado una instrucción GOTO con un número de línea inexistente, etc…</p>
<h4 id="undefined-user-function-18">Undefined user function (18)</h4>
<p>Se ha intentado utilizar una función de usuario no definida por una instrucción DEF FN.</p>
<h4 id="unprintable-error-23-26-49-60-255">Unprintable error (23, 26-49, 60-255)</h4>
<p>Se ha producido un error que no tiene asignado número de error.</p>
<p>Se ha producido un error debido a que en una instrucción ERROR ha sido especificado el número de un error indefinido.</p>
<h4 id="verify-error-20">Verify error (20)</h4>
<p>El programa en cinta de casete es diferente al programa residente en memoria.</p>
<h4 id="function-not-implemented-yet-255">Function not implemented yet (255)</h4>
<p>La función no ha sido implementada todavía en la versión actual del VR-BASIC.</p>
<h1 id="vr-dos">VR-DOS</h1>
<h1 id="qué-es-vr-dos">¿Qué es VR-DOS?</h1>
<p>Es el intérprete de comandos que permite al usuario interaccionar con el sistema operativo de la máquina, sus herramientas y servicios.</p>
<pre><code>VR-DOS version 1.0
MSXVR version 0.0.1
Copyright MSXVR Team 2013-2020
C:/&gt;</code></pre>
<p>Este interprete de comandos es similar al MSX-DOS<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (a su vez basado en CP/M<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>). Está basado en unidades de disco desde las cuales se puede navegar entre archivos y carpetas (o directorios). Podemos tener varias unidades, cada una de ellas haciendo referencia a distintos dispositivos físicos conectados al ordenador.</p>
<p>El VR-DOS presenta un símbolo de sistema (command prompt) o texto identificativo desde el que sabemos la ubicación (unidad y directorio) en el que estamos. Veremos un cursor parpadeante: eso indica que el intérprete está operativo para que introduzcamos un comando.</p>
<p>En este manual encontrarás toda la lista de comandos existentes y cómo funcionan. También cómo crear programas en diferentes lenguajes, acceder al VR-BASIC y operar con el VR-VIEW (interface de usuario basado en ventanas), pero antes vamos a dar un pequeño repaso a conceptos importantes e introducirnos en este entorno.</p>
<p>Concepto de unidad, directorio y archivo.</p>
<p>Un <strong>bit</strong> es la unidad mínima de información en un ordenador. Un bit representa el valor decimal 0 o 1.</p>
<p>Un <strong>byte</strong> sería un paquete de 8 bits. Permite representar valores decimales entre 0 y 255 sin signo o de -128 a 127 con signo.</p>
<p>Un <strong>Archivo</strong> es un conjunto de bytes. Este conjunto de bytes almacena cualquier tipo de información codificada numéricamente. Este archivo (o documento) viene identificado por un nombre de hasta 256 caracteres en formato extendido (o de 8 en formato CP/M) y de 256 caracteres para la extensión en formato extendido (o de 3 en formato CP/M).</p>
<p>Un <strong>Directorio</strong> es un conjunto de archivos y otros directorios. También se identifica por nombre con el mismo formato que el de los archivos.</p>
<p>Una <strong>Unidad</strong> es un dispositivo de almacenamiento (disco duro, floppy disk, flash disk, SD, etc.) que contiene archivos y directorios.</p>
<p>Programas y Aplicaciones</p>
<p>En VR-DOS vamos a poder desarrollar programas y aplicaciones con distintas características en función de nuestros requerimientos. Estas aplicaciones se programan en <strong>VR-SCRIPT,</strong> que es un lenguaje orientado a objetos con multitud de funciones y posibilidades.</p>
<p>Un ejemplo:</p>
<pre><code>class MyApp implements DOS_Program
{
   virtual Start ()
   {
      GetDOS().GetConsole().PrintLn(&quot;Hello World!&quot;);
      End(0);
   }
}</code></pre>
<p>Esto sería un ejemplo del típico “Hello World”. Obsérvese cómo se hace referencia a que es un programa VR-DOS. Realmente existen otros tipos de interfaces que se pueden implementar; según el tipo podremos disponer de diferentes funcionalidades, todo esto lo iremos viendo más adelante.</p>
<h4 id="cómo-podemos-editar-nuestro-programa-hello-world">¿Cómo podemos editar nuestro programa “Hello World”?</h4>
<p>Efectivamente, vamos a necesitar un editor de textos que nos permita crear este programa y posteriormente ejecutarlo desde la consola de comandos. Para ello, vamos a usar el editor de textos por defecto que se encuentre disponible. Escribiremos el comando “edit” y pulsaremos la tecla ENTER</p>
<figure>
<img src="media/aa3d0ad706f9418a95ca27d26dc06994.gif" alt="" /><figcaption>Imagen relacionada</figcaption>
</figure>
<pre><code>C:&gt;edit helloworld.pi</code></pre>
<p>Veremos que se nos muestra un editor de textos con el que podremos comenzar a introducir nuestro programa. Una vez introducido lo guardamos como “helloworld.pi” y salimos del editor. A continuación, desde la consola VR-DOS escribimos:</p>
<pre><code>C:&gt;helloworld 
Hello World!</code></pre>
<p>Es así como, efectivamente, ¡hemos ejecutado nuestro primer programa con éxito!</p>
<h1 id="editando-comandos">Editando comandos</h1>
<p>Cuando escribimos en la línea de comandos del VR-DOS, podemos editar y disponer de facilidades para arreglar errores o reintroducir y editar comandos anteriores.</p>
<p>Tecleando caracteres ordinarios provocamos que estos aparezcan en la pantalla como esperaríamos. Teclear un carácter de control causa que se vea representado por un símbolo ‘^’ seguido de la letra del control. Las excepciones son:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>CTRL + C</th>
<th>Este actúa como el CTRL+STOP e interrumpe drásticamente la ejecución de un programa o de un comando.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HOME o CTRL + K</td>
<td>Permite llevar el cursor al comienzo de la línea (HOME).</td>
</tr>
<tr class="even">
<td>ENTER o CTRL + M</td>
<td>Permite introducir un retorno de carro. Esto hace que el comando escrito proceda a ejecutarse.</td>
</tr>
<tr class="odd">
<td>BACKSPACE o CTRL + H</td>
<td>Borra y retrocede un carácter en la línea. Desde cualquier posición de la línea de comandos provocamos que se borre el carácter inmediatamente a la izquierda del cursor.</td>
</tr>
<tr class="even">
<td>TAB o CTRL + I</td>
<td>Introduce el siguiente nombre del archivo disponible que cumpla con la condición establecida o por defecto del directorio en curso.</td>
</tr>
<tr class="odd">
<td>INSERT o CTRL + R</td>
<td>Activa/Desactiva el modo de inserción de texto. Verás que la forma del cursor cambia de aspecto.</td>
</tr>
<tr class="even">
<td>CTRL + V</td>
<td>Volcamos el texto que tengamos en el portapapeles del sistema.</td>
</tr>
<tr class="odd">
<td>CTRL + Z</td>
<td>Finaliza la entrada de datos.</td>
</tr>
<tr class="even">
<td>ESC</td>
<td>Borra todos los caracteres de la línea que hayamos introducido.</td>
</tr>
</tbody>
</table>
<p>Con las teclas de CURSOR izquierda y derecha, moveremos el cursor a la izquierda o a la derecha una posición. Si tecleamos un carácter en esa posición sobrescribiremos el carácter que haya justo bajo la posición del cursor.</p>
<p>Si pulsamos la tecla INSERT (o entramos en modo inserción), veremos que el cursor cambia de aspecto y eso implicará que cuando escribamos no sobrescribiremos los caracteres sobre los que estemos, sino que los nuevos caracteres se insertarán en ese lugar, provocando que todos los que tengamos a la derecha del cursor se muevan tantas posiciones como caracteres tecleemos.</p>
<p>La tecla DEL borrará el carácter que tengamos justo bajo el cursor y moverá el resto de caracteres hasta el final de la línea una posición a la izquierda.</p>
<p>La tecla HOME moverá el cursor al comienzo de la línea.</p>
<p>La tecla END moverá el cursor al final de la línea.</p>
<p>Pulsando ESC borraremos todos los caracteres de la línea y será como comenzar de nuevo a introducir un comando.</p>
<p>El editor de comandos va almacenando los últimos 16 comandos que vayamos introduciendo. Pulsando CURSOR arriba/abajo nos moveremos a través de esta lista de comandos y los iremos mostrando en pantalla. De esta forma podemos volver a ejecutar o editar cualquier comando introducido y ahorrar el hecho de reescribir comandos de uso frecuente.</p>
<p>Mediante la tecla TAB (Tabulador) podemos ir alternando entre los distintos archivos y carpetas que se encuentran en el directorio en curso. De esta forma podemos agilizar la inserción de comandos que hagan referencia a archivos. Si pulsamos SHIFT+TAB recorreremos la lista a la inversa.</p>
<p>Pulsando CTRL+arriba/abajo podemos acceder al scroll de pantalla. De este modo podemos ver el texto que se haya salido de nuestro campo de visión. Si en cualquier momento pulsamos ESC (estando en el scroll) volveremos al símbolo de sistema y pasaremos de nuevo al modo edición de comando.</p>
<h1 id="notación-de-los-comandos">Notación de los comandos</h1>
<p>La sintaxis de los comandos disponibles en VR-DOS está descrita usando la siguiente notación:</p>
<h4 id="palabras-en-letras-mayúsculas">Palabras en letras mayúsculas</h4>
<p>Estas palabras pueden ser introducidas como se muestran o mezclando letras en mayúsculas y minúsculas.</p>
<h4 id="ítems-en-letras-minúsculas">Ítems en letras minúsculas</h4>
<p>Estos son los parámetros que debemos aportar al comando justo en ese punto de la línea del comando.</p>
<h4 id="ítems-entre-corchetes-y">Ítems entre corchetes (‘[’ y ’]’)</h4>
<p>Estos son ítems opcionales. Los mismos corchetes no deben ser incluidos en la línea de comando.</p>
<h4 id="ítems-separados-por-una-barra-vertical">Ítems separados por una barra vertical (‘|’)</h4>
<p>Esto indica que solo uno de los ítems es requerido. La barra vertical en sí misma no debe ser añadida a la línea de comando.</p>
<p>ITEMS</p>
<p>A continuación la lista de los ítems que pueden aparecer en una línea de comando:</p>
<h4 id="d">d:</h4>
<p>Esto indica que el nombre de la unidad es necesario (A:, B:, etc.).</p>
<p>Si d: se muestra como opcional y no se especifica, entonces se asumirá la unidad en curso, tal y como se muestra en el símbolo del sistema.</p>
<h4 id="path">path</h4>
<p>Esto indica que una ruta a directorio es requerida. Cada directorio en la ruta está separado por una barra invertida ‘\’ o ‘/’. La barra invertida al comienzo de la ruta indica que se empieza desde el directorio raíz; de otro modo la ruta comenzaría a tenerse en cuenta desde el directorio actual tal y como indica el símbolo de sistema o también a través del comando CHDIR. Frecuentemente un nombre de archivo sigue a una ruta, en cuyo caso ambos han de estar separados por una barra invertida ‘\’ o ‘/’.</p>
<p>NOTA: Además de la barra invertida, el VR-DOS acepta el uso de la barra normal ‘/’ para separar directorios y archivos en una ruta.</p>
<p>Dos puntos consecutivos ‘..’ indican el directorio padre al indicado en la ruta. Un único punto ‘.’ Indica el directorio actual y su uso no tiene valor en la especificación de una ruta.</p>
<p>Si una ruta se muestra como opcional y no se especifica entonces el directorio actual, tal y como se indica en el símbolo del sistema o usando el comando CHDIR, es el que se usa.</p>
<p>La sintaxis de los nombres de directorio que forman el nombre de una ruta de acceso sigue a la de los nombres de archivo que se indican a continuación:</p>
<h4 id="filename">filename</h4>
<p>Esto indica que se requiere el nombre de un archivo, cuya sintaxis es similar a MS-DOS y MSX-DOS 1. Un nombre de archivo ambiguo es aquel que contiene los caracteres ‘*’ y ‘?’ y puede coincidir con más de un archivo en el disco, mientras que uno que no contiene estos es un nombre de archivo inequívoco.</p>
<p>Un nombre de archivo tiene la siguiente sintaxis:</p>
<pre><code>     mainname[.ext]</code></pre>
<p>Donde mainname es una secuencia de hasta 8 caracteres (o 256 en su versión extendida) y la extensión es una secuencia de hasta 3 caracteres (o 256 en su versión extendida). Los caracteres que se encuentran fuera de estos campos se ignoran. Un ‘*’ en el nombre principal o en la extensión es equivalente a llenar desde esa posición de carácter al final del campo con ‘?’. La extensión, si existe, debe separarse de la parte principal del nombre de archivo por un solo punto ‘.’</p>
<p>Los siguientes caracteres no pueden ser usados en los nombres de archivo:</p>
<p>Códigos de control y el espacio (en los rangos entre 0 y 20h y 7Fh y FFh)</p>
<pre><code>     : ; . , = + \ &lt; &gt; ( ) | / &quot; ‘ [ ]</code></pre>
<p>Aunque se permitan caracteres en mayúsculas y minúsculas, para el sistema tienen el mismo significado. Por tanto, el archivo “ARCHIVO.TXT” es igual que “archivo.txt” e igual que “ArChiVo.TxT”.</p>
<p>Si un nombre de archivo se muestra como opcional y no se especifica, entonces un nombre de archivo *.* se asume por defecto.</p>
<h4 id="filespec">filespec</h4>
<p>Esto se utiliza para identificar un archivo o varios archivos en el mismo directorio en un disco. Su sintaxis es:</p>
<pre><code>     [d:][path][filename]</code></pre>
<p>Donde se debe especificar al menos uno de los tres elementos opcionales. Cuando se utiliza para especificar archivos existentes, /H se puede dar para permitir que se encuentren archivos ocultos.</p>
<p>Por lo general, si no se especifica d:, se hará referencia a la unidad actualmente conectada; si no se especifica ruta de acceso, se hará referencia al directorio actual de esa unidad; y si no se especifica el nombre de archivo se asignará el nombre por defecto ‘*.*’.</p>
<h4 id="compound-filespec">compound-filespec</h4>
<p>Esto se utiliza en muchos comandos para especificar los archivos o directorios a los que se aplica el comando. Su sintaxis es:</p>
<pre><code>     filespec [+ filespec [+ filespec ...]]</code></pre>
<p>Así, se pueden dar varios filespecs (ver arriba), separados por símbolos ‘+’, con espacios, etc., permitidos a ambos lados del signo +. El efecto de esto en los comandos es exactamente igual que si todos los archivos coincidentes pudieran haber sido emparejados por una sola especificación de archivos.</p>
<p>Cuando se especifica una composición de varios ficheros, /H puede darse después de cada fichero (véase más arriba), en cuyo caso solo tendrá efecto para los ficheros que coincidan con ese fichero único. Si se usa /H antes de la notación compuesta, entonces se aplicará sobre todos los filespecs.</p>
<h4 id="volname">volname</h4>
<p>Esto indica que se requiere un nombre de volumen. Un nombre de volumen es una secuencia de hasta 11 caracteres, que puede incluir los caracteres no válidos para nombres de archivo con la excepción de los códigos de control y ‘/’, aunque los espacios principales se eliminarán.</p>
<h4 id="device">device</h4>
<p>Esto indica que uno de los cinco dispositivos estándar es necesario. Estos y su significado son:</p>
<pre><code> CON - E/S de pantalla / teclado

 NUL - dispositivo &#39;nul&#39;, no hace nada

 AUX - E/S auxiliar (por ejemplo, serie RS232)

 LST - salida de la impresora

 PRN - salida de la impresora</code></pre>
<p>A diferencia de otros sistemas, los dos puntos no son necesarios después del nombre del dispositivo.</p>
<p>Los nombres de los dispositivos se pueden utilizar generalmente dondequiera que se puedan utilizar los nombres de fichero. Por ejemplo, el comando COPY MYFILE PRN leerá el archivo MYFILE y lo escribirá en la impresora.</p>
<p>Cuando se utiliza el dispositivo CON como un nombre de archivo de entrada, las líneas se pueden escribir y editar de la misma manera que las líneas de comandos. Para finalizar la operación, se debe escribir CTRL+Z (^ Z) al principio de una línea. Por ejemplo, un pequeño archivo de texto llamado MYFILE se puede crear con el comando COPY CON MYFILE:</p>
<pre><code>        A:/&gt;COPY CON MYFILE
        All work and no play makes Jack a dull boy.
        Can you hear me?
        ^Z
        A:/&gt;</code></pre>
<p>A continuación se pueden escribir líneas de texto, y se escribirán en el archivo MYFILE. El comando se completará cuando se ingrese una línea que contenga un solo CTRL+Z. Si la escritura es dirigida al dispositivo NUL mediante el comando COPY CON NUL, entonces los caracteres escritos son sencillamente ignorados. Si se lee, entonces se devuelve inmediatamente una condición de fin de archivo (lo que equivale a escribir el CTRL+Z en el ejemplo anterior). Para la mayoría de los comandos, no tiene sentido especificar un dispositivo (el dispositivo CON no se puede eliminar mediante el comando ERASE, por ejemplo). Los comandos con los que es probable que se usen los dispositivos son aquellos que leen y escriben datos desde y hacia archivos, como CONCAT, COPY y TYPE.</p>
<h4 id="number">number</h4>
<p>Esto indica que se requiere un número, que puede estar en el rango 0 a 255 o 0 a 65535 dependiendo del comando.</p>
<h2 id="as">AS</h2>
<p>Herramienta que permite preprocesar, compilar y enlazar archivos PI, ASM y LIB. El formato de los archivos ASM es compatible con el que utiliza el compilador SDCC (SDZ80) y también con el SJASM. Además, incorpora otras funcionalidades como la gestión de bancos y preprocesador.</p>
<p>Ejemplo</p>
<pre><code>as /CODE 0x4000 /DATA 0xC000 /SIZE 32k /CPU Z80 /OUT game.rom game.asm msxlib.lib</code></pre>
<p>Parámetros</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>/CODE &lt;address&gt;</th>
<th>Establece la dirección base en la que ubicar la zona de código. Por defecto vale 0.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/DATA &lt;address&gt;</td>
<td>Establece la dirección base en la que ubicar la zona de datos. Por defecto vale 0.</td>
</tr>
<tr class="even">
<td>/ADD &lt;file&gt;</td>
<td>Permite agregar un archivo a una librería (.LIB).</td>
</tr>
<tr class="odd">
<td>/OUT &lt;file&gt;</td>
<td>Establece el archivo de salida del binario generado</td>
</tr>
<tr class="even">
<td>/SIZE &lt;size&gt;</td>
<td>Establece el límite o tamaño de nuestro archivo binario de salida. Este tamaño se puede establecer en Bytes, Kbytes o Megabytes. Por ejemplo: 100, 100K o 100M.</td>
</tr>
<tr class="odd">
<td>/CPU &lt;name&gt;</td>
<td>Permite definir para qué CPU se quiere generar el código máquina. Los valores pueden ser: Z80, R800 y MOS6510. Por defecto se considera Z80.</td>
</tr>
<tr class="even">
<td>/?</td>
<td>Muestra la ayuda en línea del comando.</td>
</tr>
</tbody>
</table>
<p>Compilar un archivo ASM</p>
<p>Los archivos .ASM han de cumplir con el formato que más adelante se comenta. Este formato es compatible con el usado en el estándar SDZ80 de la suite de utilidades del compilador SDCC y además aporta novedades. También es compatible parcialmente con la sintaxis del compilador SJASM de XL2S Entertaiment.</p>
<p>Ejemplo:</p>
<pre><code>.area _DATA
myWord:
    .ds 2
.area _CODE
_main:
    .romheader
    di
    im  1
    ld  sp, 0xF380
    ei
_bucle$:
    ld hl, #myWord
    inc (hl)
    jr _bucle$</code></pre>
<pre><code></code></pre>
<p>Supongamos que tenemos el código anterior en un archivo de texto “test.asm”. Podemos compilar nuestro ejemplo para generar una ROM MSX de 16Kb de la siguiente forma:</p>
<pre><code>as /CODE 0x4000 /DATA 0xC000 /SIZE 16K /OUT my.rom test.asm</code></pre>
<p>NOTA: Por defecto esto se compilará teniendo en cuenta que el código generado es para una CPU del tipo Z80.</p>
<p>Tras esto veremos en la consola que se ha compilado y posteriormente enlazado nuestra ROM. Automáticamente se habrán generados 3 archivos: “my.map”, “my.sym” y por supuesto “my.rom”.</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>my.map</strong></th>
<th>Podemos ver las direcciones y los símbolos que se han generado en la compilación de los distintos módulos (en nuestro caso, de “test.asm”).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>my.sym</strong></td>
<td>Archivo de texto con la relación entre etiquetas y direcciones. Este archivo es utilizado por las herramientas de depuración.</td>
</tr>
<tr class="even">
<td><strong>my.rom</strong></td>
<td>Nuestra ROM de 16Kb compatible MSX.</td>
</tr>
</tbody>
</table>
<p>Compilar un archivo PI</p>
<p>Veamos el siguiente ejemplo:</p>
<pre><code>class MyGame
{
    properties:
        myWord : ubyte;</code></pre>
<pre><code>    //CRT FOR THE ROM!
    function _main() : void
    {
        native
        {
            .romheader
            di
            im  1
            ld  sp, 0xF380
            ei
            call Init
        }
    }</code></pre>
<pre><code>    function Init () : void
    {
        while (1)
        {
            myWord++;
        }
    }
}           </code></pre>
<pre><code></code></pre>
<p>Supongamos que tenemos dicho ejemplo en un archivo “test.pi”. Vamos a proceder a compilarlo y generar una ROM, al igual que con el ejemplo anterior del ASM.</p>
<pre><code>as /CODE 0x4000 /DATA 0xC000 /SIZE 16K /OUT my.rom test.pi</code></pre>
<p>En este caso, vamos a ver que el AS va a convertir el código del archivo “test.pi” a código ensamblador y que generará el archivo “test.asm”.</p>
<p>NOTA: Cuidado con el nombre de los archivos que se usen porque puedes sobrescribir archivos que no deseas.</p>
<p>Del mismo modo, tras finalizar el proceso obtendremos los archivos “my.map”, “my.sym”, “my.rom”, además del fichero “test.asm” con el código generado a partir del archivo PI.</p>
<p>Crear una librería</p>
<p>Una librería es un conjunto de módulos precompilados que se ubican tras un único archivo (.LIB). Gracias a esto podemos gestionar y distribuir código de una manera más cómoda, además de compartirlo sin comprometer el código fuente. Ejemplo:</p>
<pre><code>as /OUT my.lib
as /OUT my.lib /ADD test1.asm
as /OUT my.lib /ADD test2.asm
as /OUT my.lib /ADD test3.pi</code></pre>
<p>Para inicializar una librería tan solo hemos de crear un archivo LIB vacío, al cual iremos agregando a continuación los distintos módulos que queramos.</p>
<p>Lo interesante de usar librerías es que nos permite aglutinar diferentes rutinas que luego el enlazador va a utilizar o no según el caso. Por tanto, aunque una librería sea muy grande y contenga una gran cantidad de rutinas, eso no significa que el enlazador vaya a incluirlas todas en el binario final: se tendrán en cuenta solo las utilizadas por el código compilado.</p>
<p>Archivos de texto ASM</p>
<div class="line-block">Comentarios | ; Comentario de línea |<br />
                                               | // Comentario de línea |<br />
                                               | /* Comentario de bloque */ |</div>
<p>|————————————————|—————————————————————————————————————————————————————————————————————————————| | .CPU &lt;mode&gt; | Establece el tipo de CPU a tener en cuenta a la hora de compilar el código. Se admiten los valores Z80, R800, MOS6502, MOS6510. | | .DEFINE &lt;label&gt; &lt;value&gt; | Permite crear una etiqueta y asociarle un valor. Ejemplo: | | .IF .ELIF .ELSE .ENDIF | Permite compilar condicionalmente. Ejemplo: | | .ERROR &lt;message&gt; | Permite generar un mensaje de error. Ejemplo: | | .ASSERT &lt;condición&gt; | Permite detener la compilación en el caso de que no se cumpla una condición. | | .MACRO &lt;name&gt; (&lt;params&gt;) &lt;code&gt; | Permite crear macros que pueden usarse más tarde como código. Ejemplo: | | .ENDMACRO | | | .INCLUDE &lt;file&gt; | Se Incluye el contenido del archivo de texto especificado, permitiendo su compilación dinámica. Ejemplo: | | .AREA &lt;name&gt; | Permite establecer un nuevo espacio de direccionamiento para las instrucciones que se compilen. Internamente se usan _CODE, _DATA y _BANK como áreas pensadas para la zona de código, de datos y para ubicar el código multibanco. | | .ORG &lt;address&gt; | Reinicia el offset del área de código _CODE. | | .MAP &lt;address&gt; | Reinicia el offset del área de datos _DATA. | | .ROMHEADER | Incluye en el binario la cabecera de una ROM MSX que consiste en 16 bytes y cuya dirección de inicio se establece en _CODE+0x10 Ejemplo: | | .DATA &lt;data&gt; .END | Permite insertar una secuencia de datos en formato UBYTE. Ejemplo: | | .FILE &lt;file&gt; .FILE(compress) &lt;file&gt; | Permite incluir un archivo como datos. También se permite la opción de especificar un tipo de compresión a la hora de incluirlo dentro del binario. Ejemplos: | | .MODULE &lt;name&gt; | Especifica el nombre del archivo que se compila. Su uso no es obligatorio. | | .OPTSDCC &lt;p&gt; &lt;v&gt; | Mantiene la compatibilidad con SDCC. | | .GLOBL &lt;label&gt; | Permite indicar qué etiquetas se quieren considerar visibles fuera del módulo. | | .DB &lt;values&gt; | Permite insertar uno o varios bytes. Estos valores estarán separados por comas. Ejemplo: | | .DW &lt;values&gt; | Permite insertar uno o varios words (16 bits). Estos valores estarán separados por comas. Ejemplo: | | .DQ &lt;values&gt; | Permite insertar uno o varios words (32 bits). | | .DS &lt;size&gt;, [&lt;value&gt;] | Permite insertar una cantidad de bytes que indiquemos. El valor que se guardará será un cero en caso de que no se indique ningún valor en un segundo parámetro. Ejemplo: | | .ASCII &lt;string&gt; | Inserta un string. Ejemplo: | | .ASCIIZ &lt;string&gt; | Inserta un string y agrega un cero indicando el final del string. | | .PETSCII &lt;string&gt; | Inserta un string en formato PETSCII (Commodore 64). | | .PETSCIIZ &lt;string&gt; | Inserta un string en formato PETSCII y agrega el cero final. | | Number | nnnn-&gt; decimal 0xnnnn -&gt; hexadecimal 0onnnn -&gt; octal 0bnnnn -&gt; binario | | String | “texto” | | &lt;text&gt;$: | Etiqueta Local | | &lt;text&gt;: | Etiqueta Global | | _BANK(x) | Obtiene el banco asociado a una etiqueta | | _WORD(x) | Obtiene la dirección de la etiqueta (16 bits) | | _BYTE(x) | Obtiene la parte baja de la dirección de la etiqueta (8 bits) | | &gt;(x) | Obtiene la parte baja de la dirección de la etiqueta (8 bits) Ejemplo: | | &lt;(x) | Obtiene la parte alta de la dirección de la etiqueta (8 bits) Ejemplo: | | Expresiones | Se pueden utilizar combinaciones de números, con etiquetas y operadores (+, -, *, /, &lt;&lt;, &gt;&gt;) |</p>
<pre><code>.DEFINE MYLABEL 5</code></pre>
<p>Nota: El valor puede ser un número o una cadena de texto.</p>
<pre><code>.IF MYLABEL == 1
    ld a, 5
.ELIF MYLABEL == 5
    ld a, 20
.ELSE
    ld a, 10
.ENDIF</code></pre>
<pre><code>.ERROR &quot;esto es un error&quot;</code></pre>
<pre><code>.MACRO MYMACRO (_a, _b)
    ld a, _a
    ld b, _b
.ENDMACRO</code></pre>
<pre><code>…</code></pre>
<pre><code>ld c, 5
MYMACRO(6, 7)</code></pre>
<pre><code>.INCLUDE &quot;myfolder/stdafx.h&quot;</code></pre>
<pre><code>.ROMHEADER</code></pre>
<p>Init:</p>
<p>// Aquí vendría todo el código de arranque de nuestra ROM.</p>
<pre><code>.DATA 5 6 7 8 10 20 .END</code></pre>
<pre><code>.FILE &quot;mymusic.wyz&quot;
.FILE(PLETTER) &quot;graphics.dat&quot;</code></pre>
<p>Los modos de compresión son: PLETTER, BITBUSTER, ZIP</p>
<pre><code>.DB 5
.DB 10, 15, 20, 30</code></pre>
<pre><code>.DW  1056
.DW 5, 3444, 0x33, 0b1113333444555</code></pre>
<pre><code>.DS 123
.DS 1000,0xFF
.DS (0x4000-$),0x00</code></pre>
<p>NOTA: $ hace referencia al offset actual dentro del AREA en curso.</p>
<pre><code>.ASCII &quot;Esto es un string&quot;</code></pre>
<pre><code>.ASCIIZ &quot;Esto es otro string&quot;</code></pre>
<pre><code>ld hl, &gt;(#myVar)</code></pre>
<pre><code>ld hl, &lt;#(myVar)</code></pre>
<p>NOTA: Cuando las palabras reservadas anteriormente citadas comienzan con “.”, es posible especificarlas también sin el “.”.</p>
<p>Un ejemplo:</p>
<pre><code>    CPU MOS6510
    ORG 0x0801  </code></pre>
<pre><code>    jsr 0xe544
    lda #0x03
    sta 0xd020
    sta 0xd021
    ldx #0x00
loop:
    lda text,x
    sta 0x0400+40*12,x
    inx
    cpx #40
    bne loop
wait:
    jmp wait
text:
    ascii &quot;              hello world               &quot;</code></pre>
<pre><code>    </code></pre>
<p>CPU Z80/R800</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Registros de 8 bits</th>
<th>A, B, C, D, E, H, L, R, HX, LX, HY, LY</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Registros de 16 bits</td>
<td>AF, AF’, BC, DE, HL, IX, IY, SP, PC</td>
</tr>
<tr class="even">
<td>Flags</td>
<td>C, NC, Z, NZ, NP, PO, PE, N, P, M</td>
</tr>
<tr class="odd">
<td>Opcodes</td>
<td>ADC, ADD, AND, BIT, CALL, CCF, CP, CPD, CPDR, CPI, CPIR, CPL, DAA, DEC, DI, DJNZ, EI, EX, EXX, HALT, IM, IN, INC, IND, INDR, INI, INIR, JP, JR, LD, LDD, LDDR, LDI, LDIR, MULUB, MULUW, NEG, NOP, OR, OTDR, OTIR, OUT, OUTD, OUTI, POP, PUSH, RES, RET, RETI, RETN, RL, RLA, RLC, RLCA, RLD, RR, RRA, RRC, RRCA, RRD, RST, SBC, SCF, SET, SRA, SLA, SRL, SUB, SLIA, SLL, TST, XOR</td>
</tr>
<tr class="even">
<td>Formato de Opcodes</td>
<td>&lt;opcode&gt; &lt;opcode&gt; &lt;op&gt; &lt;opcode&gt; &lt;op1&gt; &lt;op2&gt;</td>
</tr>
<tr class="odd">
<td>Indexación</td>
<td>En los opcodes que tienen parámetros que permiten indexación se puede establecer la misma de dos formas: (reg+nn) nn(reg) Ejemplo:</td>
</tr>
<tr class="even">
<td>Dirección de etiquetas</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>ld a, (ix+4)
ld a, 4(ix)
ld a, -4(ix)
ld a, (ix-4)</code></pre>
<pre><code>ld hl, #label </code></pre>
<p>Hace referencia a la dirección de la etiqueta.</p>
<pre><code>ld hl, (#label)</code></pre>
<p>Hace referencia al contenido de la dirección de la etiqueta.</p>
<p>CPU MOS 6502/6510</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Registros de 8 bits</th>
<th>A, X, Y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Registros de 16 bits</td>
<td>SP, PC</td>
</tr>
<tr class="even">
<td>Flags</td>
<td>N, V, B, D, I, Z, C</td>
</tr>
<tr class="odd">
<td>Opcodes</td>
<td>AND, ASL, ADC, BIT, BEQ, BNE, BRK, BPL, BCS, BMI, BVC, BVS, CLC, CLD, CPX, CPY, CMP, DEC, EOR, INC, INX, INY, JSR, JMP, LDA, LDX, LDY, LSR, ORA, PHP, RTI, RTS, ROL, ROR, SBC, SED, STA, STX, STY</td>
</tr>
<tr class="even">
<td>Formato de Opcodes</td>
<td>&lt;opcode&gt; #&lt;op&gt; &lt;opcode&gt; &lt;op&gt; &lt;opcode&gt; &lt;op&gt;, X &lt;opcode&gt; &lt;op&gt;, Y &lt;opcode&gt; (&lt;op&gt;) &lt;opcode&gt; (&lt;op&gt;, X) &lt;opcode&gt; (&lt;op&gt;), Y</td>
</tr>
</tbody>
</table>
<h2 id="assign">ASSIGN</h2>
<pre><code>ASSIGN [d: [d:]]</code></pre>
<p>Permite vincular unidades lógicas a unidades físicas. Las unidades físicas son las que tras ellas tienen montado un dispositivo E/S original. Las unidades lógicas son referencias a estas unidades.</p>
<p>Uso</p>
<p>Si no se especifica unidad alguna, todas las unidades lógicas que estuviesen asignadas se cancelan.</p>
<p>Si solo se indica una unidad, entonces se muestra en pantalla a qué unidad física hace referencia.</p>
<p>Si se especifican las dos unidades, entonces se vincula a la primera unidad (lógica o física) la segunda unidad (física).</p>
<p>NOTA: Cuando se monta una unidad lógica sobre una física, la primera unidad puede ser lógica o física. En el caso de ser lógica, perderá su anterior asignación. En el caso de ser física, pasará a ser lógica y podrá recuperar su anterior estado cuando pierda su asignación.</p>
<p>Ejemplos</p>
<pre><code>ASSIGN</code></pre>
<pre><code></code></pre>
<p>Elimina todas las unidades lógicas asignadas.</p>
<pre><code>ASSIGN A: B:</code></pre>
<p>Vincula la unidad lógica A: con la unidad física B: de manera que toda operación sobre la unidad A: se realizará en la unidad B:.</p>
<pre><code>ASSIGN A:</code></pre>
<pre><code></code></pre>
<p>Mostrará en pantalla que A: es lo mismo que B:.</p>
<h2 id="atdir">ATDIR</h2>
<pre><code>ATDIR +|-H [/H] [/P] compound-filespec</code></pre>
<p>Cambia el atributo de los directorios para hacerlos ocultos o visibles.</p>
<p>Uso</p>
<p>El “compound-filespec” especifica los directorios a seleccionar y cuyos atributos desean ser cambiados.</p>
<p>Si se usa +H, entonces los directorios seleccionados son marcados como ocultos y no se verán afectados por otros comandos de directorios o visualizados por el comando DIR, a menos que la opción /H sea dada con estos comandos.</p>
<p>La opción -H permite indicar que los directorios seleccionados son visibles, pero esto no tendrá efecto en aquellos directorios que ya estén ocultos a menos que indiquemos /H.</p>
<p>NOTA: Al contrario que los archivos, los directorios no pueden ser de solo lectura.</p>
<p>Cuando un error ocurre, el nombre del directorio que ha provocado el error se muestra junto al mensaje de error, pero el comando continúa con los siguientes directorios.</p>
<p>Si ocurren múltiples errores, se puede utilizar la opción /P que permite pausar el comando una vez los mensajes de textos rebasan el final de la pantalla.</p>
<p>El comando DIR /H puede ser usado para indicar los atributos actuales de los directorios.</p>
<p>Ejemplos</p>
<pre><code>ATDIR +H DIR1</code></pre>
<p>Marca el directorio llamado DIR1 como oculto.</p>
<pre><code>ATDIR -H DIR1/H</code></pre>
<pre><code></code></pre>
<p>Marca el directorio oculto DIR1 como visible.</p>
<pre><code>ATDIR +H DIR?</code></pre>
<pre><code></code></pre>
<p>Marca como ocultos los directorios que coincidan con DIR? (por ejemplo: DIR1, DIR2 y DIR3).</p>
<pre><code>ATDIR +H \DIR1+\DIR2</code></pre>
<p>Marca los directorios DIR1 y el DIR2 como ocultos.</p>
<h2 id="attrib">ATTRIB</h2>
<pre><code>ATTRIB +|-R|H [/H] [/P] compound-filespec </code></pre>
<p>Cambia los atributos de los archivos y los hace ocultos/visibles y de lectura/escritura o solo lectura.</p>
<p>Uso</p>
<p>El “compound-filespec” indica los atributos de qué archivos van a ser cambiados y el /H permite a los archivos ocultos también cambiar sus atributos.</p>
<p>Si se especifica +H, entonces los archivos seleccionados son marcados como ocultos y no se verán afectados por la mayoría de comandos o mostrados por el comando DIR a menos que se especifique el /H.</p>
<p>Si el -H se especifica, los archivos seleccionados se marcarán como visibles, pero solo se aplicará esto sobre los archivos que estén ocultos.</p>
<p>Si el +R se especifica entonces los archivos seleccionados se marcarán como de solo lectura. Los archivos de solo lectura no podrán ser escritos ni modificados.</p>
<p>Si el -R se especifica, los archivos seleccionados pasarán a ser de lectura/escritura.</p>
<p>Cuando un error ocurre, el nombre del archivo que ha provocado el error se muestra en pantalla junto al error, pero el comando continuará con el siguiente archivo. Si muchos errores ocurren podemos usar la opción /P que permitirá pausar el comando una vez se rebase el final de la pantalla.</p>
<p>Podemos ver los actuales atributos de los archivos usando el comando DIR.</p>
<p>Ejemplos</p>
<pre><code>ATTRIB +R FILE1</code></pre>
<p>El archivo FILE1 queda marcado como de solo lectura, y no será posteriormente modificable o eliminable.</p>
<pre><code>ATTRIB +H B:\DIR1\*.COM</code></pre>
<p>Marca todos los archivos * .COM en el directorio B:\DIR1 como ocultos y no se mostrarán con el comando DIR.</p>
<pre><code>ATTRIB -R -H \DIR1/H/P</code></pre>
<p>Todos los archivos de DIR1 serán habilitados para lectura/escritura y marcados como no ocultos. La salida, si la hay, se detendrá en la parte inferior de la pantalla.</p>
<pre><code>ATTRIB +R \DIR1 + \DIR2 + FILE1</code></pre>
<p>Todos los archivos de los directorios DIR1 y DIR2 y el archivo FILE1 quedan marcados como de solo lectura.</p>
<h2 id="basic">BASIC</h2>
<pre><code>BASIC [program][/model name]</code></pre>
<p>Ejecuta la aplicación VR-BASIC.</p>
<p>Uso</p>
<p>[program] es el nombre de un programa VR-BASIC en disco. El control se pasa al VR‑BASIC, que cargará y ejecutará el programa VR-BASIC si se ha especificado.</p>
<p>El comando de VR-BASIC CALL SYSTEM (“command”) se puede utilizar para volver a DOS, y el comando opcional “command”, que puede ser cualquier comando ejecutable en DOS, se ejecutará. Si el comando no se encuentra, entonces el archivo de proceso REBOOT.BAT se ejecutará en caso de existir.</p>
<p>Se puede indicar qué modelo de máquina virtual queremos usar. Por defecto, arrancará la máquina configurada por defecto para VR-BASIC.</p>
<p>Ejemplos</p>
<pre><code>BASIC</code></pre>
<p>Ejecutamos MSXVR BASIC.</p>
<pre><code>BASIC MYPROG.BAS</code></pre>
<pre><code></code></pre>
<p>Arrancamos el VR-BASIC y este a su vez cargará el programa MYPROG.BAS y lo ejecutará.</p>
<pre><code>BASIC MYPROG2.BAS /model MSXTR</code></pre>
<pre><code></code></pre>
<p>Arrancamos el VR-BASIC con una máquina virtual modelo MSXturboR, y este a su vez cargará y ejecutará el programa MYPROG2.BAS.</p>
<h2 id="buffers">BUFFERS</h2>
<pre><code>BUFFERS [number]</code></pre>
<p>Muestra o cambia el número de buffers (zonas de memoria reservadas para acelerar las lecturas/escrituras) de disco en el sistema.</p>
<p>Uso</p>
<p>Si no se define un número, entonces se mostrará el número de buffers de disco actualmente en el sistema; de lo contrario el número de buffers se cambiará al número especificado y la memoria ahora no utilizada se liberará para otros fines si el nuevo número es menor que el anterior. Si no hay suficiente memoria para el número especificado de buffers, se crean tantos como sea posible y no da error.</p>
<p>Aumentar el número de buffers de disco puede acelerar algunas aplicaciones, en particular aquellas que realizan accesos aleatorios a archivos. Definir el número por encima de 10 es poco probable que mejore el rendimiento, y utiliza memoria innecesariamente.</p>
<p>El área de memoria utilizada para buffers de disco también se utiliza para elementos de entorno y para abrir archivos. Por lo tanto, mantener los buffers ajustados al máximo posible puede impedir que algunos comandos funcionen (particularmente SET, COPY y CONCAT). Si alguno de estos comandos da un error de memoria insuficiente, reducir el número de buffers puede ayudar.</p>
<p>El número predeterminado de buffers en el sistema es 5, que será adecuado para la mayoría de los casos.</p>
<p>Ejemplos</p>
<pre><code>BUFFERS
 BUFFERS=5</code></pre>
<p>Muestra el número actual de buffers de disco, que en este caso es 5.</p>
<pre><code>BUFFERS 10 </code></pre>
<p>El número de buffers se incrementa hasta un máximo de 10.</p>
<pre><code>BUFFERS 5</code></pre>
<p>El número de buffers se reduce de nuevo a 5.</p>
<h2 id="chdir-cd">CHDIR / CD</h2>
<pre><code>CHDIR [d:] [path] or CD [d:] [path]</code></pre>
<p>Muestra o cambia el directorio actual.</p>
<p>Uso</p>
<p>Si no se especifica ninguna ruta, se imprime la ruta de directorio actual para la unidad actual o especificada. Esta es la ruta del directorio desde el directorio raíz al directorio actual.</p>
<p>Si se especifica una ruta de acceso, el directorio actual de la unidad actual o especificada se cambia al directorio especificado por la ruta de acceso.</p>
<p>Cada unidad tiene su propio directorio actual. Este permanece en el directorio especificado por el último comando CHDIR para esa unidad (o en el directorio raíz inicialmente) hasta que se da otro comando CHDIR o no se puede encontrar en el disco cuando se accede (porque el disco ha sido cambiado, por ejemplo). En ese caso, se devuelve al directorio raíz.</p>
<p>El comando CD es una forma abreviada del comando CHDIR proporcionada por conveniencia y compatibilidad con MS-DOS.</p>
<p>Tenga en cuenta que el <em>command prompt</em> puede cambiarse para mostrar el directorio actual con el comando SET PROMPT ON (consulte Variables de entorno).</p>
<p>Ejemplos</p>
<pre><code>CHDIR \DIR1</code></pre>
<p>El directorio actual de la unidad actual se cambia a DIR1.</p>
<pre><code>CHDIR A:DIR2</code></pre>
<p>El directorio actual de la unidad A: se cambia a DIR2.</p>
<pre><code>CD
 E:\DIR1</code></pre>
<p>Aparece el directorio actual de la unidad actual, que en este caso es DIR1.</p>
<pre><code>CHDIR A:
 A:\DIR2</code></pre>
<p>Aparece el directorio actual para la unidad A:, que es DIR2.</p>
<h2 id="chkdsk">CHKDSK</h2>
<pre><code>CHKDSK [d:] [/F]</code></pre>
<p>Comprueba la integridad de los archivos en el disco.</p>
<p>Uso</p>
<p>Se comprueba la integridad de las estructuras de datos en el disco de la unidad especificada o actual y se comprueba la pérdida de espacio en disco. Cuando se detectan errores en el disco, se toman medidas correctivas. Si se encuentran clústeres perdidos, se emite un aviso que permite convertir el espacio de disco perdido en espacio de disco utilizable o en archivos.</p>
<p>Si no se da la opción /F, entonces CHKDSK no escribirá ninguna corrección en el disco, pero se comportará como si lo hubiera hecho. Esto permite utilizar CHKDSK para ver qué efecto tendría sobre el disco en caso de usarse /F.</p>
<p>Ejemplos</p>
<pre><code>CHKDSK B:</code></pre>
<pre><code></code></pre>
<p>Se comprueba el disco de la unidad actual. Los errores encontrados no se grabarán en el disco.</p>
<pre><code>CHKDSK B:</code></pre>
<pre><code></code></pre>
<p>Se analiza el disco en la unidad B:. Los errores encontrados no se grabarán en el disco. A continuación, un ejemplo con comprobación del disco y corrección de errores:</p>
<pre><code>CHKDSK B: /F
Unmount Drive...
Check &amp; Repair Disk...
Mount Drive...
Checked!</code></pre>
<h2 id="cls-1">CLS</h2>
<pre><code>CLS</code></pre>
<p>Borra la pantalla.</p>
<p>Uso</p>
<p>Simplemente borra la pantalla y lleva el cursor a la posición superior izquierda de la pantalla.</p>
<p>Ejemplos</p>
<pre><code>CLS</code></pre>
<pre><code></code></pre>
<p>La pantalla se borra y se puede escribir otro comando.</p>
<h2 id="command2">COMMAND2</h2>
<pre><code>COMMAND2 [command]</code></pre>
<p>Invoca al intérprete de comandos.</p>
<p>Uso</p>
<p>[command] es cualquier comando que normalmente se puede escribir en el símbolo del sistema (como los comandos de este manual).</p>
<p>COMMAND2 es simplemente el nombre del intérprete de comandos en disco usado por MSX-DOS 2 y que por compatibilidad puede ejecutarse como un programa transitorio normal.</p>
<p>COMMAND2 crea una nueva instancia de la aplicación VR-DOS. Si indicamos un comando, se ejecutará el comando en la nueva instancia y, una vez finalizado, se cerrará y volveremos a la anterior. Si no especificamos un comando, se abrirá la nueva instancia y será decisión del usuario cuándo finalizar o cambiar.</p>
<p>Para salir de ella y volver a la anterior instancia, se usaría el comando EXIT por ejemplo.</p>
<p>Ejemplos</p>
<pre><code>COMMAND2</code></pre>
<pre><code>A:/&gt;</code></pre>
<pre><code></code></pre>
<p>Se carga otra copia de COMMAND2, e imprime su símbolo de sistema normal. EXIT saldrá de nuevo al símbolo de sistema original.</p>
<pre><code>COMMAND2 FILE.BAT</code></pre>
<p>Si ejecutamos esta sentencia en un archivo de proceso por lotes, una vez termine de procesarse el archivo FILE.BAT, se volverá de nuevo al archivo por lotes previo y ejecutará el comando justo a continuación de este.</p>
<h2 id="concat">CONCAT</h2>
<pre><code>CONCAT [/H] [/P] [/B] [/A] [/V] compound-filespec filespec</code></pre>
<pre><code></code></pre>
<p>Concatena los archivos.</p>
<p>Uso</p>
<p>El compound-filespec especifica los archivos que se van a unir, y /H permite que se unan los archivos ocultos.</p>
<p>El segundo parámetro filespec debe hacer referencia a un nombre de archivo inequívoco, que se crea antes de que se lean los archivos de origen. Cada archivo de origen se lee, se une al final del anterior y se escribe en el destino.</p>
<p>A medida que se lee cada archivo de origen, se muestra su nombre de archivo. Si por alguna razón el archivo no puede ser leído (por ejemplo, es el archivo que se ha creado como el destino), entonces el nombre de archivo aparece seguido por un mensaje de error y la operación de CONCAT continúa con el siguiente archivo de origen. Si se están concatenando muchos archivos, entonces /P hará que la salida haga una pausa al final de la pantalla hasta que se pulse una tecla.</p>
<p>Normalmente, la concatenación se realiza en archivos ASCII. Los archivos de origen se leen hasta el primer carácter de fin de archivo (CTRL+Z) y un único carácter de fin de archivo se agrega al destino después de que se hayan escrito todos los datos. Sin embargo, si se usa /B (modo binario), entonces no se da ninguna interpretación a los datos leídos y no se añade ningún dato adicional.</p>
<p>También es posible aplicar /B al destino o a cualquiera de los filespecs dentro del compound-filespec, y entonces se referirá solo a esos archivos. También es posible usar /A para revertir el efecto de /B.</p>
<p>La opción /V se puede usar para activar la verificación de escritura durante el mandato CONCAT (véase el comando VERIFY). Esto garantizará que los datos se escriban correctamente en los discos si el controlador de dispositivo que se utiliza tiene la característica, pero se ralentizará la operación a causa de la verificación.</p>
<p>Si CONCAT da un error de ‘No hay memoria suficiente’, probablemente reduciendo el número de buffers (véase el comando BUFFERS) o eliminando algunos elementos del entorno (véase Variables de entorno) liberará suficiente memoria.</p>
<p>Ejemplos</p>
<pre><code>CONCAT *.DOC ALL.PRN</code></pre>
<pre><code></code></pre>
<p>Se crea un nuevo archivo denominado ALL.PRN y todos los archivos que coincidan con *.DOC (por ejemplo FILE1.DOC, FILE2.DOC y FILE3.DOC) se unen y se escriben en el nuevo archivo, en el orden en que se encuentran en el disco. Cualquier archivo existente llamado ALL.PRN se sobrescribirá.</p>
<pre><code></code></pre>
<pre><code>CONCAT /H /P *.DOC ALL.DOC
 FILE1.DOC
 FILE2.DOC
 FILE3.DOC
 ALL.DOC -- Destination file cannot be concatenated</code></pre>
<p>Se crea un nuevo archivo denominado ALL.DOC y todos los archivos que coinciden con *.DOC se unen y se escriben en el nuevo archivo en el orden en que se encuentran en el disco. Dado que el archivo de destino ALL.DOC también coincide con el nombre de archivo de origen *.DOC, el mensaje se muestra y no se incluye en la concatenación. Al haber usado /H, los archivos ocultos también se concatenan y, dado que se usó /P, se solicita pulsar una tecla si el número de líneas de la lista de archivos es mayor que el de la pantalla.</p>
<pre><code>CONCAT /B FILE2.DOC + FILE3.DOC + FILE1.DOC ALL.DOC</code></pre>
<p>Se crea un nuevo archivo ALL.DOC y los archivos FILE2.DOC, FILE3.DOC y FILE1.DOC se unen en ese orden, y en modo binario, y se escriben en el nuevo archivo.</p>
<h2 id="config">CONFIG</h2>
<pre><code>CONFIG [/action] [/module [param][param]] </code></pre>
<pre><code></code></pre>
<p>Permite cambiar los parámetros de configuración del sistema o aplicar acciones sobre dicha configuración.</p>
<p>Uso</p>
<p>Si invocamos al comando sin ningún tipo de parámetro, se lanzará la aplicación de escritorio donde podremos configurar todo lo que se detalla a continuación:</p>
<p>Acciones disponibles:</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>/SAVE</th>
<th>Actualiza y guarda la configuración actual.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/LOAD</td>
<td>Carga la configuración que tengamos guardada.</td>
</tr>
<tr class="even">
<td>/RESET</td>
<td>Resetea el ordenador. Esto permite aplicar los cambios en la configuración.</td>
</tr>
</tbody>
</table>
<p>Módulos configurables:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 81%" />
<col style="width: 4%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
</colgroup>
<thead>
<tr class="header">
<th>/BOOT MODE &lt;mode&gt;</th>
<th><strong>&lt;mode&gt;</strong></th>
<th><strong>Funcionalidad:</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>DOS</strong></td>
<td>Arrancará directamente el VR- DOS.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>VM</strong></td>
<td>Arrancará en modo máquina virtual.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>BASIC</strong></td>
<td>Arrancará directamente el VR- BASIC.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>SYSTEM</strong></td>
<td>Arrancará directamente el VR- SYSTEM.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/BOOT CHECKSLOTS &lt;bool&gt;</td>
<td><strong>&lt;bool&gt;</strong></td>
<td><strong>Funcionalidad:</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>True</strong></td>
<td>Comprobará si hay cartuchos insertados al arrancar.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>False</strong></td>
<td>No hará comprobación de cartuchos insertados.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/BOOT LOGOSPEED &lt;speed&gt;</td>
<td>Permite indicar la velocidad a la que queremos visualizar el logo de inicio. Por defecto su valor será de 1. Los valores admitidos estarán entre 0 y 10.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/BOOT LOGO &lt;id&gt;</td>
<td>Indica qué tipo de logo inicializar en el arranque. Si se indica un 0, estaremos diciendo que no queremos ver ningún logo. Si indicamos un 1, usaremos el que hay por defecto. Para valores &gt; 1, se usarán los logos que se encuentren dentro de la carpeta de clases del sistema; de este modo, se pueden crear logos de arranque mediante el uso de VR-SCRIPT.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/BOOT VM_PARAMS &lt;params&gt;</td>
<td>Se indicarán los parámetros de inicialización de máquina virtual. Véase comando: <em>play</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/BOOT VM_MODEL &lt;model&gt;</td>
<td>Se indicará el modelo de máquina virtual con el que queremos arrancar.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/BOOT</td>
<td>Se mostrarán los valores existentes en la configuración de parámetros de arranque.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VIDEO RES &lt;w&gt; &lt;h&gt; &lt;bpp&gt; &lt;hz&gt;</td>
<td>Establece las dimensiones, resolución y frecuencia de refresco de pantalla con las que queremos trabajar. En caso de que establezcamos valores no soportados por el sistema, veremos un mensaje de error. En caso de que existan, para que se apliquen los cambios habrá que reiniciar el sistema.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VIDEO FPS &lt;mode&gt;</td>
<td><strong>&lt;mode&gt;</strong></td>
<td><strong>Funcionalidad:</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>SHOW</strong></td>
<td>Muestra en pantalla los fotogramas por segundo.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>HIDE</strong></td>
<td>Oculta los fotogramas por segundo en pantalla.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VIDEO OUTPUT &lt;mode&gt;</td>
<td><strong>&lt;mode&gt;</strong></td>
<td><strong>Funcionalidad:</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>ANALOG or TV</strong></td>
<td>Activa la salida de vídeo compuesto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>DIGITAL or HDMI</strong></td>
<td>Activa la salida de vídeo por HDMI.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VIDEO OVERSCAN &lt;x&gt; &lt;y&gt;</td>
<td>Permite ajustar el origen de visualización en la pantalla.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VIDEO ADJUST</td>
<td>Permite ajustar parámetros de la configuración de pantalla interactivamente.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VIDEO FX</td>
<td>Ajusta interactivamente aspectos relacionados con el filtro de efectos visuales de postproceso.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VIDEO</td>
<td>Muestra información sobre la configuración actual de vídeo.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/AUDIO VOLUME &lt;v&gt;</td>
<td>Permite configurar el volumen de sonido del sistema. El valor de &lt;v&gt; ha de estar entre 0 y 255.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/AUDIO PANNING &lt;v&gt;</td>
<td>Permite configurar el equilibrio de volumen estéreo. El valor de &lt;v&gt; ha de estar entre 0 (izquierda) y 255 (derecha), siendo 128 el valor que equilibra entre izquierda y derecha.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/AUDIO OUTPUT &lt;mode&gt;</td>
<td><strong>&lt;mode&gt;</strong></td>
<td><strong>Funcionalidad:</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>ANALOG o TV</strong></td>
<td>La salida de sonido se redirecciona a través del audio analógico (RCA + Ear).</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>DIGITAL o HDMI</strong></td>
<td>La salida de sonido se redirecciona por la salida digital (HDMI).</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/AUDIO</td>
<td>Muestra el estado de los parámetros configurados para el audio.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/AUDIO_SLOTS VOLUME &lt;v&gt;</td>
<td>Ajusta el volumen de la salida amplificada de los slots de cartucho. El valor de &lt;v&gt; estará entre 0 y 255, siendo 0 el silenciado completo del amplificador.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/AUDIO_SLOTS</td>
<td>Muestra información sobre el estado de la configuración del amplificador.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/ETH [ ON | OFF ]</td>
<td>Activa y habilita funcionalidad para usar la conexión de red Ethernet o bien la deshabilita.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/ETH</td>
<td>Muestra el estado y características de la conexión de red ETH.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/WIFI [ ON | OFF ]</td>
<td>Activa y habilita funcionalidad para usar la conexión de red WIFI o bien la deshabilita.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/WIFI SCAN</td>
<td>Permite escanear la red WIFI en busca de redes disponibles.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/WIFI CONNECT &lt;ssid&gt; [&lt;pwd&gt;]</td>
<td>Se conecta a un &lt;ssid&gt; de una red WIFI disponible y utiliza el &lt;pwd&gt; facilitado como parámetro. En caso de no especificar la contraseña de red requerida, se solicitará su introducción.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/WIFI DISCONNECT</td>
<td>En caso de estar conectados a una red WIFI, se cancelará la conexión.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/WIFI STATUS</td>
<td>Permite obtener información sobre el estado de la red WIFI.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/WIFI</td>
<td>Obtiene información sobre las propiedades relacionadas con la configuración del módulo de red WIFI.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/THEME PRESET [&lt;theme&gt;]</td>
<td>Permite aplicar un tema que tengamos configurado. Indicaremos el nombre del tema para aplicarlo.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/LOCALE [&lt;locale&gt;]</td>
<td>Establece el idioma con el que se desea mostrar la información de menús, ayuda, documentación y aplicaciones. &lt;locale&gt; ha de facilitarse en formato ISO 3166 de dos dígitos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/KEYBOARD [&lt;layout&gt;]</td>
<td>Configura la plantilla de idioma que usaremos para mapear el teclado del ordenador. El parámetro &lt;layout&gt; ha de facilitarse en formato ISO 3166 de dos dígitos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/ALIAS</td>
<td>Muestra el alias que tenemos asociado a nuestra placa MSXVR.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/ALIAS CHANGE &lt;alias&gt;</td>
<td>Cambia el alias asociado a la placa.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<table>
<thead>
<tr class="header">
<th>CONFIG /ETH ON</th>
<th>Activa la conexión de red a través del cable Ethernet.</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="copy-2">COPY</h2>
<pre><code>COPY [/A] [/H] [/T] [/V] [/P] [/B] [/S] source dest</code></pre>
<pre><code></code></pre>
<p>Copia datos de archivos o dispositivos a otros archivos o dispositivos.</p>
<p>Uso</p>
<p>La definición de source es</p>
<pre><code>     compound-filespec | device</code></pre>
<pre><code></code></pre>
<p>El compound-filespec especifica los archivos que se van a copiar. Puede ser la especificación del dispositivo. Si se usa /H entonces se pueden copiar archivos ocultos.</p>
<p>La definición de dest es:</p>
<pre><code>     [d:] [path] [filename] | device</code></pre>
<pre><code></code></pre>
<p>Por defecto d: y path hacen referencia a la unidad de disco y al directorio, respectivamente. Si cualquier parte del nombre de archivo es ambigua, entonces el carácter apropiado del nombre de archivo de origen se sustituye, permitiendo así que los archivos se renombren en el proceso. Si no se da el nombre de archivo, se utiliza el nombre de archivo de origen completo. Si el dest es un directorio sin ambigüedad, los archivos se copian en ese directorio con un nombre de archivo *.*.</p>
<p>COPY leerá tantos archivos de origen como sea posible en la memoria antes de escribir cualquier salida. Cuando no puede leer más en la memoria (por ejemplo, cuando se ha utilizado toda la memoria disponible) se escribirá cada archivo en el orden en que los haya leído. Cuando crea cada archivo de destino, muestra el nombre de archivo de origen. Si no puede crear el archivo de destino, se muestra un mensaje de error y la operación de copia continúa con el siguiente archivo. Se puede usar /P para hacer la pausa de salida al final de la pantalla.</p>
<p>Existen muchas razones para que COPY no pueda crear el destino, como por ejemplo un archivo de solo lectura que ya existe con el mismo nombre. A veces COPY se negará a crear el destino porque el usuario puede haber cometido un error. Por ejemplo, un archivo no se puede copiar en sí mismo, o varios archivos no se pueden copiar en un archivo. Se puede dar un error “No se puede crear el destino” si el destino de un archivo suprime un archivo de origen anterior o un archivo que ya se está utilizando para otra cosa (por ejemplo, el archivo de proceso en ejecución).</p>
<p>Si se especifica /A, se realiza una copia ASCII. Esto significa que los archivos de origen solo se leerán hasta el primer carácter de final de archivo (EOF) o carácter (CTRL+Z) y, a continuación, cada destino tendrá un carácter de final de archivo adjunto a él.</p>
<p>También es posible asignar un /A al destino o a cualquiera de los archivos origen, en cuyo caso se aplica solo a esa fuente o al dest especificado.</p>
<p>Se puede usar la opción /B para hacer la copia en modo binario, es decir, el archivo que se está leyendo se copiará tal cual y no se agregarán datos.</p>
<p>La opción /V se puede usar para activar la verificación de escritura durante el mandato COPY (véase el comando VERIFY). Esto garantizará que los datos se escriban correctamente en los discos si el controlador de dispositivo que se utiliza tiene la característica, pero ralentizará la operación.</p>
<p>La opción /S permite copiar carpetas recursivamente.</p>
<p>Normalmente, los archivos de destino tienen la misma fecha y hora que los archivos de origen. Sin embargo, se puede usar la opción /T para que los archivos de destino tengan la fecha y hora actuales. Los archivos de destino no estarán ocultos o de solo lectura, independientemente de los atributos de los archivos de origen. El comando ATTRIB se puede utilizar para cambiarlos.</p>
<p>Si COPY da un error de “No hay suficiente memoria”, probablemente reduciendo el número de buffers (véase el comando BUFFERS) o eliminando algunos elementos del entorno (consulte el capítulo 7 en Elementos de entorno) liberará suficiente área de trabajo.</p>
<p>Tenga en cuenta que el comando COPY es más simple que en MS-DOS y MSX-DOS 1 porque no puede concatenar archivos. Para ello, se dispone de un comando CONCAT (véase el comando CONCAT).</p>
<p>Ejemplos</p>
<pre><code>COPY FILE1 B:</code></pre>
<pre><code></code></pre>
<p>El archivo FILE1 se copia desde el directorio actual de la unidad actual al directorio actual de la unidad B:.</p>
<pre><code>COPY /H MSXDOS2.SYS + COMMAND2.COM B:</code></pre>
<pre><code></code></pre>
<p>Los dos archivos ocultos MSXDOS2.SYS y COMMAND2.COM se copian en la unidad B:, convirtiéndolo en un disco de arranque.</p>
<pre><code>COPY A:\DIR1 B:\DIR1 /V</code></pre>
<pre><code></code></pre>
<p>Todos los archivos del directorio DIR1 desde la raíz de la unidad A: se copian en un directorio similar en la unidad B: con verificación para asegurarse de que los archivos se escribieron correctamente.</p>
<pre><code>COPY B:</code></pre>
<pre><code></code></pre>
<p>Todos los archivos del directorio actual de la unidad B: se copian en el directorio actual de la unidad actual.</p>
<pre><code>COPY /A AUX CON</code></pre>
<pre><code></code></pre>
<p>Los caracteres se leen desde el dispositivo AUX (que se puede utilizar para la serie RS232, por ejemplo) al dispositivo CON, que es la pantalla. La copia se realiza hasta el primer carácter de fin de archivo.</p>
<pre><code>COPY A:*.DOC B:/T</code></pre>
<pre><code></code></pre>
<p>Todos los archivos del directorio actual de la unidad A: que coinciden con *.DOC (por ejemplo FILE1.DOC, FILE2.DOC y FILE3.DOC) se copian en el directorio actual de la unidad B: y se les da la fecha y hora actuales en lugar de las fechas y horas de los archivos *.DOC.</p>
<pre><code>COPY *.BAT</code></pre>
<pre><code>  AUTOEXEC.BAT -- File cannot be copied onto itself</code></pre>
<pre><code>  REBOOT.BAT -- File cannot be copied onto itself</code></pre>
<pre><code></code></pre>
<p>Este comando le indicó a COPY que copiara todos los archivos *.BAT (en este caso, AUTOEXEC.BAT y REBOOT.BAT) del directorio actual de la unidad actual al mismo lugar, y COPY mostró los mensajes para avisar de esto. Ningún dato en este caso fue realmente copiado.</p>
<pre><code>COPY *.BAT DIR2</code></pre>
<pre><code>  AUTOEXEC.BAT</code></pre>
<pre><code>  REBOOT.BAT -- Cannot overwrite previous destination file</code></pre>
<p>Este comando le indicó a COPY que copiara todos los archivos *.BAT (en este caso, AUTOEXEC.BAT y REBOOT.BAT) a un directorio llamado DIR2. Ese directorio, sin embargo, no existía, y por tanto el archivo AUTOEXEC.BAT se copió en un archivo denominado DIR2, y a continuación se intentó copiar REBOOT.BAT también a un archivo denominado DIR2. El mensaje se mostró como una advertencia de que probablemente se cometió un error (en este caso DIR2 no existe). REBOOT.BAT no se copió en realidad en ninguna parte.</p>
<h2 id="color-1">COLOR</h2>
<pre><code>COLOR [foreground [background [border]]]</code></pre>
<pre><code></code></pre>
<p>Uso</p>
<p>Cambia el color de primer plano (tinta), el de fondo y el de borde.</p>
<p>El valor de los parámetros va del 1 al 15. El valor 0 significa que se ignora el cambio y se deja el color que haya configurado en ese instante.</p>
<p>Ejemplos</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>COLOR 15 4 8</th>
<th>Cambia el color usado en las fuentes, fondo y borde.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COLOR 1</td>
<td>Cambia solo el color de las fuentes y deja el mismo para el fondo y borde.</td>
</tr>
<tr class="even">
<td>COLOR 0 0 6</td>
<td>Cambia solamente el color de borde.</td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<h2 id="date">DATE</h2>
<pre><code>DATE [date]</code></pre>
<p>Muestra o establece la fecha actual.</p>
<p>Uso</p>
<p>Si se introduce una fecha después del comando, entonces esta se establece así (véanse los posibles formatos más abajo). Si la fecha no se introduce después del comando, entonces se imprimirán el día y la fecha actuales y se solicitará introducir la nueva fecha. Si no se da ninguna entrada (es decir, si solo se pulsa la tecla ENTER), la fecha actual no se altera. De lo contrario, se supone que la entrada es una nueva fecha y se interpreta como se describe a continuación. Si la fecha no es válida, se mostrará un mensaje de error y se solicitará una nueva fecha.</p>
<p>La fecha constará de hasta tres números, separados por uno de los siguientes caracteres:</p>
<pre><code>     space tab , - . / :</code></pre>
<p>Se permiten espacios a ambos lados de cada carácter. Los números que falten aparecerán por defecto en la configuración actual. El año puede introducirse con dos o cuatro dígitos. De introducirse solo dos, si el año es mayor que 80 se asumirá el siglo XX; de lo contrario, se asumirá el siglo XXI. La fecha y las especificaciones del año se pueden sustituir por “-” para omitirse.</p>
<p>El formato en el que se muestra la fecha y la entrada es flexible y se puede cambiar. Un elemento de entorno denominado DATE se configura de forma predeterminada en un formato apropiado en función de la localización establecida en el sistema. El comando SET DATE = DD-MM-YY cambiará el formato de fecha al formato europeo. El formato también afecta a las fechas mostradas por el comando DIR.</p>
<p>Si se define el elemento de entorno DATE, se mostrará mediante el comando DATE para indicar el formato en el que se debe introducir la fecha.</p>
<p>Ejemplos</p>
<pre><code>DATE 86-6-18</code></pre>
<p>La fecha actual es 18 de junio de 1986.</p>
<pre><code>DATE
 Current date is Wed 1986-06-18
 Enter new date (yy-mm-dd): - -19</code></pre>
<p>No se dio ningún parámetro, por lo que se mostró la fecha actual del 18 de junio de 1986 y se solicitó una nueva fecha. En la respuesta a la solicitud, la fecha se actualizó al día siguiente solo especificando el 19. Como el año y el mes no fueron introducidos, permanecieron iguales.</p>
<pre><code>SET DATE = DD-MM-YY</code></pre>
<p>El formato de fecha cambia al formato europeo.</p>
<pre><code>DATE
 Current date is Thu 19-06-1986
 Enter new date (DD-MM-YY):</code></pre>
<p>No se introdujo ningún parámetro, por lo que la fecha actual del 19 de junio de 1986 se muestra en el formato europeo. La respuesta se espera en el formato europeo. Los formatos son:</p>
<p>ISO YY-MM-DD</p>
<p>Americano MM-DD-YY</p>
<p>Europeo DD-MM-YY</p>
<h2 id="dir">DIR</h2>
<pre><code>DIR [/H] [/W] [/P] [compound-filespec]</code></pre>
<p>Muestra los nombres de los archivos en el disco.</p>
<p>Uso</p>
<p>El compound-filespec especifica los archivos que se van a enumerar. Si se incluye la opción /H, también se mostrarán los archivos ocultos.</p>
<p>En el comando DIR, a diferencia de todos los demás comandos, está permitido no especificar el nombre principal del archivo o la extensión del nombre de archivo, y ambos predeterminarán ‘*’. Así, un nombre de archivo de ‘FRED’ es equivalente a ‘FRED.*’ Y un nombre de archivo de ‘.COM’ es equivalente a ‘*.COM’. Teniendo en cuenta que si se añade ‘.’ al final de un nombre principal de archivo, entonces se asume que también se ha especificado la extensión, por lo que el nombre de archivo ‘FRED.’ no es equivalente a ‘FRED.*’, a diferencia del ejemplo anterior.</p>
<p>Hay dos formatos de listado. Si se usa la opción /W, se muestra una lista “amplia”, con varios nombres de archivo por línea. Los nombres de subdirectorio, los atributos de archivo y la fecha y hora en que se creó cada archivo no se muestran.</p>
<p>Si no se usa la opción /W, los nombres de los archivos se muestran con un nombre de archivo por línea, junto con los atributos, el tamaño del archivo y la fecha y hora en que se modificó el archivo por última vez. Los atributos se muestran como una ‘r’ si el archivo es de solo lectura y una ‘h’ si el archivo está oculto (y se usó /H). Si la hora de un archivo es cero (es decir, el archivo no tiene una hora de modificación asociada), entonces el campo de hora no se mostrará. Si la fecha de un archivo es cero, entonces ni los campos de fecha ni de hora se mostrarán. Los formatos en los que se muestran las fechas y horas se pueden cambiar (véanse los comandos DATE y TIME).</p>
<p>La salida por pantalla cuando no se usa /W está diseñada para encajar dentro de una pantalla de 40 o de 80 columnas, de manera que muestra más caracteres en el nombre asociado al archivo o directorio. El número de archivos por línea que se muestran cuando /W se especifica también se ajusta según el ancho de pantalla. Si el ancho de la pantalla es menor de 13 caracteres, entonces, en ambos casos, los nombres de los archivos se ajustarán a la siguiente línea.</p>
<p>En la parte superior de la lista de archivos, se muestran el nombre de volumen del disco y el nombre del directorio que aparece en la lista. En la parte inferior aparecen el número de archivos enumerados, el número total de bytes en los archivos y la cantidad de espacio en disco restante.</p>
<p>Cuando se muestre el contenido de un subdirectorio, los dos primeros elementos enumerados siempre serán dos subdirectorios especiales denominados ‘.’ y ‘..’. Estos se crean automáticamente cuando se crea un nuevo directorio, y son los que permiten usar ‘.’ y ‘..’ en nombres de rutas para referirse a los directorios actual y anterior respectivamente.</p>
<p>Si se usa la opción /P, la salida se detendrá en la parte inferior de la pantalla hasta que se presione una tecla.</p>
<p>Ejemplos</p>
<pre><code>DIR</code></pre>
<p>Se mostrarán todos los nombres de archivos y directorios en el directorio actual de la unidad actual. Por ejemplo:</p>
<pre><code>Volume in drive A: is MSX-DOS 2
Directory of A:\ 

MSXDOS2  SYS r    4096 86-06-19  2:45p
COMMAND2 COM r   10496 86-06-19  2:46p
UTILS           &lt;dir&gt;  86-06-19  2:50p
HELP            &lt;dir&gt;  86-06-19  2:50p
 14K in 2 files   222K free</code></pre>
<p>Por tanto, el disco contiene los dos archivos de sistema MSX-DOS MSXDOS2.SYS y COMMAND2.COM, que son de solo lectura, y dos directorios denominados UTILS y HELP.</p>
<pre><code>DIR B:\HELP /W</code></pre>
<p>Se ha solicitado un formato de directorio “ancho” del directorio HELP de la unidad B :. El resultado sería:</p>
<pre><code>Volume in drive B: is MSX-DOS 2
Directory of B:\HELP</code></pre>
<pre><code>BUFFERS .HLP    ATTRIB  .HLP    ASSIGN  .HLP
ATDIR   .HLP    CHDIR   .HLP    CD      .HLP
SYNTAX  .HLP    ENV     .HLP    BATCH   .HLP
EDITING .HLP
 25K in 10 files   222K free</code></pre>
<pre><code></code></pre>
<pre><code>DIR UTILS\ + HELP\ /P</code></pre>
<p>Esto mostrará todos los archivos del directorio UTILS y todos los archivos del directorio HELP y se detendrá al final de cada pantalla completa.</p>
<pre><code>DIR .COM</code></pre>
<p>No se especificó nombre de archivo principal, por lo que el valor predeterminado es *. Así, este comando es equivalente al comando DIR *.COM.</p>
<pre><code>DIR COMMAND2</code></pre>
<p>No se ha especificado ninguna extensión, por lo que el valor predeterminado es .*. Por lo tanto, este comando es equivalente al comando DIR COMMAND2 .*.</p>
<h2 id="diskcopy">DISKCOPY</h2>
<pre><code>DISKCOPY source: dest: [/X]</code></pre>
<p>Copia un disco a otro.</p>
<p>Uso</p>
<p>La primera unidad es la unidad de origen y la segunda el destino; ambas unidades han de especificarse en el comando. Si no se especifican unidades, DISKCOPY devolverá un error.</p>
<p>Antes de utilizar DISKCOPY, el disco de destino debe formatearse con el mismo formato que el disco de origen, en caso contrario se producirá un error.</p>
<p>Es importante saber que el disco destino será borrado por completo.</p>
<p>Si se usa /X, entonces se suprimirán los mensajes mostrados durante la operación de copia de disco.</p>
<p>Tanto el disco de origen como el destino podrá ser o bien una unidad lógica (A:, B:, etc.) o bien un archivo con formato de imagen de disco (por ejemplo .DSK)</p>
<p>Ejemplos</p>
<pre><code>DISKCOPY A: B:
 Content of B: will be deleted. 
 Do you want continue (Y/N)?</code></pre>
<pre><code></code></pre>
<p>El comando copia el disco en la unidad A: al disco en la unidad</p>
<p>B:, destruyendo así todos los datos existentes en el disco en la unidad B:.</p>
<h2 id="dsktool">DSKTOOL</h2>
<pre><code>DSKTOOL [/C] [/I] [/D] [/A] [/E] [/R] [/Y] [/F fmt] dskPath [files]</code></pre>
<p>Permite la manipulación de archivos con formato DSK.</p>
<p>Uso</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 82%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
</colgroup>
<thead>
<tr class="header">
<th>/C</th>
<th>Crear un archivo DSK con el nombre establecido en &lt;dskPath&gt;. Por defecto el DSK se crea de tamaño 720Kb, FAT 12 y Boot Sector MSX-DOS 2.0.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/F</td>
<td>Especificar otro formato para la creación del DSK. En el parámetro &lt;fmt&gt; podemos indicar:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>SIZE</td>
<td>360, 720, 1440, 2880</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FAT</td>
<td>12, 16</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>BOOT</td>
<td>NONE, MSXDOS, MSXDOS2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>OEM</td>
<td>Etiqueta del volumen. Un identificador de 8 bytes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/D</td>
<td>Mostrar el contenido de los archivos y carpetas dentro del DSK.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/A</td>
<td>Añadir uno o varios archivos al DSK. Esta opción afectará a los ficheros mencionados en el parámetro &lt;files&gt;.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/E</td>
<td>Extraer archivos del DSK a las unidades locales. Esta opción afectará a los ficheros mencionados en el parámetro &lt;files&gt;.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/R</td>
<td>Borrar archivos contenidos dentro del DSK. Esta opción afectará a los ficheros mencionados en el parámetro &lt;files&gt;.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/I</td>
<td>Mostrar información sobre el formato del DSK.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/Y</td>
<td>Dar por defecto contestación afirmativa a cualquier petición del programa.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<pre><code>DSKTOOL /C /F SIZE=360,FAT=12,BOOT=MSXDOS,OEM=MYDSK mydsk.dsk</code></pre>
<pre><code>DSKTOOL /A mydsk.dsk text.txt ./images/bmp1.pic</code></pre>
<h2 id="echo">ECHO</h2>
<pre><code>ECHO [text]</code></pre>
<pre><code></code></pre>
<p>Imprime &lt;text&gt;.</p>
<p>Uso</p>
<p>El texto simplemente se muestra en la pantalla. Si no se introduce ningún texto, solo se emite una línea en blanco.</p>
<p>Este comando no debe confundirse con el estado “echo” de los archivos por lotes, controlado por un elemento de entorno denominado ECHO (véase Variables de Entorno).</p>
<p>Ejemplos</p>
<pre><code>ECHO AUTOEXEC batch file executed
 AUTOEXEC batch file executed</code></pre>
<pre><code></code></pre>
<p>El texto especificado (‘AUTOEXEC batch file executed’) se muestra en la pantalla.</p>
<pre><code>ECHO</code></pre>
<pre><code></code></pre>
<p>No se teclearon parámetros, por lo que solo se mostró una línea en blanco.</p>
<h2 id="edit">EDIT</h2>
<pre><code>EDIT [file]</code></pre>
<p>Abre la aplicación por defecto para la visualización y edición de textos.</p>
<p>Uso</p>
<p>Mediante el uso de este comando, podremos editar o crear un archivo de texto usando la aplicación que tengamos por defecto configurada para tal requerimiento. Si no especificamos ningún archivo, se abrirá la aplicación y desde ella se decidirán las acciones pertinentes.</p>
<p>Ejemplos</p>
<pre><code>EDIT </code></pre>
<pre><code>EDIT myfile.txt</code></pre>
<h2 id="era-erase-del">ERA / ERASE / DEL</h2>
<pre><code>ERA [/U] [/H] [/P] compound-filespec 
ERASE [/U] [/H] [/P] compound-filespec 
DEL [/U] [/H] [/P] compound-filespec</code></pre>
<p>Elimina uno o más archivos.</p>
<p>Uso</p>
<p>El compound-filespec especifica qué archivos tienen que ser eliminados. La opción /H permite también eliminar los archivos ocultos.</p>
<p>Durante la operación de borrado, si un archivo no se puede borrar por alguna razón (por ejemplo, por estar establecido de ‘solo lectura’), se mostrará el nombre del archivo en un mensaje de error y la operación de borrado continuará con el siguiente archivo. Si se producen muchos errores de este tipo, la opción /P hará que la salida se detenga al final de la pantalla.</p>
<p>Si el nombre de archivo es *.*, el siguiente texto:</p>
<pre><code>          Erase all files (Y/N) ?</code></pre>
<p>se muestra y se espera una respuesta. Si la respuesta es distinta de ‘Y’ o ‘y’, entonces la eliminación de archivos no se produce. Esta es una función de seguridad diseñada para evitar la pérdida accidental de todos los archivos en un directorio.</p>
<p>Si los archivos se eliminan involuntariamente en un disco, el comando UNDEL se puede utilizar inmediatamente después para restaurarlos de nuevo siempre que hayamos usado el parámetro /U.</p>
<p>Ejemplos</p>
<pre><code>ERASE FILE1.BAK</code></pre>
<pre><code></code></pre>
<p>El archivo FILE1.BAK se borra del directorio actual de la unidad actual.</p>
<pre><code>DEL *.COM/H</code></pre>
<p>Todos los archivos que coincidan con *.COM, tanto ocultos como no ocultos, se eliminan.</p>
<pre><code>DEL B:\UTIL\*.COM + B:\UTIL\*.BAT </code></pre>
<p>Todos los archivos que coincidan con *.COM o *.BAT se eliminan de B:\UTIL.</p>
<pre><code>DEL B:\UTIL
  Erase all files (Y/N) ? </code></pre>
<p>Todos los archivos del directorio denominados UTIL de la unidad B: se eliminan. Dado que se están eliminando tantos archivos, primero se muestra un mensaje para evitar una catástrofe.</p>
<pre><code>DEL *.BAT
 AUTOEXEC.BAT -- Read only file
 REBOOT.BAT -- Read only file</code></pre>
<h2 id="exit">EXIT</h2>
<pre><code>EXIT [number]</code></pre>
<pre><code></code></pre>
<p>Sale de COMMAND2.COM al programa de invocación.</p>
<p>Uso</p>
<p>El número es un código de error y el valor predeterminado es 0, que en VR-DOS indica ningún error.</p>
<p>EXIT sale de la instancia VR-DOS que ejecuta el comando y devuelve el código de error al programa que lo cargó e inició originalmente (consulte el comando COMMAND2). Esto puede ser otro VR-DOS u otro programa. En este último caso, se mostrará un mensaje de error apropiado y VR-DOS simplemente continuará su ejecución.</p>
<p>Cada instancia VR-DOS conserva sus variables de entorno.</p>
<p>Si el EXIT se realiza en la única instancia VR-DOS existente, aparecerá un diálogo de confirmación de apagado del sistema.</p>
<p>Ejemplos</p>
<pre><code>EXIT</code></pre>
<pre><code></code></pre>
<p>Se sale del intérprete de comandos. Lo que suceda a continuación depende de quién lo invocó.</p>
<pre><code>EXIT 40
 *** User error 40</code></pre>
<p>Se sale del intérprete de comandos con un código de error 40. Puesto que esto no corresponde a un error conocido por el sistema, quien haya cargado el intérprete de comandos muestra el mensaje de error en primer lugar.</p>
<h2 id="fixdisk">FIXDISK</h2>
<pre><code>FIXDISK [d:] [/S]</code></pre>
<pre><code></code></pre>
<p>Actualiza un disco al formato MSX-DOS 2 completo en unidades de disco flexible USB.</p>
<p>Uso</p>
<p>d: especifica la unidad en la que FIXDISK va a funcionar. Si d: no se especifica, se asumirá la unidad actual, y en caso de no ser una unidad USB de disco flexible devolverá un error.</p>
<p>El parámetro /S hace que el disco se actualice al disco MSX-DOS 2 completo.</p>
<p>El comando FIXDISK actualizará un disco para que sea totalmente compatible con MSX-DOS 2, y su uso permitirá el uso completo de las características de disco de MSX-DOS 2. Si se especifica la opción /S, el programa de arranque se actualizará para MSX-DOS 2 para que las funciones del disco MSX-DOS 2 puedan funcionar completamente. Sin embargo, cuando un disco se ha actualizado de esta manera, puede que ya no sea totalmente compatible con el sistema original. Por ejemplo, si se especifica la opción /S en el disco de la aplicación que utiliza un programa de arranque no estándar, como algunos juegos, la aplicación ya no se iniciará, aunque todavía podrá iniciar MSX-DOS 1 o MSX-DOS 2.</p>
<p>Para evitar actualizaciones accidentales de discos de arranque de otros sistemas, se emite un aviso antes de actualizar un disco.</p>
<p>Ejemplos</p>
<pre><code>FIXDISK B: /S
 Disk in drive B: will only be able to boot MSX-DOS 2
 Press any key to continue... </code></pre>
<pre><code></code></pre>
<p>La unidad B: se actualizará para que sea totalmente compatible con MSX-DOS 2. Dado que el disco puede haber sido un disco de arranque de otro sistema, se emite un aviso antes de que el disco se actualice.</p>
<h2 id="format">FORMAT</h2>
<pre><code>FORMAT [d:] [/FAT12] [/FAT16] [/FAT32] [/NTFS] [/EXT4] [/S640] [/S720] [/S1440] [/S1232] [/S1200]</code></pre>
<pre><code></code></pre>
<p>Formatea (inicializa) un disco.</p>
<p>Uso</p>
<p>La unidad especificada o actual se formatea y todos los datos del disco se destruirán.</p>
<p>Después de formatear, no habrá archivos o directorios en el disco y la cantidad máxima de espacio en disco será libre. El disco no tendrá un nombre de volumen, pero se le puede dar uno con el comando VOL. Para convertir el disco en un disco de arranque para que MSX-DOS se pueda iniciar desde él, los archivos MSXDOS2.SYS y COMMAND2.COM deben copiarse en él con el comando COPY.</p>
<p>Ejemplos</p>
<pre><code>FORMAT B:
 All data on drive B: will be destroyed
 Press space to continue... </code></pre>
<pre><code></code></pre>
<p>Este comando formatea el disco en la unidad B:. A continuación, se muestra el mensaje de advertencia estándar. Si queremos abortar el comando, podremos cancelar la operación mediante CTRL+C o CTRL+STOP.</p>
<pre><code>FORMAT</code></pre>
<pre><code></code></pre>
<p>Esto formateará la unidad actual.</p>
<h2 id="gr-geekreader">GR <a href="#geekreader">GeekReader</a></h2>
<p>GR es el comando que permite operar con el interfaz hardware del MSXVR.</p>
<p>Uso</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>/D</th>
<th>Detectar si hay un cartucho legible conectado y si disponemos de información en la base de datos.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/DC</td>
<td>Detectar si el cartucho insertado dispone de algún chip flash.</td>
</tr>
<tr class="even">
<td>/CA</td>
<td>Detectar las direcciones (si existen) del chip flash que pueda contener algún cartucho.</td>
</tr>
<tr class="odd">
<td>/DF &lt;filename&gt;</td>
<td>Detectar si el contenido de un archivo se encuentra registrado en la base de datos.</td>
</tr>
<tr class="even">
<td>/R</td>
<td>Detectar si hay algún cartucho conectado y ejecuta su contenido.</td>
</tr>
<tr class="odd">
<td>/Sn</td>
<td>Especificar el slot que queremos usar, siendo &lt;n&gt; del 1 al 4. Si no lo indicamos buscará el primero que encuentre con un cartucho insertado.</td>
</tr>
<tr class="even">
<td>/M &lt;name&gt;</td>
<td>Determinar qué máquina queremos arrancar cuando usamos el /R.</td>
</tr>
<tr class="odd">
<td>/S &lt;filename&gt; &lt;address&gt; &lt;size&gt;</td>
<td>Guardar el contenido de un cartucho a un archivo. Si &lt;size&gt; es cero o no se indica, el sistema determinará el tamaño del cartucho.</td>
</tr>
<tr class="even">
<td>/P &lt;address&gt; &lt;size&gt;</td>
<td>Mostrar el contenido en pantalla de los datos ROM almacenados en un cartucho.</td>
</tr>
<tr class="odd">
<td>/PF &lt;filename&gt; &lt;address&gt; &lt;size&gt;</td>
<td>Mostrar el contenido en pantalla de los datos almacenados en un archivo. Si &lt;size&gt; es cero o no se indica, se usará el tamaño del archivo.</td>
</tr>
<tr class="even">
<td>/L &lt;filename&gt; &lt;address&gt; &lt;mapper&gt;</td>
<td>Cargar el contenido de un archivo a un chip de memoria flash, si este se ha detectado. El guardado tendrá en cuenta la dirección donde guardar y el tipo de mapper necesario (por defecto es “GENERIC” pero también podrá ser “ASCII8”, “ASCII16”, “KONAMI4”, “KONAMI5”, “MSXVR”).</td>
</tr>
<tr class="odd">
<td>/C &lt;filename&gt; &lt;address&gt; &lt;size&gt; &lt;fileoffset&gt;</td>
<td>Comparar byte a byte el contenido de un cartucho con el contenido de un archivo.</td>
</tr>
<tr class="even">
<td>/E</td>
<td>Borrar el contenido de un chip de memoria flash (si este ha sido detectado)</td>
</tr>
<tr class="odd">
<td>/OFF</td>
<td>Desconectar el voltaje de los slots para poder hacer inserción o extracción de cartuchos en modo seguro. ¡IMPORTANTE! Se debe confirmar que los leds asociados al SLOT VCC se apagan y que se escucha el sonido del clic del relé.</td>
</tr>
<tr class="even">
<td>/ON</td>
<td>Conectar el voltaje de los slots para poder acceder al contenido de los cartuchos. Observar que los leds asociados al SLOT VCC se encienden.</td>
</tr>
<tr class="odd">
<td>/DASM &lt;address&gt; &lt;size&gt;</td>
<td>Desensamblar el contenido de la ROM de un cartucho a partir de una dirección y dentro del rango de bytes indicados en el parámetro &lt;size&gt;.</td>
</tr>
<tr class="even">
<td>/DASMF &lt;filename&gt; &lt;offset&gt; &lt;size&gt;</td>
<td>Desensamblar el contenido de un archivo a partir de un desplazamiento &lt;offset&gt; y en un número de bytes determinado en &lt;size&gt;. En caso de que &lt;size&gt; sea cero o no se indique, se considerá el tamaño del archivo.</td>
</tr>
<tr class="odd">
<td>/POKE &lt;address&gt; &lt;value&gt;</td>
<td>Escribir un byte en una determinada posición de memoria.</td>
</tr>
<tr class="even">
<td>/PEEK &lt;address&gt;</td>
<td>Mostrar en pantalla el contenido (1 byte) de una determinada posición de memoria.</td>
</tr>
<tr class="odd">
<td>/OUTP &lt;port&gt; &lt;value&gt;</td>
<td>Escribir en un puerto un determinado valor.</td>
</tr>
<tr class="even">
<td>/INP &lt;port&gt;</td>
<td>Leer el valor de un puerto.</td>
</tr>
<tr class="odd">
<td>/RESET</td>
<td>Aplicar un RESET a todo el interfaz GR.</td>
</tr>
<tr class="even">
<td>/FAST</td>
<td>Permitir la ejecución en modo rápido de algunos comandos. Por defecto está desactivada.</td>
</tr>
<tr class="odd">
<td>/IN &lt;input&gt;</td>
<td>Establece un archivo de entrada. Se utiliza en conversión o aplicación de parches.</td>
</tr>
<tr class="even">
<td>/OUT &lt;output&gt;</td>
<td>Establece un archivo de salida. Se utiliza en conversión o aplicación de partches.</td>
</tr>
<tr class="odd">
<td>/IPS &lt;path&gt;</td>
<td>Indica el archivo con formato IPS para aplicarse sobre un archivo de entrada y que generará un archivo de salida.</td>
</tr>
<tr class="even">
<td>/?</td>
<td>Mostrar la ayuda asociada en pantalla.</td>
</tr>
</tbody>
</table>
<h2 id="help">HELP</h2>
<pre><code>HELP [subject][/rebuild][/expandall]</code></pre>
<pre><code></code></pre>
<p>Proporciona ayuda en línea relacionada con los conceptos indicados en &lt;subject&gt;.</p>
<p>Uso</p>
<p>Si no se introduce ningún parámetro, abrirá la aplicación por defecto usada para ofrecer ayuda en línea al usuario del ordenador.</p>
<p>Toda la documentación en el ordenador se encuentra en la carpeta del sistema dedicada para esto. La documentación es multi-idioma y dependerá de este cómo se apliquen las búsquedas y también el tipo de información obtenida.</p>
<p>La documentación consta principalmente de archivos de texto en diferentes formatos, desde el más simple hasta otros con formato MarkDown por ejemplo.</p>
<p>HELP &lt;comando_dos&gt; sería equivalente a: &lt;comando_dos&gt; /?</p>
<p>Mediante el parámetro /rebuild, se analizarán todos los archivos de texto existentes en la carpeta de documentación por defecto. Este análisis permitirá reiniciar la base de datos en la que se apoya el comando para ofrecer la información solicitada.</p>
<p>El parámetro /expandall muestra la información de forma no compactada. Por efecto, visualmente se compacta la información que está relacionada bajo un mismo tema o capítulo. Es el usuario quien decide ampliar esta información.</p>
<p>Ejemplos</p>
<p>HELP Abrirá la aplicación</p>
<p>HELP COPY Sería equivalente a COPY /?</p>
<p>HELP Make me win 1000000$ Prueba a ver qué pasa</p>
<h2 id="history">HISTORY</h2>
<pre><code>HISTORY [/P] [/CLEAN]</code></pre>
<p>Lista de comandos usados más recientes.</p>
<p>Uso</p>
<p>Si se invoca sin parámetros mostrará por pantalla y en diferentes líneas, los comandos ejecutados en la consola VR-DOS.</p>
<p>Mediante el parámetro /P podemos pausar la salida por pantalla y mediante /CLEAN se limpiará el contenido de la lista.</p>
<p>Ejemplos</p>
<p>HISTORY</p>
<p>HISTORY /P</p>
<h2 id="kill-1">KILL</h2>
<pre><code>KILL [/PID id]</code></pre>
<pre><code></code></pre>
<p>Muestra la lista de procesos en marcha y además permite eliminarlos.</p>
<p>Uso</p>
<p>Si invocamos el comando sin parámetros, veremos la lista de procesos que tenemos en marcha. En esta lista veremos el nombre del proceso y también su identificador.</p>
<p>Mediante el parámetro /PID, podemos indicar el identificador del proceso que queremos eliminar. Si se elimina un proceso de esta forma y este contiene datos sin almacenar, se perderán.</p>
<p>Ejemplos</p>
<pre><code>KILL</code></pre>
<pre><code>KILL /PID 2</code></pre>
<h2 id="md-mkdir">MD / MKDIR</h2>
<pre><code>MKDIR [d:] path 
MD [d:] path</code></pre>
<p>Crea un nuevo subdirectorio.</p>
<p>Uso</p>
<p>El último elemento de la ruta de acceso es el nombre del nuevo subdirectorio que se va a crear en la unidad actual o especificada. Por lo tanto, si este es el único elemento en la ruta, el nuevo directorio se crea en el directorio actual. Si se va a ocultar el nuevo directorio, se debe ocultar por separado con el comando ATDIR.</p>
<p>Cuando se crea un nuevo directorio, está vacío, excepto para dos subdirectorios especiales llamados ‘.’ y ‘..’ . Estos se crean automáticamente en el directorio y son los que permiten incluir ‘.’ y ‘..’ en nombres de ruta para indicar los directorios actual y padre respectivamente (véase el capítulo 3 sobre Notación para una descripción de rutas).</p>
<p>El comando MD es una forma abreviada del comando MKDIR proporcionada por conveniencia y compatibilidad con MSX-DOS.</p>
<p>Ejemplos</p>
<pre><code>MKDIR UTIL</code></pre>
<p>Se crea un directorio llamado UTIL en el directorio actual de la unidad actual.</p>
<pre><code>MKDIR A:\UTIL\RAM</code></pre>
<p>Un directorio llamado RAM se crea en el directorio UTIL del directorio raíz de la unidad A:.</p>
<h2 id="mode">MODE</h2>
<pre><code>MODE number [/M]</code></pre>
<p>Cambia el número de caracteres por línea en la pantalla y el modo de color de texto.</p>
<p>Uso</p>
<p>El número debe estar en el rango de 1 a 80, ambos inclusive, y el número de caracteres por línea en la pantalla se ajustará a esto. La pantalla se borrará y el cursor se moverá a la esquina superior izquierda en el proceso.</p>
<p>Con /M indicamos que queremos usar el modo monocolor. Por defecto, se usa el modo multicolor de pantalla de texto.</p>
<p>Ejemplos</p>
<pre><code>MODE 80</code></pre>
<p>La pantalla se establece en el modo de 80 columnas multicolor y se borra en el proceso.</p>
<pre><code>MODE 25</code></pre>
<p>La pantalla se establece en 25 columnas monocolor.</p>
<h2 id="move">MOVE</h2>
<pre><code>MOVE [/H] [/P] compound-filespec [path]</code></pre>
<p>Mueve archivos de un lugar a otro del disco.</p>
<p>Uso</p>
<p>El compound-filespec especifica qué archivos tienen que ser movidos, y /H permite que los archivos ocultos se incluyan en el movimiento.</p>
<p>El path especifica el directorio al que se van a mover los archivos: se asume el directorio actual si no se especifica. La ruta de acceso debe existir en cada unidad a la que hacen referencia los filespecs de la lista de compound-filespec.</p>
<p>Si un archivo en particular no puede ser movido al directorio especificado o actual (por ejemplo, si ya existe un archivo del mismo nombre), se mostrará el nombre del archivo en cuestión junto con un mensaje de error y la operación de movimiento continuará con el siguiente archivo. Si se producen muchos errores, entonces la opción /P hará que la salida haga una pausa en la parte inferior de la pantalla.</p>
<p>Ejemplos</p>
<pre><code>MOVE FILE1 \ </code></pre>
<p>El archivo FILE1 se mueve del directorio actual de la unidad actual al directorio raíz de la unidad actual.</p>
<pre><code>MOVE /H /P E:*.COM \ </code></pre>
<pre><code>COMMAND2.COM -- File exists</code></pre>
<p>Todos los archivos que coincidan con * .COM, tanto ocultos como no ocultos, en el directorio actual de la unidad E: se mueven al directorio raíz de la unidad actual. El archivo COMMAND2.COM ya existía en el directorio raíz, por lo que se imprimió el error. Ninguno de los archivos COMMAND2.COM se movió o alteró. Si muchos de estos errores se hubieran producido, entonces se mostraría un mensaje después de una pantalla llena.</p>
<pre><code>MOVE \UTIL\*.COM + \UTIL\*.BAT</code></pre>
<p>Todos los archivos que coincidan con * .COM o * .BAT en un directorio llamado UTIL en la unidad actual se mueven al directorio actual de esa unidad.</p>
<h2 id="mvdir">MVDIR</h2>
<pre><code>MVDIR [/H] [/P] compound-filespec [path]</code></pre>
<p>Mueve directorios de un lugar a otro del disco.</p>
<p>Uso</p>
<p>El compound-filespec especifica qué directorios se van a mover, y /H permite que los directorios ocultos se incluyan en el movimiento.</p>
<p>El segundo parámetro especifica el directorio al que se van a mover los directorios, que es el directorio actual utilizado si se omite. Este directorio debe existir en cada unidad referenciada por las rutas indicadas en los compound-filespec.</p>
<p>Si un directorio particular no puede ser movido al directorio especificado o actual (por ejemplo, si ya existe un directorio del mismo nombre), entonces se muestra el nombre del directorio en cuestión junto con un mensaje de error y la operación de movimiento continúa con el directorio siguiente. Si se producen muchos errores, entonces la opción /P hará que la salida haga una pausa en la parte inferior de la pantalla.</p>
<p>Tenga en cuenta que no es posible mover un directorio a uno de sus propios subdirectorios, ya que esto produciría un árbol de subdirectorio no válido. En caso de aplicarse acabaría provocando un error.</p>
<p>Ejemplos</p>
<pre><code>MVDIR COM UTIL</code></pre>
<p>Un directorio llamado COM y todos sus directorios y archivos se trasladan a un directorio llamado UTIL, estando ambos directorios en el directorio actual de la unidad actual.</p>
<pre><code>MVDIR COM + BAT \UTIL</code></pre>
<p>Un directorio denominado COM y un directorio llamado BAT, y el contenido de ambos, se trasladan a un directorio denominado UTIL ubicado en el directorio raíz.</p>
<pre><code>MVDIR E:DIR? /H /P ALL</code></pre>
<pre><code>DIR2 -- Duplicate filename</code></pre>
<p>Todos los directorios de la unidad E: coincidentes con DIR? (por ejemplo, DIR1, DIR2 y DIR3), que pueden estar ocultos, y su contenido, se mueven a un directorio llamado ALL. Ya existía un directorio DIR2 en ALL, por lo que se mostró el error. El resto de directorios fueron desplazados, pero DIR2 no se vio afectado en absoluto.</p>
<h2 id="mount">MOUNT</h2>
<pre><code>MOUNT [/U] [/RW] [drive:] [username:password@][source]</code></pre>
<p>Permite el montaje y desmontaje de unidades lógicas para gestión de directorios y archivos.</p>
<p>Uso</p>
<p>Si no se especifica ningún parámetro, devolverá el número de unidades montadas hasta el momento. Solo devolverá las unidades accesibles (no ocultas) por el sistema.</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>/U</th>
<th>Permite el desmontaje de la unidad. Si la unidad &lt;drive:&gt; no existe, el comando devolverá un error.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/RW</td>
<td>Permite el montaje de lectura/escritura. Por defecto es de lectura únicamente.</td>
</tr>
</tbody>
</table>
<p>Si queremos montar una unidad, invocaremos el comando especificando el nombre de la unidad seguido por dos puntos, y en el parámetro &lt;source&gt; especificaremos el sistema de archivos al que queremos acceder. Este sistema de archivos podrá ser:</p>
<ul>
<li><p>Una URL a un servidor FTP</p></li>
<li><p>Una ruta a un archivo con extensión DSK</p></li>
<li><p>Una ruta a un archivo con extensión ZIP</p></li>
<li><p>Memoria RAM</p></li>
<li><p>Una ruta del sistema de directorios nativo. Nota: Se desaconseja usar este mecanismo. Es potencialmente peligroso.</p></li>
</ul>
<p>Si queremos montar un nombre de unidad que ya está montada, el comando devolverá error.</p>
<p>Ejemplos</p>
<pre><code>MOUNT /U A:</code></pre>
<p>Desmonta la unidad A:</p>
<pre><code>MOUNT /RW E: ftp://google.com/users/nirvana</code></pre>
<p>Monta una unidad E: para acceder al FTP indicado como parámetro.</p>
<p>MOUNT /RW B: SAMBA:MSXVR:MSXVR@192.168.0.198/Datos</p>
<p>Monta una unidad B: para acceder al recurso compartido en red, Datos, ubicado en la IP 192.168.0.198 para la cual, nos hemos identificado con el usuario MSXVR y password MSXVR.</p>
<p>MOUNT /RW B: FTP:MSXVR:MSXVR@msxlibrary.ddns.net</p>
<p>Monta una unidad B: para acceder al ftp indicado, para el cual, nos hemos identificado con el usuario MSXVR y password MSXVR.</p>
<p>MOUNT /RW A: C:/TEMP/DISK.DSK</p>
<p>Monta una unidad A: de solo lectura utilizando un archivo DSK.</p>
<p>MOUNT B: MEM:720K</p>
<p>Monta una unidad B: usando 720 Kbytes de memoria RAM.</p>
<p>MOUNT /RW Z: /root</p>
<p>Monta una unidad Z: con acceso a la carpeta nativa.</p>
<h2 id="path-1">PATH</h2>
<pre><code>PATH [ [+|-] [d:]path [ [d:]path [ [d:]path ...]] ]</code></pre>
<p>Muestra o establece rutas por defecto donde el sistema busca comandos COM y BAT.</p>
<p>Uso</p>
<p>Si no se especifican parámetros, se mostrarán las rutas de búsqueda actualmente establecidas, separadas por punto y coma (‘;’).</p>
<p>Si no se usan ni + ni -, entonces se eliminará cualquier ruta de búsqueda existente y se añadirá la ruta de búsqueda introducida.</p>
<p>Si se usa - antes de la lista de rutas, cada ruta introducida se eliminará de la ruta de búsqueda actualmente establecida, y se dará un error si alguna de las rutas dadas ya no existe.</p>
<p>Si se usa + antes de la lista de rutas, entonces cada ruta especificada se borrará primero de la ruta de búsqueda actualmente establecida si existe, y luego se añadirá al final. Esto permite cambiar el orden de las rutas en la ruta de búsqueda y permite añadir nuevas rutas al final de la ruta de búsqueda actual. Pueden añadirse tantas rutas de búsqueda como se desee, hasta un límite de 255 caracteres.</p>
<p>Al buscar un archivo COM o BAT, las rutas de la ruta de búsqueda actual se recorrerán en orden de izquierda a derecha. Se recomienda que las rutas de la ruta de búsqueda se especifiquen como rutas completas que comienzan en el directorio raíz y con la unidad especificada. Si este no es el caso, entonces el significado de la ruta de búsqueda podría cambiar cuando se cambia la unidad o el directorio actual.</p>
<p>La ruta de búsqueda se almacena como un elemento de entorno al que también se puede acceder con el comando SET.</p>
<p>Ejemplos</p>
<pre><code>PATH E:\COM E:\BAT</code></pre>
<p>Cuando se busca un comando COM o BAT, los directorios buscados serán el directorio actual de la unidad actual, el directorio COM en el directorio raíz de la unidad E: y el directorio BAT en el directorio raíz de la unidad E:, en ese orden.</p>
<pre><code>PATH
; E:\COM; E:\BAT</code></pre>
<p>No se asignaron parámetros; por tanto se muestra la ruta actual.</p>
<pre><code>PATH + A:\COM A:\BAT</code></pre>
<p>Los directorios A:\COM y A:\BAT se agregan al final de la ruta de búsqueda que existiese.</p>
<pre><code>PATH
; E:\COM; E:\BAT; A:\COM; A:\BAT</code></pre>
<p>Se muestra la nueva ruta de búsqueda.</p>
<pre><code>PATH - E:\COM E:\BAT</code></pre>
<p>Los directorios E:\COM y E:\BAT se eliminan de la ruta de búsqueda actual.</p>
<pre><code>PATH
; A:\COM; A:\BAT</code></pre>
<p>Se vuelve a mostrar la nueva ruta de búsqueda.</p>
<h2 id="net">NET</h2>
<pre><code>NET [/WIFI] [/ETH]</code></pre>
<p>Gestiona el acceso a redes.</p>
<p>Uso</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>/WIFI</th>
<th>Muestra información sobre la conexión WIFI.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/WIFI SCAN</td>
<td>Busca redes inalámbricas que se puedan alcanzar.</td>
</tr>
<tr class="even">
<td>/WIFI CONNECT &lt;ssid&gt; &lt;pwd&gt;</td>
<td>Se conecta a una red inalámbrica identificada con un SSID y una contraseña (si la tiene).</td>
</tr>
<tr class="odd">
<td>/WIFI DISCONNECT</td>
<td>Se desconecta de la red inalámbrica a la que estemos conectados. Si no estamos conectados no se hará nada.</td>
</tr>
<tr class="even">
<td>/ETH</td>
<td>Muestra información sobre la conexión Ethernet.</td>
</tr>
<tr class="odd">
<td>/ETH DHCP &lt;activar&gt;</td>
<td>Indica si se quiere activar el protocolo DHCP para la conexión, y por tanto, obtener una dirección IP de forma automática.</td>
</tr>
<tr class="even">
<td>/ETH IP &lt;ip&gt;</td>
<td>Permite asignar una dirección IP a nuestra conexión Ethernet.</td>
</tr>
<tr class="odd">
<td>/ETH GATEWAY &lt;ip&gt;</td>
<td>Establece la dirección IP de la puerta de enlace de nuestra red a otras redes.</td>
</tr>
<tr class="even">
<td>/ETH NETMASK &lt;mask&gt;</td>
<td>Establece la máscara de red.</td>
</tr>
<tr class="odd">
<td>/ETH BROADCAST &lt;ip&gt;</td>
<td>Establece la IP máscara para broadcasting en la red.</td>
</tr>
<tr class="even">
<td>/ETH PRIMARY_DNS &lt;ip&gt;</td>
<td>Se indica la dirección IP del servidor primario de resolución de nombres.</td>
</tr>
<tr class="odd">
<td>/ETH SECONDARY_DNS &lt;ip&gt;</td>
<td>Se indica la dirección IP del servidor secundario de resolución de nombres.</td>
</tr>
<tr class="even">
<td>/ETH UPDATE</td>
<td>Actualiza la conexión con los posibles cambios realizados previamente. O sea, aplica los cambios realizados en el DHCP, IP, GATEWAY, NETMASK, BROADCAST, PRIMARY_DNS y SECONDARY_DNS.</td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<pre><code>NET /WIFI SCAN          </code></pre>
<p>Buscamos redes inalámbricas.</p>
<pre><code>NET /ETH IP 192.168.0.120</code></pre>
<pre><code>NET /ETH UPDATE</code></pre>
<p>Cambiamos la IP que usamos en nuestra red local por conexión Ethernet.</p>
<pre><code>NET /ETH
 IP: 192.168.0.120
 NETMASK: 255.255.255.0
 BROADCAST: 192.168.0.255
 GATEWAY: 192.168.0.1
 DNS: 8.8.8.8 - 8.8.8.4
 MAC: 12:2B:43:54:33:22:12:AA
 DHCP: No</code></pre>
<p>Obtenemos información sobre nuestra conexión de red.</p>
<h2 id="pause">PAUSE</h2>
<pre><code>PAUSE [comment]</code></pre>
<p>Solicita y espera que se pulse una tecla en un archivo por lotes.</p>
<p>Uso</p>
<p>El comentario consiste en una secuencia arbitraria de caracteres.</p>
<p>El comentario, de introducirse, se muestra seguido del mensaje “Presione cualquier tecla para continuar” en la línea siguiente. El sistema entonces esperará a que se presione una tecla y mostrará la tecla pulsada si es un carácter imprimible. Si no se da un comentario como parámetro, solo se mostrará el mensaje.</p>
<p>El uso principal de este comando es emitir avisos desde dentro de un archivo por lotes.</p>
<p>Ejemplos</p>
<pre><code>PAUSE
Press any key to continue... </code></pre>
<p>No se introdujo ningún comentario, por lo que solo se mostró el mensaje.</p>
<pre><code>PAUSE Insert document disk in drive B:
Insert document disk in drive B:
Press any key to continue... </code></pre>
<p>Se ha introducido un comentario, por lo que se mostró, seguido de la solicitud de pulsación de una tecla.</p>
<h2 id="play-2">PLAY</h2>
<pre><code>PLAY [source] [/SYSTEM system] [/MODEL model] [/VERSION] [/WIZARD] [/PORTA port] [/PORTB port] [/STI path] [/SPEED speed] [/DEV device] [/CART1 path] [/CART2 path] [/CART3 path] [/CART4 path] [/MAPPER1 mapper] [/MAPPER2 mapper] [/MAPPER3 mapper] [/MAPPER4 mapper] [/MSX1] [/MSX2] [/MSX2+] [/MSXTR] [/SCC] [/OBSONET] [/FMPAC] [/PSG] [/MSXMUSIC] [/MSXAUDIO] [/IPS1 path] [/IPS2 path] [/IPS3 path] [/IPS4 path] [/tape path] [/DSK1 path] [/DSK2 path] [/DSK3 path] [/DSK4 path] [/GRSLOT1 params] [/GRSLOT2 params] [/VRT [path]] [/VRTDRV drv] [/VRISET mapper] [/SAFEMODE] [/VIRTUALIZED]</code></pre>
<p>Ejecuta y reproduce diferentes tipos de formatos multimedia.</p>
<p>Uso</p>
<p>Si no se especifica ningún parámetro, lanzará el explorador de archivos por defecto.</p>
<p>Extensiones soportadas y aplicaciones que se lanzan:</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>.ROM</th>
<th>Máquina virtual - Binario con volcado de ROM de cartucho. A menos que se establezca un modelo o sistema distinto, por defecto arranca una máquina MSX.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.BIN</td>
<td>Máquina virtual - Binario con volcado de ROM de cartucho. A menos que se establezca un modelo o sistema distinto, por defecto arranca una máquina ZX.</td>
</tr>
<tr class="even">
<td>.COL</td>
<td>Máquina virtual - Binario con volcado de ROM de cartucho. Arranca una máquina Coleco.</td>
</tr>
<tr class="odd">
<td>.SG</td>
<td>Máquina virtual - Binario con volcado de ROM de cartucho. Arranca una máquina Sega SG-1000.</td>
</tr>
<tr class="even">
<td>.DSK</td>
<td>Máquina virtual - Binario con volcado de contenido de un disco flexible. A menos que se establezca un modelo o sistema distinto, por defecto, arranca una máquina MSX.</td>
</tr>
<tr class="odd">
<td>.CAS</td>
<td>Máquina virtual - Formato digitalizado del contenido de una cinta de casete. Arranca una máquina MSX.</td>
</tr>
<tr class="even">
<td>.TAP</td>
<td>Máquina virtual - Formato digitalizado del contenido de una cinta de casete. A menos que se establezca un modelo o sistema distinto, por defecto arranca una máquina ZX.</td>
</tr>
<tr class="odd">
<td>.TZX</td>
<td>Máquina virtual - Formato digitalizado del contenido de una cinta de casete. Arranca una máquina ZX.</td>
</tr>
<tr class="even">
<td>.TSX</td>
<td>Máquina virtual - Formato digitalizado del contenido de una cinta de casete. Arranca una máquina MSX.</td>
</tr>
<tr class="odd">
<td>.CDT</td>
<td>Máquina virtual - Formato digitalizado del contenido de una cinta de casete. Arranca una máquina CPC.</td>
</tr>
<tr class="even">
<td>.Z80</td>
<td>Máquina virtual - Binario con el estado guardado de una máquina ZX. Arranca una máquina ZX.</td>
</tr>
<tr class="odd">
<td>.T64</td>
<td>Máquina virtual - Imagen de un casete de C64. Arranca una máquina C64.</td>
</tr>
<tr class="even">
<td>.CRT</td>
<td>Máquina virtual - Binario con volcado de ROM de cartucho. Arranca una máquina C64.</td>
</tr>
<tr class="odd">
<td>.PRG</td>
<td>Máquina virtual - Programa BASIC C64. Arranca una máquina C64.</td>
</tr>
<tr class="even">
<td>.D64</td>
<td>Máquina virtual - Imagen de disco de C64. Arranca una máquina C64.</td>
</tr>
<tr class="odd">
<td>.G64</td>
<td>Máquina virtual - Imagen de disco de C64. Arranca una máquina C64.</td>
</tr>
<tr class="even">
<td>.NIB</td>
<td>Máquina virtual - Imagen de disco de C64. Arranca una máquina C64.</td>
</tr>
<tr class="odd">
<td>.TGA</td>
<td>Imagen - TARGA</td>
</tr>
<tr class="even">
<td>.JPG</td>
<td>Imagen - JPEG</td>
</tr>
<tr class="odd">
<td>.BMP</td>
<td>Imagen - Windows BITMAP</td>
</tr>
<tr class="even">
<td>.PNG</td>
<td>Imagen - Portable Network Graphics</td>
</tr>
<tr class="odd">
<td>.SC2, .SR2, .GRP</td>
<td>Imagen - BSAVE MSX SCREEN 2</td>
</tr>
<tr class="even">
<td>.SC5, .SR5, .GE5</td>
<td>Imagen - BSAVE MSX SCREEN 5</td>
</tr>
<tr class="odd">
<td>.SC6, .SR6, .GE6</td>
<td>Imagen - BSAVE MSX SCREEN 6</td>
</tr>
<tr class="even">
<td>.SC7, .SR7, .GE7</td>
<td>Imagen - BSAVE MSX SCREEN 7</td>
</tr>
<tr class="odd">
<td>.SC8, .SR8, .GE8, .PIC</td>
<td>Imagen - BSAVE MSX SCREEN 8</td>
</tr>
<tr class="even">
<td>.SC10, .SCA, .SRA</td>
<td>Imagen - BSAVE MSX SCREEN 10</td>
</tr>
<tr class="odd">
<td>.SC11, .SCB, .SRB</td>
<td>Imagen - BSAVE MSX SCREEN 11</td>
</tr>
<tr class="even">
<td>.SC12, .SCC, .SRC</td>
<td>Imagen - BSAVE MSX SCREEN 12</td>
</tr>
<tr class="odd">
<td>.SC13, .SCD, .SRD</td>
<td>Imagen - BSAVE MSX SCREEN 13</td>
</tr>
<tr class="even">
<td>.GB9</td>
<td>Imagen - Team Bomba V9990</td>
</tr>
<tr class="odd">
<td>.SCR</td>
<td>Imagen - ZX-Spectrum SCREEN$</td>
</tr>
<tr class="even">
<td>.GIF</td>
<td>Imagen - Graphics Interchange Format</td>
</tr>
<tr class="odd">
<td>.PCX</td>
<td>Imagen - Run Length Encoded ZSoft Corp.</td>
</tr>
<tr class="even">
<td>.MKI</td>
<td>Imagen - Japanese MagView/Makichan Format Graphic</td>
</tr>
<tr class="odd">
<td>.MAG, .MAX</td>
<td>Imagen - Japanese MagView/Makichan Format Graphic</td>
</tr>
<tr class="even">
<td>.OGG</td>
<td>Audio - OGG Vorbis</td>
</tr>
<tr class="odd">
<td>.WAV</td>
<td>Audio - WAVE form audio file format</td>
</tr>
<tr class="even">
<td>.MP3</td>
<td>Audio - MPEG-1 Audio Layer III o MPEG-2 Audio Layer III</td>
</tr>
<tr class="odd">
<td>.KSS</td>
<td>Audio - Chiptune</td>
</tr>
<tr class="even">
<td>.VGM</td>
<td>Audio - Video Game Music</td>
</tr>
<tr class="odd">
<td>.VGZ</td>
<td>Audio - Video Game Music ZIP</td>
</tr>
<tr class="even">
<td>.TMU</td>
<td>Audio - Trilotracker</td>
</tr>
<tr class="odd">
<td>.PT3</td>
<td>Audio - Protracker 3.xx</td>
</tr>
<tr class="even">
<td>.WYZ</td>
<td>Audio - WyzTracker</td>
</tr>
<tr class="odd">
<td>.EVA</td>
<td>Vídeo - EVA</td>
</tr>
<tr class="even">
<td>.MP4</td>
<td>Video - MPEG-4</td>
</tr>
<tr class="odd">
<td>.MKV</td>
<td>Video - Matroska Video File</td>
</tr>
<tr class="even">
<td>.OGV</td>
<td>Video - OGG Vorbis Video</td>
</tr>
<tr class="odd">
<td>.FM</td>
<td>Texto - Archivo MSX-BASIC con música MML</td>
</tr>
<tr class="even">
<td>.BAS</td>
<td>Texto - Archivo MSX-BASIC</td>
</tr>
<tr class="odd">
<td>.LDR</td>
<td>Texto - Archivo MSX-BASIC</td>
</tr>
<tr class="even">
<td>.PI</td>
<td>Archivo VR-SCRIPT</td>
</tr>
<tr class="odd">
<td>.VGS</td>
<td>GameSaurus - Archivo de proyecto</td>
</tr>
<tr class="even">
<td>.TXT</td>
<td>Editor de texto - Texto sin formato</td>
</tr>
<tr class="odd">
<td>.MD</td>
<td>Editor de texto - Texto con formato MarkDown</td>
</tr>
</tbody>
</table>
<p>Parámetros:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 69%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
</colgroup>
<thead>
<tr class="header">
<th>/SYSTEM system</th>
<th>Indica el sistema sobre el que queremos trabajar: MSX, ZX, CPC, C64, SG1000, SC3000, COLECO, ADAM, etc.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/MODEL model</td>
<td>Indica el modelo que queremos usar. De este se extrae también el SYSTEM. Los modelos son las distintas configuraciones que tenemos de máquinas virtuales en el sistema.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VERSION</td>
<td>Obtiene información sobre la versión de la aplicación.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/WIZARD o /W</td>
<td>Lanza el asistente visual para gestionar todas las opciones del lanzador de máquinas virtuales.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/PORTA port /PORTB port</td>
<td>Establece un dispositivo asociado al puerto de juegos A y/o B. Los dispositivos pueden ser:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>&lt;port&gt;</strong></td>
<td><strong>Dispositivo</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VRI</td>
<td>VR-Interface. Puertos DB9.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Joystick1</td>
<td>Un joystick conectado al USB.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Joystick2</td>
<td>Un joystick conectado al USB.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Mouse</td>
<td>Un ratón conectado al USB.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/STI path</td>
<td>Archivo con el estado de una máquina virtual.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/SPEED speed</td>
<td>Velocidad de emulación. &lt;speed&gt; será un valor &gt;= 0, siendo 0 que la emulación está totalmente parada, 1 la velocidad normal, 2 el doble de la velocidad normal, y así en adelante.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/DEV device</td>
<td>Añade un dispositivo emulado a la configuración de la máquina virtual. Dependerá del sistema que los identificadores usados sean diferentes.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/CART1 path /CART2 path /CART3 path /CART4 path</td>
<td>Indica el archivo binario que contiene los datos de la ROM y que queremos asociar con uno de los slots de cartucho de la máquina virtual emulada. Es posible especificar hasta 4 slots de cartucho.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/MAPPER1 name /MAPPER2 name /MAPPER3 name /MAPPER4 name</td>
<td>Especifica el tipo de mapper a emular para cada cartucho asociado. El nombre &lt;name&gt; a usar dependerá del sistema emulado. Por ejemplo en MSX: ASCII8, ASCII16, KONAMI4, KONAMISCC, etc.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/IPS1 path /IPS2 path /IPS3 path /IPS4 path</td>
<td>Especifica el origen del archivo que se usará para aplicar los cambios (parches) sobre el binario ROM usado. El formato de este archivo será IPS.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/DSKA path /DSKB path</td>
<td>Determina el origen de los archivos con la imagen de disco flexible a utilizar para la unidad A: y B:.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/HDD1 path /HDD2 path</td>
<td>Determina el origen de los archivos con la imagen de disco duro a utilizar como maestro y esclavo en un interfaz IDE/SCSI o similar.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/GRSLOT1 slot</td>
<td>Redirecciona el slot usado para el cartucho 1.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/GRSLOT2 slot</td>
<td>Redirecciona el slot usado para el cartucho 2.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/MSX1</td>
<td>Usa una configuración MSX1 por defecto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/MSX2</td>
<td>Usa una configuración MSX2 por defecto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/MSX2+</td>
<td>Usa una configuración MSX2+ por defecto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/MSXTR</td>
<td>Usa una configuración MSXturboR por defecto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/SCC</td>
<td>Usar SCC emulado.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/OPL4</td>
<td>Usar OPL4 bien emulador o bien con cartucho real conectado.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/FMPAC</td>
<td>Usar FMPAC emulado. YM2413.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/PSG</td>
<td>Usar PSG externo (puertos 10h al 12h).</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/MSXAUDIO</td>
<td>Usar el Y8950.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/MSXMUSIC</td>
<td>Usar el YM2413.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/GFX9000</td>
<td>Usar emulación del V9990.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VRT</td>
<td>Lanzar VRTunnel en la unidad y carpeta actuales. La unidad se montará como C:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VRT path</td>
<td>Lanzar VRTunnel usando la ruta que establezcamos. La unidad se montará como C:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/VRTDRV drive</td>
<td>Indicar otra unidad de montaje diferente a C: para el VRTunnel.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VRISET</td>
<td>En el caso de usar un mapper de tipo VRI (MSXVR Slots) se fuerza el tipo de estrategia utilizar para acceder al slot.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>/SAFEMODE</td>
<td>Activa el modo seguro de tiempos para el acceso a los cartuchos en tiempo real.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/VIRTUALIZED</td>
<td>Desactiva cualquier tipo de cache y obliga a un acceso completo en tiempo real.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>play game.rom</th>
<th>Iniciará la ROM del juego y lo hará con una máquina MSX por defecto.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>play D:/roms/game.rom /model MSXTR</td>
<td>Lanzará la ROM y lo hará usando una máquina referenciada con el nombre de modelo MSXturboR.</td>
</tr>
<tr class="even">
<td>play video.mkv</td>
<td>Ejecutará el reproductor de vídeos y mostrará la película video.mkv.</td>
</tr>
<tr class="odd">
<td>play</td>
<td>Lanzará el explorador de archivos por defecto.</td>
</tr>
<tr class="even">
<td>play /w</td>
<td>Abrirá el asistente.</td>
</tr>
<tr class="odd">
<td>play *.rom /vrt</td>
<td>Abrirá una máquina MSX con el sistema VRTunnel accediendo a la carpeta y unidad en la que estemos.</td>
</tr>
<tr class="even">
<td>play *.rom /vrtdrv A: /vrt</td>
<td>Abre una máquina MSX usando VRTunnel y mapeando la unidad en A: para MSXDOS</td>
</tr>
</tbody>
</table>
<h2 id="pkg">PKG</h2>
<pre><code>PKG [/CLEAN] [/BACKUP] [/UPDATE] [/CHECK] [/FIND] [/INSTALL name] [/REMOVE name] [/Y]</code></pre>
<p>Gestiona la instalación de versiones del sistema operativo y de aplicaciones.</p>
<p>Uso</p>
<p>Los parámetros son:</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>/UPDATE</th>
<th>Actualiza el sistema a la última versión disponible.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/CHECK</td>
<td>Consulta sobre el estado de las actualizaciones.</td>
</tr>
<tr class="even">
<td>/INSTALL name</td>
<td>Descarga la última versión de un paquete o aplicación.</td>
</tr>
<tr class="odd">
<td>/REMOVE name</td>
<td>Elimina un paquete o aplicación del sistema.</td>
</tr>
<tr class="even">
<td>/FIND wildcard</td>
<td>Muestra los paquetes o aplicaciones disponibles para ser actualizados.</td>
</tr>
<tr class="odd">
<td>/CLEAN</td>
<td>Limpia la base de datos para realizar una actualización que parta de cero.</td>
</tr>
<tr class="even">
<td>/BACKUP</td>
<td>Sobrescribe la versión de copia de seguridad con la actualizada.</td>
</tr>
<tr class="odd">
<td>/Y</td>
<td>Evita las confirmaciones y las acepta por defecto.</td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<pre><code>PKG /CLEAN /UPDATE</code></pre>
<pre><code></code></pre>
<pre><code>PKG /FIND *</code></pre>
<pre><code></code></pre>
<h2 id="ramdisk">RAMDISK</h2>
<pre><code>RAMDISK [number[K]] [/D]</code></pre>
<p>Muestra o establece el tamaño de la RAM-Disk.</p>
<p>Uso</p>
<p>Si no se introducen parámetros, entonces se muestra el tamaño en kilobytes del RAM-Disk actual.</p>
<p>El número, de introducirse, especifica el tamaño máximo del nuevo disco RAM en kilobytes. El rango es de 0 a 4064. Si el número es 0 o solo se especifica /D, se eliminará la RAM-Disk. Este número se redondeará al múltiplo más cercano de 16Kb ya que la RAM-Disk siempre es un múltiplo de 16Kb. Se puede crear una RAM-Disk más pequeña que el tamaño máximo especificado si no hay suficiente memoria libre para el tamaño completo, aunque recibirá un error de “memoria insuficiente” si no hay memoria disponible. Tenga en cuenta que el número especificado es la cantidad máxima de RAM que se utilizará para la RAM-Disk, que no es lo mismo que la cantidad máxima de espacio libre disponible en la RAM-Disk recién creada, ya que el sistema necesita utilizar una parte para FAT o directorios.</p>
<p>En las máquinas MSX con 128Kb RAM, la cantidad máxima de disco RAM es 32Kb. En una máquina MSXVR el máximo de memoria permitido serán 8192Kb.</p>
<p>Si ya existe un disco RAM, aparecerá un mensaje de confirmación donde se nos pedirá confirmación de la destrucción de datos. Si usamos el parámetro /D no se solicitará esta confirmación y se procederá directamente a la eliminación de los datos existentes.</p>
<p>Después de haber creado un disco RAM, la unidad H: estará disponible.</p>
<p>Ejemplos</p>
<div class="line-block">RAMDISK | No se han especificado parámetros, por lo que se muestra el tamaño actual (en este caso 160Kb). |<br />
RAMDISK=160K | |</div>
<p>|—————————————————|———————————————————————————————————————————————————————————————–| | RAMDISK | No se han especificado parámetros, pero no había ningún disco RAM creado, por lo que se muestra el error. | | *** RAM disk does not exist | | | RAMDISK 300K | Ya existía un disco RAM, por lo que se mostró el mensaje. En este caso, la respuesta fue “y”, por lo que el disco RAM actual fue borrado y el nuevo configurado con un tamaño máximo de 300K. | | Destroy all data on RAM disk (Y/N)? y | |</p>
<pre><code></code></pre>
<h2 id="rem-1">REM</h2>
<pre><code>REM [comment]</code></pre>
<p>Introduce un comentario en un archivo por lotes.</p>
<p>Uso</p>
<p>El comentario se ignora simplemente y se ejecuta el siguiente comando. El comentario consiste en una secuencia de caracteres hasta una longitud máxima de una línea de comandos (127 caracteres).</p>
<p>Ejemplos</p>
<pre><code>REM This is my AUTOEXEC batch file</code></pre>
<p>Este comando, ya sea en un archivo por lotes o escrito, no hace nada con sus parámetros.</p>
<h2 id="ren-rename">REN / RENAME</h2>
<pre><code>RENAME [/H] [/P] compound-filespec filename
REN [/H] [/P] compound-filespec filename</code></pre>
<p>Cambia el nombre de uno o más archivos.</p>
<p>Uso</p>
<p>El compound-filespec especifica los ficheros que se van a renombrar, y /H permite que los archivos ocultos se incluyan en la operación de cambio de nombre.</p>
<p>El segundo nombre de archivo especifica el nuevo nombre para los archivos. El uso de ‘?’ en el nuevo nombre indica que se utilizará el carácter correspondiente del nombre de archivo que se renombra, permitiendo así un cambio de nombre ambiguo. Igualmente, usar ‘*’ (que es equivalente a una serie de ‘?’) en el segundo nombre de fichero indica que la totalidad del nombre de archivo o extensión permanecerá sin cambios.</p>
<p>Si por alguna razón no se puede cambiar el nombre de un archivo en particular (por ejemplo, si ya existe un archivo o un directorio con el nuevo nombre o si son de solo lectura), se mostrará el nombre del archivo en cuestión junto con un mensaje de error y la operación de cambio de nombre continuará con el siguiente archivo. Si se producen muchos errores, entonces /P hará que la salida se detenga al final de la pantalla.</p>
<p>Ejemplos</p>
<pre><code>RENAME FILE1 FILE2</code></pre>
<p>El archivo FILE1 en el directorio actual de la unidad actual se renombra FILE2.</p>
<pre><code>REN B:\DIR1\*.DOC /H /P *.OLD
FILE2.DOC -- Duplicate filename</code></pre>
<p>Todos los archivos que coinciden con *.DOC del directorio denominado DIR1 en el directorio raíz de la unidad B:, incluidos los archivos ocultos, se renombran con el mismo nombre principal pero con una extensión .OLD. El archivo FILE2.DOC no se pudo cambiar de nombre porque ya había un archivo llamado FILE2.OLD en el directorio, por lo que se mostró el error. Ni FILE2.DOC ni FILE2.OLD se alteraron en absoluto. De darse muchos errores, entonces se imprimiría un mensaje en la parte inferior de cada pantalla llena, ya que se introdujo /P.</p>
<pre><code>REN DOC + FILE1 *.OLD</code></pre>
<p>Todos los archivos del directorio DOC y el archivo FILE1, ambos del directorio actual de la unidad actual, se renombran con la extensión .OLD.</p>
<h2 id="reset">RESET</h2>
<pre><code>RESET [/HW]</code></pre>
<pre><code></code></pre>
<p>Uso</p>
<p>Aplica un reset en el sistema. Si no se especifica el parámetro /HW, el reset es por software, mientras que, si lo hacemos, el reset reiniciará la máquina al completo.</p>
<p>Un reset hardware permite inicializar dispositivos y configuraciones en el momento del encendido del ordenador. En ese sentido, un reset hardware reinicia el sistema operativo base de la plataforma.</p>
<p>Ejemplos</p>
<pre><code>RESET</code></pre>
<pre><code>RESET /HW</code></pre>
<h2 id="rmdir-rd">RMDIR / RD</h2>
<pre><code>RMDIR [/S] [/Y] [/U] [/H] [/P] compound-filespec
RD [/S] [/Y] [/U] [/H] [/P] compound-filespec</code></pre>
<p>Elimina uno o más subdirectorios.</p>
<p>Uso</p>
<p>El compound-filespec especifica qué directorios se deben eliminar, y /H permite que los directorios ocultos sean incluidos en la operación de borrado.</p>
<p>Para eliminar un directorio, no debe contener ningún otro archivo ni ningún otro directorio excepto los directorios especiales ‘.’ y ‘..’, que siempre existen. Estos se crean automáticamente en cada nuevo directorio y no se pueden eliminar. Son estos los que permiten utilizar ‘.’ y ‘..’ en los nombres de ruta para especificar los directorios actual y anterior respectivamente. En el caso de especificar /S, permitiremos borrar los archivos y carpetas que cuelgan del directorio a borrar y además hacerlo de forma recursiva. Usando el parámetro /Y aplicaremos afirmativo por defecto en las confirmaciones de seguridad.</p>
<p>Si no se puede borrar un directorio por alguna razón (por ejemplo, no está vacío), se mostrará el nombre del directorio en cuestión junto con un mensaje de error y la operación de eliminación continuará con el directorio siguiente. Si se producen muchos errores, entonces /P hará que la salida se detenga al final de la pantalla.</p>
<p>Ejemplos</p>
<pre><code>RMDIR DIR1</code></pre>
<p>Se elimina el directorio denominado DIR1 en el directorio actual de la unidad actual.</p>
<pre><code>RD B:\COM + B:\BAT</code></pre>
<p>Los directorios COM y BAT se eliminan del directorio raíz de la unidad B:.</p>
<pre><code>RD \*.*</code></pre>
<pre><code>UTIL -- Directory not empty</code></pre>
<p>Se ha intentado eliminar todos los directorios del directorio raíz de la unidad actual, pero un directorio llamado UTIL no estaba vacío y por lo tanto se mostró el error. UTIL y su contenido no se ven afectados en absoluto.</p>
<h2 id="rndir">RNDIR</h2>
<pre><code>RNDIR [/H] [/P] compound-filespec filename</code></pre>
<p>Cambia el nombre de uno o más subdirectorios.</p>
<p>Uso</p>
<p>El compound-filespec especifica los directorios que se van a renombrar, y /H permite que los directorios ocultos se incluyan en la operación de cambio de nombre. El contenido de los directorios permanece sin cambios.</p>
<p>El segundo nombre de archivo especifica el nuevo nombre para los directorios. El uso de ‘?’ en el nuevo nombre indica que se utilizará el carácter correspondiente del nombre del directorio que se renombra, lo que permitirá un cambio de nombre ambiguo. Igualmente, usar ‘*’ en el segundo nombre de fichero, que es justo equivalente a una serie de ‘?’, indica que la totalidad del nombre de archivo o extensión del nombre del directorio permanecerá sin cambios.</p>
<p>Si por algún motivo no se puede cambiar el nombre de un directorio en particular (por ejemplo, si ya existe un archivo o directorio con el nuevo nombre), se mostrará el nombre del directorio en cuestión junto con un mensaje de error y la operación de cambio de nombre continuará con el directorio siguiente. Si se producen muchos errores, entonces /P hará que la salida se detenga al final de la pantalla.</p>
<p>Ejemplos</p>
<pre><code>RNDIR UTIL COM</code></pre>
<p>El directorio llamado UTIL del directorio actual de la unidad actual se renombra como COM.</p>
<pre><code>RNDIR A:\*.* /H /P *.OLD
UTIL -- Duplicate filename</code></pre>
<p>Todos los directorios, ocultos y no ocultos, en el directorio raíz de la unidad A: se renombran con una extensión .OLD. El directorio UTIL no se pudo renombrar porque ya existía un directorio llamado UTIL.OLD, por lo que se mostró el error. Si se mostraran muchos de estos errores, entonces /P causaría que se mostrara un mensaje al final de cada pantalla.</p>
<pre><code>RNDIR COM + BAT *.OLD</code></pre>
<p>Los directorios COM y BAT se renombran COM.OLD y BAT.OLD, respectivamente.</p>
<h2 id="set">SET</h2>
<pre><code>SET [name] [separator] [value]</code></pre>
<p>Muestra/configura los elementos del entorno.</p>
<p>Uso</p>
<p>Si no se proporcionan parámetros, se muestran todos los elementos del entorno actualmente definidos y sus valores actuales. Inicialmente, hay varios elementos configurados con valores predeterminados.</p>
<p>Si solo se indica un nombre como parámetro, se mostrará el valor actual del elemento de entorno especificado.</p>
<p>Si el nombre es seguido por un separador, se le asigna a esa variable el valor que se haya especificado a continuación. Si el valor está en blanco, el elemento de entorno se eliminará.</p>
<p>El área de memoria utilizada para los elementos de entorno también se utiliza para los buffers de disco. Por lo tanto, si se produce un error de “memoria insuficiente” cuando se utiliza el comando SET, puede ayudar reducir el número de buffers de disco (véase el comando BUFFERS).</p>
<p>Ejemplos</p>
<pre><code>SET
 ECHO=OFF
 PROMPT=OFF
 PATH=;
 TIME=12
 DATE=yy-mm-dd
 HELP=$SYSTEM:/DOCS/
 SHELL=$SYSTEM:/APPS/DOS.APP</code></pre>
<p>No se dieron parámetros, por lo que se mostraron todas las variables de entorno actualmente configuradas, en este caso valores predeterminados típicos.</p>
<pre><code>SET HELP=A:\HELP</code></pre>
<p>Se da el valor A:\HELP al elemento llamado HELP.</p>
<pre><code>SET HELP
 A:\HELP</code></pre>
<p>Muestra el valor actual de HELP.</p>
<pre><code>SET HELP=</code></pre>
<p>Se elimina el elemento HELP de la lista de elementos del entorno.</p>
<h2 id="stop-1">STOP</h2>
<pre><code>STOP</code></pre>
<p>Detiene la ejecución de un programa.</p>
<p>Uso</p>
<p>Dado un proceso por lotes, usar STOP permite detener su ejecución de inmediato.</p>
<p>Ejemplos</p>
<pre><code>STOP</code></pre>
<h2 id="time-1">TIME</h2>
<pre><code>TIME [/A] [/Z zone] [time]</code></pre>
<p>Muestra o establece la hora actual.</p>
<p>Uso</p>
<p>Si se especifica la hora después del comando, entonces la hora se ajusta a este valor (véase más abajo para más detalles sobre el formato). Si no se especifica la hora después del comando, entonces se muestra la hora actual y se solicita la nueva hora. Si no se da ninguna entrada (es decir, si solo se pulsa la tecla ENTER), entonces la hora actual no se altera. De lo contrario, se supone que la entrada es una nueva hora y se interpreta como se describe a continuación. Si la hora no es válida, se mostrará un mensaje de error y se le pedirá una nueva hora.</p>
<p>La hora debe constar de hasta cuatro cifras, separadas por uno de los siguientes caracteres:</p>
<pre><code>     space tab , - . / :</code></pre>
<p>con espacios permitidos a ambos lados de cada carácter. Los dígitos que falten aparecerán por defecto en la configuración actual. La primera cifra representa la hora, la segunda son los minutos, la tercera son los segundos y la cuarta son las centésimas de segundo. No obstante, las centésimas de segundo no se muestran, ya que no es muy útil conocer el valor actual, o incluso introducir uno nuevo.</p>
<p>El formato en el que se muestra la hora es flexible y se puede cambiar. Por defecto, un elemento de entorno denominado TIME está configurado por defecto con el valor ‘12’, lo que indica que la hora se mostrará en formato de 12 horas con el carácter ‘a’ o ‘p’ a continuación para indicar ‘a.m.’ y ‘p.m.’. El comando SET TIME 24 hará que la hora se muestre en el modo de 24 horas. La hora se puede introducir en cualquier formato. El formato de hora también afecta a las horas mostradas por el comando DIR.</p>
<p>Si se utiliza /A, se utilizará la hora obtenida por conexión NTP (a través de Internet) y se anulará la que hayamos establecido previamente. Mediante /Z podremos establecer la zona horaria indicando la ciudad de referencia.</p>
<p>Ejemplos</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>TIME 16:45</th>
<th>Se establece la hora actual a las 4:45 p.m.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TIME</td>
<td>No se han introducido parámetros, por lo que se muestra la hora actual (en este caso en el modo de 12 horas) y se solicita una nueva hora.</td>
</tr>
<tr class="even">
<td>Current time is 10:45:00a</td>
<td></td>
</tr>
<tr class="odd">
<td>Enter new time:</td>
<td></td>
</tr>
<tr class="even">
<td>TIME 10-50-30-23</td>
<td>La hora se fija en las 10:50 a.m. con 30 segundos y 23 centésimas.</td>
</tr>
<tr class="odd">
<td>TIME /A /Z Madrid</td>
<td>Establece hora automática y zona horaria de Madrid.</td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<h2 id="type">TYPE</h2>
<pre><code>TYPE [/H] [/P] [/B] compound-filespec | device</code></pre>
<p>Muestra el contenido de un archivo o dispositivo.</p>
<p>Uso</p>
<p>El compound-filespec especifica los archivos que se van a mostrar, y /H permite que también se muestre el contenido de los archivos ocultos. Si el compound‑filespec es ambiguo, entonces el nombre del archivo se muestra antes de cada uno.</p>
<p>Si se especifica /B, el contenido de cada archivo se muestra sin modificación en la pantalla hasta que se alcanza el final del archivo. Esto puede tener un efecto extraño en la pantalla si el archivo contiene caracteres de control.</p>
<p>Si /B no se da, entonces TYPE buscará el carácter de fin de archivo (CTRL+Z) y se detendrá cuando lo encuentre. Los caracteres de control excepto el retorno de carro, el avance de línea y el tabulador también se convertirán en caracteres que se pueden imprimir (A para ^A, W para ^W, etc).</p>
<p>Si se usa /P, entonces la salida se detendrá al final de la pantalla hasta que se presione una tecla.</p>
<p>Ejemplos</p>
<pre><code>TYPE FILE1</code></pre>
<p>El contenido del archivo se muestra en pantalla, hasta el primer carácter de final de archivo.</p>
<pre><code>TYPE *.BAT/H/P</code></pre>
<p>Se muestra el contenido de todos los archivos por lotes, incluidos los ocultos. Se imprime un mensaje al final de cada pantalla completa.</p>
<pre><code>TYPE AUTOEXEC.BAT + REBOOT.BAT</code></pre>
<p>Se muestran los archivos AUTOEXEC.BAT y REBOOT.BAT.</p>
<pre><code>TYPE /B DIR1</code></pre>
<p>Se imprime en pantalla el contenido de todos los archivos del directorio DIR1 sin interpretar los datos de los archivos.</p>
<h2 id="undel">UNDEL</h2>
<pre><code>UNDEL [filespec] [/Y] [/F]</code></pre>
<p>Recupera un archivo previamente eliminado.</p>
<p>Uso</p>
<p>El archivo filespec especifica qué archivos y/o carpetas deben recuperarse si es posible. En caso de no especificarse, se intentarán recuperar todos los archivos y carpetas eliminados previa confirmación del usuario (excepto si se usa el parámetro /Y).</p>
<p>Con /F eliminamos cualquier posibilidad de recuperar los archivos y/o carpetas borradas hasta el momento. En ese sentido, liberamos cualquier registro de archivos y carpetas borrados.</p>
<p>Los archivos y/o carpetas borradas intentarán recuperarse manteniendo intacta la ruta original en el momento en que fueron eliminados. Si al recuperarse existe el mismo archivo o directorio (la misma ruta), el sistema nos pedirá confirmación para sobrescribir y recuperar el borrado. En caso de usar /Y, no se pedirá confirmación.</p>
<p>Ejemplos</p>
<pre><code>UNDEL B:HELP.MAC</code></pre>
<p>Intenta recuperar el archivo HELP.MAC del directorio actual de la unidad B:.</p>
<pre><code>UNDEL A:\DIR1</code></pre>
<p>Todos los archivos y directorios eliminados en DIR1 son recuperados.</p>
<h2 id="ver">VER</h2>
<pre><code>VER</code></pre>
<p>Muestra los números de versión del sistema.</p>
<p>Uso</p>
<p>Se muestra la versión del núcleo VR-DOS, la versión del sistema operativo y su número de compilación. También se muestran el número de serie de la placa, el ALIAS registrado y el UDID del ordenador.</p>
<p>El número de serie de la placa es único, al igual que el UDID del ordenador.</p>
<p>Ejemplos</p>
<pre><code>VER
 VR-DOS version 1.0 build 790
 MSXVR version 0 build 16000</code></pre>
<pre><code> VR-ENGINE version 6 build 900
 S/N: 0000-0000-0000-0000
 ALIAS: Zanac
 UDID: 00-00-00-00-00-00-00-00
 (c) MSXVRTeam Corp. 2013-2021</code></pre>
<pre><code> </code></pre>
<h2 id="verify">VERIFY</h2>
<pre><code>VERIFY [ON | OFF]</code></pre>
<p>Muestra/establece el estado de verificación de escritura del disco actual.</p>
<p>Uso</p>
<p>Si no se usan parámetros, entonces el estado de verificación actual se muestra en la pantalla.</p>
<p>Si se introducen ON u OFF, entonces el estado de verificación se cambia apropiadamente.</p>
<p>El estado de verificación afecta a todas las escrituras en disco. Si está OFF, el estado predeterminado, entonces simplemente se escriben los datos. Si está ON, después de escribir los datos se lee de nuevo y se compara con el original para asegurarse de que se escribió correctamente. La sobrecarga adicional de este proceso significa que la escritura es más lenta cuando la verificación está activada.</p>
<p>Esta característica depende del controlador de dispositivo, por lo que no tendrá ningún efecto si el controlador no tiene la función.</p>
<p>Ejemplos</p>
<pre><code>VERIFY
 VERIFY=OFF</code></pre>
<p>No se han introducido parámetros, por lo que se muestra el estado de verificación actual, que en este caso está desactivado.</p>
<pre><code>VERIFY ON</code></pre>
<p>La verificación de escritura de disco queda activada.</p>
<h2 id="vol">VOL</h2>
<pre><code>VOL [d:] [volname]</code></pre>
<p>Muestra o cambia el nombre del volumen en un disco.</p>
<p>Uso</p>
<p>Si no se proporcionan parámetros o si solo se especifica un nombre de unidad, se mostrará el nombre de volumen de la unidad actual o especificada.</p>
<p>Si se introduce un volumen, entonces el nombre de volumen de la unidad especificada o actual se cambia al nombre de volumen introducido.</p>
<p>Ejemplos</p>
<pre><code>VOL B:
     Volume in drive B: has no name</code></pre>
<p>Solo se introdujo una unidad, por lo que se muestra el nombre de volumen para el disco de esa unidad. En este caso no se ha definido ningún nombre de volumen.</p>
<pre><code>VOL B: BACKUP</code></pre>
<p>El nombre de volumen del disco en la unidad B: se cambia a BACKUP.</p>
<h2 id="wget">WGET</h2>
<pre><code>WGET [url]</code></pre>
<p>Descarga un paquete de datos desde una URL en Internet.</p>
<p>Uso</p>
<p>En url se indica la dirección web desde la que descargar un paquete de datos.</p>
<p>Ejemplos:</p>
<pre><code>wget https://github.com/msxvr/code/raw/master/examples/vr-script/pong.zip</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="xdir">XDIR</h2>
<pre><code>XDIR [filespec] [/H] [/P]</code></pre>
<p>Lista todos los archivos dentro de los directorios y sus posibles subdirectorios.</p>
<p>Uso</p>
<p>Filespec especifica qué archivos se van a enumerar y /H permite incluir archivos ocultos.</p>
<p>XDIR es similar al comando DIR, pero no imprime las fechas y horas de los archivos.</p>
<p>El parámetro /P permite pausar la salida por pantalla cuando está completa.</p>
<p>Después de que todos los archivos en el directorio especificado se han enumerado, entonces los archivos dentro de los directorios descendentes también se enumeran, y se muestran identados. Esto permite obtener un DIR de un árbol de directorios completo o disco.</p>
<p>Ejemplos</p>
<table>
<thead>
<tr class="header">
<th>XDIR</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Se muestra el contenido de los directorios de todo el disco desde la unidad y el directorio actuales:</p>
<div class="line-block">                 | Volume in drive A: is MSX-DOS 2 | |<br />
                 | Directory of A:\ | |</div>
<p>|——————|————————————————————————————————–|—| | XDIR B:\DIR1 | Se muestran todos los archivos y directorios que haya dentro de DIR1. | | | XDIR \*.COM /H | Se muestran los nombres de todos los archivos, incluidos los ocultos, que coincidan con * .COM. | |</p>
<pre><code>MSXDOS2.SYS     r     4480
COMMAND2.COM    r    14976
AUTOEXEC.BAT            57
REBOOT.BAT              57
\UTILS
        CHKDSK.COM       7680
        DISKCOPY.COM     7168
        FIXDISK.COM       768
        UNDEL.COM        3968
        XCOPY.COM       10112
        XDIR.COM         7168
        MKSYS.BAT         569
        AUTOEXEC.BAT       47
        REBOOT.BAT         90
\HELP</code></pre>
<p>ASSIGN.HLP 819<br />
ATDIR.HLP 1527<br />
ATTRIB.HLP 1828<br />
.<br />
.<br />
.<br />
292K in 117 files 530K free</p>
<pre><code></code></pre>
<pre><code></code></pre>
<h2 id="ziptool">ZIPTOOL</h2>
<pre><code>ZIPTOOL [/C] [/I] [/D] [/A] [/E] [/R] [/Y] zipPath [filespec1]...[filespecN]</code></pre>
<p>Permite la manipulación de archivos con formato ZIP.</p>
<p>Uso</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>/C</th>
<th>Crear un archivo ZIP con el nombre establecido en zipPath.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/D</td>
<td>Mostrar el contenido de los archivos y carpetas dentro del ZIP.</td>
</tr>
<tr class="even">
<td>/A</td>
<td>Añadir uno o varios archivos al ZIP.</td>
</tr>
<tr class="odd">
<td>/E</td>
<td>Extraer archivos del ZIP a las unidades locales.</td>
</tr>
<tr class="even">
<td>/R</td>
<td>Borrar archivos contenidos dentro del ZIP.</td>
</tr>
<tr class="odd">
<td>/I</td>
<td>Mostrar información sobre el formato del ZIP.</td>
</tr>
<tr class="even">
<td>/Y</td>
<td>Dar respuesta afirmativa por defecto a cualquier petición del programa.</td>
</tr>
</tbody>
</table>
<p>Ejemplos</p>
<pre><code>ZIPTOOL /E tutorial.zip *.* tutorial/</code></pre>
<p>Extrae del ZIP todos los archivos y los copia dentro de la carpeta tutorial.</p>
<h1 id="redirección">Redirección</h1>
<p>La mayoría de los comandos y programas ejecutados en VR-DOS generan texto en la pantalla, que correspondería a la “salida estándar”, y leen desde el teclado, que correspondería a la “entrada estándar”. VR-DOS, sin embargo, proporciona facilidades para cambiar la entrada estándar y la salida estándar durante la duración del comando para hacer referencia a otros dispositivos o a archivos en disco incluyendo uno o más de los símbolos de redirección &lt;,&gt; y &gt;&gt; en la línea de comandos, seguido de un nombre de archivo.</p>
<p>Por ejemplo, el comando ECHO normalmente solo envía sus parámetros a la pantalla, escribiendo los caracteres en la salida estándar. Pero se puede redirigir su salida para enviarla a la impresora de la siguiente manera:</p>
<pre><code>     ECHO text &gt; PRN</code></pre>
<p>que cambia la salida estándar para referirse al dispositivo PRN durante la duración del comando ECHO. Del mismo modo, el comando:</p>
<pre><code>     ECHO text &gt; file1</code></pre>
<p>hará que se cree el archivo especificado (“file1”) y la salida del comando ECHO se escriba en el archivo. Para añadir la salida de un comando al final de un archivo existente, se puede usar el símbolo &gt;&gt; en lugar del símbolo &gt;, y el archivo solo se creará si aún no existe.</p>
<p>Para cambiar la entrada estándar, puede usar el símbolo &lt;, de forma similar al símbolo &gt;. En este caso, el archivo ya debe existir y debe contener una entrada adecuada para el comando. Si el comando intenta leer la entrada más allá del final del archivo, entonces será abortado ya que no puede continuar.</p>
<p>Cuando la información de redirección se da en la línea de comandos, es utilizada por VR‑DOS para aplicar este mecanismo y, a continuación, toda esta información se elimina de la línea de comandos. Por lo tanto, en los ejemplos anteriores, el comando ECHO no hará eco de los símbolos de redirección ni del nombre de archivo.</p>
<p>Si se redirige la entrada o salida de un archivo por lotes, se aplicará esa redirección a todos los comandos dentro del archivo por lotes. Sin embargo, los comandos individuales dentro del archivo de proceso por lotes pueden seguir siendo redirigidos, lo que anulará la redirección del archivo por lotes (véase Archivos de procesamiento por lotes).</p>
<h1 id="tuberías">Tuberías</h1>
<p>Además de redirigir la entrada y la salida de un comando o programa a otro dispositivo o un archivo de disco, es posible redirigir o ‘canalizar’ la salida estándar de un comando en la entrada estándar de otro. Normalmente, el segundo comando será un programa que lee desde su entrada estándar, modifica los datos y lo escribe en su salida estándar. Tal programa se llama un “filtro”. Por ejemplo, se podría producir un filtro que lea los datos de su entrada estándar, los coloque en orden alfabético y los escriba en su salida estándar. Así podría, por ejemplo, ordenarse alfabéticamente la salida del comando DIR.</p>
<p>La tubería se indica en la línea de comandos separando los dos comandos por el símbolo |. El comando a la izquierda del símbolo | se realizará primero y su salida será redirigida a un archivo temporal creado por el VR-DOS. A continuación, se realizará el segundo comando, con su entrada estándar redirigida desde el mismo archivo temporal. Cuando finalice el segundo comando, se eliminará el archivo temporal. La salida estándar del segundo comando puede, por supuesto, canalizarse en la entrada estándar de un tercer comando, y así sucesivamente.</p>
<p>Si se produce un redireccionamiento de entrada en una línea de comandos que implica una tubería, la redirección se aplica al primer comando de la tubería, ya que todos los demás comandos reciben su entrada estándar de la salida estándar del comando anterior en el conducto. Del mismo modo, si cualquier redirección de salida se produce en una línea de comandos que implica una tubería, la redirección se aplicará al último comando en la línea de comandos.</p>
<p>Como se mencionó anteriormente, para canalizar la salida de un comando en la entrada de otro, los archivos temporales serán creados y eliminados por VR-DOS. La ubicación de estos archivos temporales se especifica en el elemento de entorno TEMP y puede cambiarse para referirse a cualquier unidad y directorio (por ejemplo, la tubería se acelerará considerablemente si TEMP se refiere a un directorio de un disco RAM). Por defecto, TEMP se refiere al directorio raíz del disco de arranque. El nombre de archivo utilizado para el archivo temporal es escogido por VR-DOS, por lo que TEMP debe especificar solo la unidad y el directorio. El nombre de archivo es de la forma:</p>
<pre><code>          %PIPExxx.$$$</code></pre>
<p>Donde xxx es un número elegido por VR-DOS para evitar conflictos con cualquier otro archivo del directorio TEMP.</p>
<h1 id="archivos-de-procesamiento-por-lotes">Archivos de procesamiento por lotes</h1>
<p>Cuando se introduce un comando en VR-DOS y no es uno de los comandos internos, se busca un archivo de ese nombre con una extensión de .COM o .BAT. Si no se encuentra en el directorio actual, se busca en la ruta de búsqueda actual (consulte el comando PATH). Si se encuentra un archivo .COM, entonces se carga y ejecuta. Si se encuentra un archivo .BAT, VR-DOS inicia la ejecución del archivo por lotes.</p>
<p>Un archivo por lotes es un archivo de texto que contiene una lista de comandos, los cuales se leen del archivo línea a línea y se ejecutan como si se escribieran en el teclado.</p>
<p>A medida que se lee cada comando, normalmente se ejecuta inmediatamente. Sin embargo, existe un elemento de entorno ECHO que puede configurarse en ON (con el comando SET ECHO ON) para que cada línea de comandos se muestre en la pantalla antes de ejecutarse. La línea de comandos se muestra en pantalla con los parámetros % sustituidos (véase más abajo). El comando SET ECHO OFF restaurará el estado normal.</p>
<p>En la línea de comandos que invocó el archivo de proceso por lotes, los parámetros van a continuación del nombre del archivo de proceso por lotes como cualquier otro comando o nombre de programa transitorio. A estos parámetros se puede acceder en cualquier parte del archivo por lotes mediante %0, %1… hasta %9, donde %1 es el primer parámetro especificado en la línea de comandos, %2 es el segundo y así sucesivamente. %0 es el nombre del archivo de proceso por lotes. Para usar el símbolo % en una línea de comandos, se debe dar un % doble (‘%%’) que será reemplazado por uno solo.</p>
<p>Si la ejecución de cualquier comando en un archivo de proceso por lotes se termina prematuramente por alguna razón (normalmente porque se han presionado las teclas CTRL+STOP o CTRL+C), se emite el siguiente mensaje:</p>
<pre><code>          Terminate batch file (Y/N)?</code></pre>
<p>Si la respuesta es ‘Y’, entonces se detiene la ejecución de todo el archivo de proceso por lotes. Si la respuesta es ‘N’, la ejecución del archivo por lotes continúa con el siguiente comando del archivo por lotes.</p>
<p>Después de que VR-DOS haya ejecutado un comando en el archivo por lotes, puede que necesite leer del disco el siguiente comando en el archivo por lotes. Si el disco correcto no está en la unidad cuando se trata de hacer esto, entonces se emite un mensaje. Por ejemplo, el siguiente aviso se emitirá si el archivo por lotes se ejecutó originalmente desde la unidad A:</p>
<pre><code>          Insert disk for batch file in drive A:
          Press any key to continue... </code></pre>
<p>Cuando se ha insertado el disco correcto y se ha pulsado una tecla, la ejecución del archivo por lotes continuará normalmente. A continuación se muestra un archivo por lotes muy simple, que se limita a mostrar los valores de sus cuatro primeros parámetros.</p>
<pre><code>          ECHO Parameter 0 = %0
          ECHO Parameter 1 = %1
          ECHO Parameter 2 = %2
          ECHO Parameter 3 = %3</code></pre>
<p>Si se denomina MYBAT.BAT, el comando MYBAT a b c devolverá:</p>
<pre><code>          Parameter 0 = MYBAT
          Parameter 1 = a
          Parameter 2 = b
          Parameter 3 = c</code></pre>
<p>Cuando VR-DOS se inicia por primera vez, se busca un archivo de proceso especial llamado AUTOEXEC.BAT, que es ejecutado si se encuentra. Este puede contener cualquier comando de VR-DOS y, por lo general, contiene comandos de inicialización únicos, como un comando RAMDISK para configurar un disco RAM.</p>
<p>Se pasa un parámetro a AUTOEXEC.BAT como %1. Esta es la unidad desde la que ha arrancado VR-DOS y está en forma de una letra de unidad normal seguida de dos puntos.</p>
<p>Otro archivo de proceso especial es REBOOT.BAT. Este se ejecuta cuando se reinicia VR‑DOS. Al igual que con el archivo AUTOEXEC.BAT, el único parámetro %1 pasado es la unidad desde la que se reinició VR-DOS.</p>
<p>Por lo general, algunos comandos deben realizarse cada vez que VR-DOS se inicia, ya sea por primera vez o algún tiempo más tarde, y estos se ponen en el archivo por lotes REBOOT. A continuación, se pueden ejecutar desde el archivo de lotes AUTOEXEC, finalizándolo con el comando REBOOT %1. Un ejemplo de un comando que se puede poner en el archivo por lotes REBOOT es el comando PATH para configurar la ruta de búsqueda de comandos transitorios.</p>
<p>Cuando un comando en un archivo por lotes es otro archivo por lotes, ese segundo archivo por lotes se ejecuta de manera normal.</p>
<h1 id="variables-de-entorno">Variables de entorno</h1>
<p>VR-DOS mantiene una lista de “elementos de entorno” en su área de trabajo. Un elemento de entorno es un elemento con nombre que tiene asociado un valor.</p>
<p>Un elemento de entorno puede tener cualquier nombre elegido por el usuario y puede consistir en los mismos caracteres que son válidos en un nombre de archivo. La longitud máxima de un nombre de elemento de entorno es de 255 caracteres. VR-DOS proporciona varios elementos de entorno configurados de forma predeterminada.</p>
<p>El valor de un elemento de entorno es simplemente una cadena de caracteres arbitrarios hasta una longitud máxima de 255. Cualquier elemento de entorno que no existe tiene un valor nulo (es decir, sin caracteres).</p>
<p>Un elemento de entorno puede cambiarse o configurarse mediante el comando SET, que también puede mostrar los elementos de entorno actualmente configurados.</p>
<p>Los elementos de entorno configurados por defecto y la forma en que se interpreta su valor son los siguientes:</p>
<h4 id="echo-1">ECHO</h4>
<p>Esto controla el eco de las líneas leídas de un archivo de proceso por lotes. Cualquier valor excepto ‘ON’ (en minúsculas también permitido) se interpreta como ‘OFF’.</p>
<h4 id="prompt">PROMPT</h4>
<p>Esto controla cómo se visualiza el <em>command prompt</em>. Cualquier valor excepto ‘ON’ se interpreta como ‘OFF’.</p>
<p>Cuando PROMPT está en OFF, como es por defecto, entonces el símbolo del sistema consiste en la unidad actual seguida de ‘&gt;’, por ejemplo A&gt;.</p>
<p>Cuando PROMPT está ON, entonces el símbolo del sistema consiste en la unidad actual y el directorio actual de esa unidad seguido por ‘&gt;’, por ejemplo A:\COM&gt;. Para ello, se debe acceder a la unidad actual para leer el directorio actual y, por lo tanto, puede tardar un poco más en aparecer.</p>
<h4 id="path-2">PATH</h4>
<p>La ruta de búsqueda actual en la que VR-DOS busca el comando dado se guarda en el elemento de entorno PATH, y se puede modificar mediante el comando PATH.</p>
<h4 id="time-2">TIME</h4>
<p>TIME especifica el formato en que VR-DOS muestra la hora. Si no es ‘24’, que indica que se muestra como un reloj de 24 horas, entonces se supone ‘12’, lo que indica que se muestra como un reloj de 12 horas seguido del indicador a.m. o p.m. El elemento de entorno TIME no se aplica cuando se introduce la hora, ya que puede introducirse en cualquier formato sin ambigüedad.</p>
<h4 id="date-1">DATE</h4>
<p>DATE especifica el formato de la fecha que se muestra e ingresa por VR-DOS. El valor predeterminado es un formato apropiado para el país de origen de la máquina MSX. Toma la forma de tres grupos de uno o dos dígitos separados por separadores (vea el comando DATE). Para establecer el formato americano, por ejemplo, se puede dar el comando SET DATE = MM/DD/YY.</p>
<h4 id="help-1">HELP</h4>
<p>Cuando se usa el comando HELP seguido del nombre del comando para el cual se necesita ayuda, entonces lee la información mostrada desde un archivo en el disco. Este archivo se encuentra en el directorio especificado por el elemento de entorno HELP. Por defecto, este directorio es $SYSTEM:/doc y como subdirectorios podemos encontrar los diferentes idiomas soportados en el sistema.</p>
<h4 id="temp">TEMP</h4>
<p>Cuando se utilizan las tuberías, es necesario que VR-DOS cree uno o más archivos temporales, y el elemento de entorno TEMP indica la unidad y el directorio en el que se van a crear estos archivos temporales. De forma predeterminada, hace referencia al directorio que el sistema utiliza para almacenar los archivos temporales: $SYSTEM:/temp.</p>
<p>Aunque el sistema VR-DOS solo utiliza TEMP para las tuberías, cualquier otro programa y utilidad que necesite crear archivos temporales también puede utilizar el elemento de entorno TEMP.</p>
<h4 id="upper">UPPER</h4>
<p>UPPER controla si la línea de comandos a ejecutar se convierte en mayúsculas.</p>
<p>Cuando UPPER está ‘OFF’ (por defecto), no se realizará ninguna conversión y los valores se pasarán al comando tal cual se hayan escrito.</p>
<p>Cuando UPPER está en ‘ON’, cada carácter de la línea de comandos se convertirá a mayúscula y posteriormente se pasará al comando.</p>
<p>Cualquier valor excepto ‘ON’ se interpreta como ‘OFF’.</p>
<h4 id="redir">REDIR</h4>
<p>REDIR controla si los caracteres de redirección o de tubería en la línea de comandos se procesan por VR-DOS.</p>
<p>Cuando REDIR está ‘OFF’, los caracteres de redirección o de tubería se pasarán al programa transitorio a medida que se escriban, y el programa transitorio puede procesarlos.</p>
<p>Cuando REDIR está ‘ON’ (por defecto), los caracteres de redirección o de tubería serán interpretados y ejecutados por VR-DOS, por lo que no se pasarán al programa transitorio.</p>
<p>Cualquier valor excepto ‘ON’ se interpreta como ‘OFF’.</p>
<h1 id="códigos-de-error">Códigos de error</h1>
<p>Errores de disco</p>
<p>Los errores de disco se producen cuando un comando o programa está intentando acceder a un disco y falla por alguna razón, como un disco que no está en la unidad. Cuando esto ocurre, aparece un mensaje y un símbolo del sistema que le permite al usuario reintentar la operación para que pueda funcionar (por ejemplo, si se ha insertado un disco en la unidad), ignorar la operación o anular todo el comando.</p>
<p>Un ejemplo de mensaje de error del disco y del símbolo del sistema es el siguiente, y puede ocurrir si el disco fue retirado mientras se estaba accediendo a la unidad A:.</p>
<pre><code>          Not ready reading drive A:
          Abort, Retry or Ignore (A/R/I)?</code></pre>
<p>La parte “Not ready” del mensaje indica por qué falló la operación del disco, y existen otras posibilidades. ‘Reading’ indica que el comando estaba intentando leer el disco, y puede ser reemplazado por ‘writing’ si eso es lo que estaba haciendo. ‘Unidad A:’ es la unidad en la que se intentó acceder al disco.</p>
<p>La parte ‘Abort, Retry or Ignore’ indica las posibles acciones que puede tomar el usuario, que se seleccionan pulsando la tecla ‘A’, ‘R’ o ‘I’.</p>
<p>Si se selecciona Abort, entonces se anula el comando completo y se muestra el mensaje ‘Disk operation aborted’ antes de poder escribir otro comando.</p>
<p>Si se selecciona Retry, la operación de disco fallido simplemente se volverá a intentar y puede fallar de nuevo o puede funcionar, particularmente si se ha tomado alguna acción correctiva, como la inserción de un disco que falta.</p>
<p>Ignore hace que la operación de disco fallida sea ignorada por el comando. En muchos casos, no se recomienda ignorar un error y, en estos casos, la opción Ignore no se mostrará. Hacerlo puede causar un mal funcionamiento del sistema y podría destruir datos en el disco. Incluso si se muestra la opción Ignore, se debe utilizar con extrema precaución, y solo cuando todo lo demás falla. Normalmente, Ignore solo se utiliza cuando los datos de un disco se han corrompido e ignorar el error de disco ofrece la única posibilidad de recuperar todo o parte de los datos.</p>
<p>Algunos errores graves que generalmente conllevan que el disco se ha dañado más allá del uso posible se abortan automáticamente y solo se muestra el mensaje de error apropiado (por ejemplo, ‘Bad file allocation table’).</p>
<p>Los errores de disco que pueden ocurrir y sus significados son, en orden alfabético, los siguientes:</p>
<h4 id="bad-file-allocation-table">Bad file allocation table</h4>
<p>El disco contiene una tabla de asignación de archivos no válida (FAT). La FAT es un área en el disco en la que el sistema mantiene la información para decirle dónde se almacenan los datos de cada archivo en el disco. Por lo tanto, si la FAT no es válida, no puede leer ningún dato en absoluto. Este mensaje normalmente significa que el disco se ha corrompido y no puede usarse.</p>
<h4 id="cannot-format-this-drive">Cannot format this drive</h4>
<p>Se ha intentado formatear un disco en una unidad que no admite el formateo de disco. Esto probablemente significa que se ha dado un comando FORMAT especificando el disco RAM.</p>
<h4 id="data-error">Data error</h4>
<p>Los datos fueron leídos o escritos sin error, pero la comprobación CRC (código para detección de errores - <em>Cyclic Redundancy Check</em>) falló. Esto normalmente significa que el disco está dañado.</p>
<h4 id="disk-error">Disk error</h4>
<p>Los datos no se pudieron leer o escribir en el disco.</p>
<h4 id="incompatible-disk">Incompatible disk</h4>
<p>Se intentó acceder a un disco con un formato incompatible.</p>
<h4 id="not-a-dos-disk">Not a DOS disk</h4>
<p>El disco no es un formato que VR-DOS pueda leer.</p>
<h4 id="not-ready">Not ready</h4>
<p>El disco no está en la unidad a la que se accede. El disco debe ser insertado en la unidad y seleccionar ‘Retry’.</p>
<h4 id="sector-not-found">Sector not found</h4>
<p>VR-DOS intentó leer o escribir en un sector inexistente. Puede indicar que el disco está dañado.</p>
<h4 id="seek-error">Seek error</h4>
<p>No se pudo encontrar la pista solicitada en el disco. Podría significar un disco dañado o una unidad de disco defectuosa.</p>
<h4 id="unformatted-disk">Unformatted disk</h4>
<p>El disco no se ha formateado. Utilice el comando FORMAT en el disco antes de acceder a él.</p>
<h4 id="verify-error">Verify error</h4>
<p>Solo se produce cuando la verificación está activada y significa que los datos parecen estar escritos en el disco correctamente, pero cuando se comprueba se encuentran diferencias en lo escrito.</p>
<h4 id="write-error">Write error</h4>
<p>Los datos no se escribieron correctamente.</p>
<h4 id="write-protected-disk">Write protected disk</h4>
<p>El disco está protegido contra escritura y se ha intentado escribir datos en él. El disco debe estar desprotegido y seleccionar ‘Retry’.</p>
<h4 id="wrong-disk-wrong-disk-for-file">Wrong disk / Wrong disk for file</h4>
<p>VR-DOS accedió a un disco una vez y posteriormente necesitó acceder de nuevo, pero encontró que la unidad contenía un disco diferente. Se debe insertar el disco correcto y seleccionar ‘Retry’.</p>
<p>Errores de comando</p>
<p>Los errores de comando se producen cuando un comando no puede realizar la función deseada por alguna razón.</p>
<p>Si se produce un error en un comando y es poco probable que pueda continuar, se muestra un mensaje de error apropiado y se vuelve al símbolo del sistema para esperar el siguiente comando.</p>
<p>Un ejemplo de mensaje de error es:</p>
<pre><code>          *** File not found</code></pre>
<p>Los tres asteriscos *** se muestran primero para indicar que se ha producido un error. A continuación, se mostrará el mensaje, seguido por el símbolo del sistema normal en la línea siguiente.</p>
<p>Cuando se produce un error de comando en una situación específica, también se puede mostrar un mensaje con información sobre el tipo de error. Por ejemplo, generalmente cuando no se puede encontrar un archivo requerido en el disco, el mensaje ‘File not found’ se muestra como en el ejemplo anterior. Sin embargo, si el archivo requerido es un archivo especificado por el símbolo de redirección &lt;, el mensaje mostrado será:</p>
<pre><code>         *** Redirection error: File not found</code></pre>
<p>Los tipos de error posibles son:</p>
<h4 id="batch-file-error">Batch file error:</h4>
<p>Se ha producido un error al intentar leer un archivo por lotes; por ejemplo, se ha producido un error de disco y se seleccionó ‘Abort’.</p>
<h4 id="piping-error">Piping error:</h4>
<p>El error se produjo durante una operación de canalización, probablemente en relación con los archivos temporales que COMMAND2.COM crea (consulte el capítulo 5 en Redirección y tubería). Por ejemplo, el elemento de entorno TEMP no se refería a una unidad o directorio válido.</p>
<h4 id="redirection-error">Redirection error:</h4>
<p>El error se produjo durante una operación de redirección. Por ejemplo, se especificó un nombre de archivo no válido después de un símbolo de redirección &lt;,&gt; o &gt;&gt;, o no se encontró el archivo de entrada especificado (consulte el capítulo 5 en Redirección y Tubería).</p>
<h4 id="standard-input-error">Standard input error:</h4>
<p>Se ha producido un error en la entrada estándar de un comando o programa después de que se haya configurado la redirección o la tubería; por ejemplo, la entrada estándar se ha redirigido de un archivo y se ha alcanzado el final del archivo.</p>
<h4 id="standard-output-error">Standard output error:</h4>
<p>Se ha producido un error en la salida estándar de un comando o programa después de que se ha configurado la redirección o la tubería; por ejemplo, la salida estándar se ha redirigido a un archivo y el disco está lleno.</p>
<p>Muchos comandos operan en archivos o directorios y si se da un nombre de archivo ambiguo, el comando opera en varios archivos o directorios (por ejemplo, el comando RENAME o el comando COPY). A menudo se produce un error cuando está intentando realizar el comando en uno de los archivos, pero que puede tener éxito en uno de los otros archivos. En este caso, el nombre del archivo se muestra seguido del mensaje de error y el comando continúa. Por ejemplo:</p>
<pre><code>    -- File cannot be copied onto itself</code></pre>
<p>Los posibles errores de comando que se pueden dar son, en orden alfabético, los siguientes:</p>
<h4 id="cannot-concatenate-destination-file">Cannot concatenate destination file</h4>
<p>El error lo devuelve CONCAT y significa que uno de los nombres de archivo coincidentes con la especificación de archivo de origen es el archivo de destino. Esto no es necesariamente malo, pero puede indicar un error en el comando.</p>
<h4 id="cannot-create-destination-file">Cannot create destination file</h4>
<p>Este error lo devuelve COPY, y por lo general significa que el archivo de destino para el archivo que está copiando, si se creó, sobrescribirá un archivo que ya estaba en uso. Es probable que se trate de un archivo de origen copiado anteriormente, pero puede ser otro archivo, como el archivo de proceso por lotes en ejecución.</p>
<h4 id="cannot-overwrite-previous-destination-file">Cannot overwrite previous destination file</h4>
<p>Este error lo devuelve COPY, y significa que el archivo de destino para el archivo que está copiando, si se creó, sobrescribirá el archivo de destino del archivo que fue copiado previamente. Esto generalmente significa que el destino deseado era un directorio pero que su nombre estaba mal escrito.</p>
<h4 id="cannot-transfer-above-64k">Cannot transfer above 64K</h4>
<p>Este error no debería ocurrir normalmente en los comandos.</p>
<h4 id="command-too-long">Command too long</h4>
<p>Un comando que se dio es demasiado largo. Esto no ocurrirá al escribir comandos desde el teclado, pero puede ocurrir desde un archivo por lotes. La longitud máxima de un comando es de 127 caracteres después de la sustitución del parámetro %.</p>
<h4 id="ctrl-c-pressed">Ctrl-C pressed</h4>
<p>El comando se interrumpió presionando CTRL+C.</p>
<h4 id="ctrl-stop-pressed">Ctrl-STOP pressed</h4>
<p>El comando se interrumpió pulsando CTRL+STOP.</p>
<h4 id="directory-exists">Directory exists</h4>
<p>Un comando intentó crear un nuevo archivo o directorio en el disco con el mismo nombre que un directorio existente.</p>
<h4 id="directory-not-empty">Directory not empty</h4>
<p>El comando RMDIR (RD) intentó quitar un directorio que contenía archivos u otros directorios. Estos deben eliminarse primero con los comandos ERASE y RMDIR, ya que los directorios deben estar vacíos antes de que se puedan eliminar.</p>
<h4 id="directory-not-found">Directory not found</h4>
<p>Un comando de directorio (por ejemplo, RNDIR) no pudo encontrar el directorio especificado.</p>
<h4 id="disk-full">Disk full</h4>
<p>No hay más espacio en el disco: será necesario eliminar algunos ficheros e introducir el comando de nuevo.</p>
<h4 id="disk-operation-aborted">Disk operation aborted</h4>
<p>Se produjo un error de disco y se eligió la opción ‘Abort’, abortando así todo el comando.</p>
<h4 id="duplicate-filename">Duplicate filename</h4>
<p>RENAME (REN) o RNDIR no pueden realizar el cambio de nombre especificado porque el nuevo nombre de archivo es igual que un nombre de archivo que ya existe. También ocurre desde MOVE o MVDIR porque ya existe un nombre de archivo en el directorio de destino con el mismo nombre que el archivo o directorio que se está cambiando.</p>
<h4 id="end-of-file">End of file</h4>
<p>Final de archivo alcanzado y la operación en el archivo no se permite.</p>
<h4 id="environment-string-too-long">Environment string too long</h4>
<p>Se intenta asociar una cadena de texto a una variable de entorno que supera el máximo de caracteres permitido.</p>
<h4 id="error-on-standard-input">Error on standard input</h4>
<p>Se produjo un error mientras un comando intentaba leer desde el teclado.</p>
<h4 id="error-on-standard-output">Error on standard output</h4>
<p>Se produjo un error mientras un comando intentaba escribir en la pantalla.</p>
<h4 id="file-access-violation">File access violation</h4>
<p>Se intenta realizar una acción en un archivo y no se tienen los permisos necesarios.</p>
<h4 id="file-allocation-error">File allocation error</h4>
<p>No hay más memoria disponible para el archivo.</p>
<h4 id="file-cannot-be-copied-onto-itself">File cannot be copied onto itself</h4>
<p>El archivo de destino al intentar hacer un COPY es el mismo archivo que el de origen.</p>
<h4 id="file-exists">File exists</h4>
<p>MKDIR (MD) intentó crear un nuevo directorio pero ya existía un archivo con el mismo nombre en el directorio especificado.</p>
<h4 id="file-for-help-not-found">File for HELP not found</h4>
<p>El comando HELP buscó un archivo para obtener el texto de ayuda pero no pudo encontrarlo. Los archivos de ayuda se guardan generalmente en un directorio llamado $SYSTEM:/DOCS en la unidad del sistema.</p>
<h4 id="file-handle-not-open">File handle not open</h4>
<p>Se intenta realizar una operación de lectura o escritura sobre un archivo que no se ha abierto para operar con él.</p>
<h4 id="file-is-already-in-use">File is already in use</h4>
<p>Un comando intentó modificar un archivo que ya se estaba utilizando para algún otro propósito, como el archivo de proceso por lotes en ejecución.</p>
<h4 id="file-not-found">File not found</h4>
<p>Un comando no pudo encontrar el archivo o archivos especificados.</p>
<h4 id="internal-error">Internal error</h4>
<p>Ha ocurrido un error inesperado en un comando.</p>
<h4 id="invalid-vr-dos-call">Inva<em>l</em>id VR-DOS call</h4>
<p>Ha ocurrido un error inesperado en el intérprete de comandos VR-DOS.</p>
<h4 id="invalid-attributes">Invalid attributes</h4>
<p>Normalmente significa que se ha especificado un atributo +/- inválido en ATTRIB o ATDIR.</p>
<h4 id="invalid-date">Invalid date</h4>
<p>La fecha escrita en el comando DATE no es una fecha válida o se escribió en un formato no válido.</p>
<h4 id="invalid-device-operation">Invalid device operation</h4>
<p>Un comando no puede realizar su función en uno de los dispositivos integrados del sistema: por ejemplo a un archivo no se le puede dar el nombre CON.</p>
<h4 id="invalid-directory-move">Invalid directory move</h4>
<p>MVDIR intentó mover un directorio a uno de sus propios subdirectorios, lo que no se puede hacer.</p>
<h4 id="invalid-drive">Invalid drive</h4>
<p>Se especificó una unidad que no existe.</p>
<h4 id="invalid-environment-string">Invalid environment string</h4>
<p>El nombre de un elemento de entorno contiene caracteres no válidos. Solo los caracteres válidos en nombres de archivo son válidos en nombres de elementos de entorno.</p>
<h4 id="invalid-file-handle">Invalid file handle</h4>
<p>El manipulador de archivo sobre el que se intenta operar es no válido.</p>
<h4 id="invalid-filename">Invalid filename</h4>
<p>Un nombre de archivo contiene caracteres no válidos. Esto puede ser un nombre de archivo dado explícitamente, o puede ser el resultado de intentar cambiar el nombre de un archivo con un nuevo nombre ambiguo.</p>
<h4 id="invalid-number">Invalid number</h4>
<p>Un número introducido en un comando contenía caracteres que no eran dígitos.</p>
<h4 id="invalid-option">Invalid option</h4>
<p>Una letra no válida fue dada después de una / en una línea de comandos.</p>
<h4 id="invalid-.-or-..-operation">Invalid . or .. operation</h4>
<p>Un comando no puede realizar su función sobre los directorios especiales ‘.’ y ‘..’ que hay en todos los subdirectorios.</p>
<h4 id="invalid-parameter">Invalid parameter</h4>
<p>De algún modo el parámetro de un comando no es válido para ese comando.</p>
<h4 id="invalid-pathname">Invalid pathname</h4>
<p>Una ruta especificada en una línea de comandos no existe o es sintácticamente incorrecta.</p>
<h4 id="invalid-process-id">Invalid process id</h4>
<p>El proceso al que se intenta acceder es no válido.</p>
<h4 id="invalid-time">Invalid time</h4>
<p>La hora escrita en el comando TIME no es una hora válida o se escribió en un formato no válido.</p>
<h4 id="missing-parameter">Missing parameter</h4>
<p>Un comando esperaba un parámetro pero no lo encontró.</p>
<h4 id="not-enough-memory">Not enough memory</h4>
<p>No hay suficiente memoria disponible para ejecutar el comando.</p>
<h4 id="not-enough-memory-system-halted">Not enough memory, system halted</h4>
<p>Este mensaje de error especial se muestra cuando VR-DOS intenta iniciar y encuentra que no hay suficiente memoria para continuar. Como sugiere el mensaje, el equipo debe reiniciarse.</p>
<h4 id="pathname-to-long">Pathname to long</h4>
<p>La ruta es demasiado larga. La longitud del nombre de ruta dado excede 256 caracteres o la longitud total de una ruta desde el directorio raíz a un archivo es mayor de 256 caracteres.</p>
<h4 id="ram-disk-already-exists">RAM disk already exists</h4>
<p>Se está intentando crear una RAM-Disk y ya existe.</p>
<h4 id="ram-disk-does-not-exist">RAM disk does not exist</h4>
<p>El comando RAMDISK se utilizó para mostrar el tamaño actual del disco RAM, pero no existe ningún disco RAM.</p>
<h4 id="read-only-file">Read only file</h4>
<p>Se ha intentado modificar o sobrescribir un archivo marcado como de solo lectura. El comando DIR muestra esto, y el comando ATTRIB puede hacer que no sea de solo lectura.</p>
<h4 id="system-file-exists">System file exists</h4>
<p>Se ha intentado crear un archivo que, si se creó, sobrescribirá un archivo que esté marcado como un archivo de sistema. Los archivos de sistema no se utilizan en VR-DOS y no se muestran mediante el comando DIR ni son accesibles desde cualquier otro comando, por lo que este error no debería ocurrir normalmente con los comandos.</p>
<h4 id="too-many-parameters">Too many parameters</h4>
<p>Todos los parámetros que un comando esperaba se encontraban en la línea de comandos, pero todavía quedaban más parámetros al final de la línea.</p>
<h4 id="unrecognized-command">Unrecognized command</h4>
<p>Un comando introducido no era un comando interno ni un comando COM o BAT externo encontrado a lo largo de la ruta de búsqueda actual según lo establecido por el comando PATH.</p>
<h1 id="mensajes-del-prompt">Mensajes del prompt</h1>
<p>Hay varias situaciones en las que se requiere la interacción del usuario antes de que el sistema pueda continuar con lo que estaba haciendo, normalmente insertando un disco. Además, muchos comandos potencialmente peligrosos solicitan respuestas a mensajes de confirmación antes de que realicen su operación. A continuación se ofrecen varias instrucciones del sistema.</p>
<pre><code>All data on drive A: will be destroyed
Press any key to continue... </code></pre>
<p>Este indicador lo muestra el comando FORMAT y se emite para reducir el riesgo de formatear el disco incorrectamente. Para cancelar el comando FORMAT, puede pulsarse CTRL+STOP o CTRL+C.</p>
<pre><code>Destroy all data on RAM disk (Y/N)? </code></pre>
<p>Se dio un comando RAMDISK para configurar un disco RAM, pero ya existía un disco RAM. Si la respuesta al mensaje es ‘Y’, entonces cualquier archivo en este disco RAM existente será destruido. Una respuesta de ‘N’ o CTRL+STOP o CTRL+C abortarán el comando.</p>
<pre><code>Disk in drive A: will only be able to boot MSX-DOS
Press any key to continue... </code></pre>
<p>Este indicador lo muestra el comando FIXDISK y se muestra para reducir el riesgo de actualizar accidentalmente un disco que no sea de MSX-DOS 2. Para anular el comando FIXDISK, se puede presionar CTRL+STOP o CTRL+C.</p>
<pre><code>Erase all files (Y/N)?</code></pre>
<p>Este indicador se produce cuando se usa un comando DEL (o ERA o ERASE) especificando todos los archivos de un directorio, y se muestra para reducir el riesgo de borrar accidentalmente muchos archivos.</p>
<pre><code>Press any key to continue... </code></pre>
<p>Este aviso se emite generalmente cuando se requiere alguna interacción del usuario, y normalmente se muestra después de algún otro mensaje que describe la acción requerida. También se muestra con el comando PAUSE. Para anular el comando que emitió el mensaje, se puede presionar CTRL+STOP o CTRL+C.</p>
<pre><code>Terminate batch file (Y/N)? </code></pre>
<p>Cuando VR-DOS anula un comando prematuramente (como cuando se presiona la tecla de CTRL+STOP o CTRL+C) y se ejecuta el comando en un archivo por lotes, se emite este aviso. Si la respuesta es ‘Y’ entonces el archivo por lotes también será abortado. Si la respuesta es ‘N’, el archivo por lotes continuará con el comando que sigue al comando abortado.</p>
<h2 id="vr-script">VR-SCRIPT</h2>
<h1 id="qué-es-vr-script">¿Qué es VR-SCRIPT?</h1>
<p>VR-SCRIPT es el lenguaje de scripting nativo de los MSXVR y con el que se pueden desarrollar cualquier tipo de aplicaciones y juegos. Además de la versatilidad del script, permite una programación orientada a objetos entre otras particularidades especiales. Este lenguaje utiliza una sintaxis similar a la del C/C++. Dentro del MSXVR se lanzan programas que ejecutan estos scripts. Estos programas tienen acceso a un conjunto de funciones nativas para poder desarrollar todo tipo de tareas.</p>
<p>En esta sección del documento aprenderemos las particularidades del lenguaje VR‑SCRIPT, así como a desarrollar nuestras propias aplicaciones en dicho lenguaje.</p>
<h1 id="palabras-reservadas">Palabras reservadas</h1>
<p>_change, _call, _implements, _instanceof, _set, _unset, _get, _state, _sizeof, _eval, _run, break, case, class, constants, continue, default, defines, delete, do, else, exit, externals, for, function, false, float, globals, if, import, implements, int, in, null, new, namespace, native, properties, pointer, protected, private, public, partial, package, return, rep, state, switch, string, sizeof, select, true, this, typeof, until, virtual, while, when</p>
<h1 id="estructura-del-archivo">Estructura del archivo</h1>
<p>VR-SCRIPT opera con archivos individuales, donde cada archivo hace referencia a una clase (aunque puede incluir subclases). Por defecto el sistema no es sensible a mayúsculas/minúsculas (aunque se puede configurar para que sí lo sea) y permite el uso de directivas de preprocesamiento.</p>
<p>La estructura básica de un archivo sería:</p>
<pre><code>namespace IDENTIFIER
import [package] STRING

class IDENTIFIER[&lt;INTERFACE&gt;] [partial STRING [, STRING, ...]] [implements STRING [, STRING, …]]
{
   globals:
      IDENTIFIER [: TYPE] = VALUE;
   ...
   externals:
      IDENTIFIER;
   ...
   defines:
      IDENTIFIER [: TYPE] [= VALUE];
   ...
   [private | public | protected] constants:
      IDENTIFIER [: TYPE] [= VALUE];
   ...
   [private | public | protected] properties:
      IDENTIFIER [: TYPE] = VALUE;
   ...
   [private | public | protected] {function | virtual} NAME ([[&amp;]ARG,[&amp;]ARG,…]) [: TYPE] {}
   [private | public | protected] state [virtual] STRING[:] {}
}</code></pre>
<h1 id="tipos">Tipos</h1>
<p>Existen diferentes tipos de datos en VR-SCRIPT. Son los siguientes:</p>
<table>
<thead>
<tr class="header">
<th><strong>Nombre</strong></th>
<th><strong>TYPE</strong></th>
<th><strong>Tamaño (Bytes)</strong></th>
<th><strong>Rango</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bool</td>
<td>TYPE_BOOL</td>
<td>1</td>
<td>True | False</td>
</tr>
<tr class="even">
<td>byte</td>
<td>TYPE_BYTE</td>
<td>1</td>
<td>-128 hasta 127</td>
</tr>
<tr class="odd">
<td>ubyte</td>
<td>TYPE_UBYTE</td>
<td>1</td>
<td>0 hasta 255</td>
</tr>
<tr class="even">
<td>short</td>
<td>TYPE_SHORT</td>
<td>2</td>
<td>-32768 hasta 32767</td>
</tr>
<tr class="odd">
<td>ushort</td>
<td>TYPE_USHORT</td>
<td>2</td>
<td>0 hasta 65535</td>
</tr>
<tr class="even">
<td>int</td>
<td>TYPE_INT</td>
<td>4</td>
<td>-2147483648 hasta 2147483647</td>
</tr>
<tr class="odd">
<td>uint</td>
<td>TYPE_UINT</td>
<td>4</td>
<td>0 hasta 4294967295</td>
</tr>
<tr class="even">
<td>long</td>
<td>TYPE_LONG</td>
<td>8</td>
<td>-263 hasta 263-1</td>
</tr>
<tr class="odd">
<td>ulong</td>
<td>TYPE_ULONG</td>
<td>8</td>
<td>0 hasta 264</td>
</tr>
<tr class="even">
<td>float</td>
<td>TYPE_FLOAT</td>
<td>4</td>
<td>1.2E-38 hasta 3.4E+38 (6 dec)</td>
</tr>
<tr class="odd">
<td>double</td>
<td>TYPE_DOUBLE</td>
<td>8</td>
<td>2.3E-308 hasta 1.7E+308 (15 dec)</td>
</tr>
<tr class="even">
<td>list</td>
<td>TYPE_LIST</td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td>buffer</td>
<td>TYPE_BUFFER</td>
<td>-</td>
<td></td>
</tr>
<tr class="even">
<td>string</td>
<td>TYPE_STRING</td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td>pointer</td>
<td>TYPE_POINTER</td>
<td>-</td>
<td></td>
</tr>
<tr class="even">
<td>object</td>
<td>TYPE_OBJECT</td>
<td>-</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Ejemplos de inicialización:</em></p>
<pre><code>A = 5;
B = 6.5;
C = &quot;Hola&quot;;
D = [A, B, &quot;CD&quot;, [1, 2]];
E = null;</code></pre>
<pre><code>// Defino un Buffer de 32 bytes
F = {@32@} </code></pre>
<pre><code>// Defino un Buffer de 9 bytes con 9 valores
G = {5,6,4,3,4,5,6,3,2} </code></pre>
<pre><code>// Defino un Buffer de 128 bytes con 4 valores
H = {@128@10, 4, 5, 3} </code></pre>
<pre><code>// Inicializo la variable I como booleano
I = true;</code></pre>
<p>sizeof / typeof</p>
<p>Con <em>sizeof</em> podemos saber el tamaño o cantidad de elementos y con <em>typeof</em> el tipo de la variable o constante.</p>
<p><em>Ejemplos:</em></p>
<table>
<thead>
<tr class="header">
<th>a = sizeof([8,4,5,6]);</th>
<th>a = 4</th>
<th>Elementos de la lista</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b = sizeof(5);</td>
<td>b = 4</td>
<td>Tamaño del entero en bytes</td>
</tr>
<tr class="even">
<td>c = sizeof(6.2);</td>
<td>c = 4</td>
<td>Tamaño del flotante en bytes</td>
</tr>
<tr class="odd">
<td>d = sizeof(“Hola”);</td>
<td>d = 4</td>
<td>Número de caracteres</td>
</tr>
<tr class="even">
<td>e = sizeof(null);</td>
<td>e = 0</td>
<td>Valor de NULL</td>
</tr>
<tr class="odd">
<td>a = “Hola”;</td>
<td>b = TYPE_STRING</td>
<td>Tipo de la variable &lt;a&gt;</td>
</tr>
<tr class="even">
<td>b = typeof(a);</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Forzar la especificación de tipos</p>
<p>Es posible programar forzando la especificación de tipo. Para ello usaremos la sintaxis:</p>
<pre><code>#pragma typejuggling=off</code></pre>
<p>Esto obligará a determinar el tipo en cada declaración de constantes, propiedades, parámetros de funciones y valores de retorno de función.</p>
<p>También es posible definir variables con un tipo concreto usando:</p>
<pre><code>properties:
    a = int;
    b = byte;
    c = bool;</code></pre>
<p>Representación numérica</p>
<p>Veamos diferentes formas de expresar el mismo número:</p>
<table>
<thead>
<tr class="header">
<th><strong>Inicialización</strong></th>
<th><strong>Tipo</strong></th>
<th><strong>Bytes Tamaño</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a = 15;</td>
<td>Entero (int)</td>
<td>4</td>
</tr>
<tr class="even">
<td>a = 15L;</td>
<td>Entero (long)</td>
<td>8</td>
</tr>
<tr class="odd">
<td>a = 15.0f;</td>
<td>Flotante (float)</td>
<td>4</td>
</tr>
<tr class="even">
<td>a = 15.0;</td>
<td>Flotante (float)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>a = 15.0L;</td>
<td>Flotante doble (double)</td>
<td>8</td>
</tr>
<tr class="even">
<td>a = 0xF;</td>
<td>Hexadecimal (int)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>a = 0b1111;</td>
<td>Binario (int)</td>
<td>4</td>
</tr>
<tr class="even">
<td>a = 0o17;</td>
<td>Octal (int)</td>
<td>4</td>
</tr>
<tr class="odd">
<td>a = 0xFL;</td>
<td>Hexadecimal (long)</td>
<td>8</td>
</tr>
<tr class="even">
<td>a = 0b1111L;</td>
<td>Binario (long)</td>
<td>8</td>
</tr>
<tr class="odd">
<td>a = 0o17L;</td>
<td>Octal (long)</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Tipos existentes</p>
<table>
<thead>
<tr class="header">
<th><strong>Declaración en el script</strong></th>
<th><strong>Constante typeof</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>bool</td>
<td>TYPE_BOOL</td>
</tr>
<tr class="even">
<td>ubyte</td>
<td>TYPE_UBYTE</td>
</tr>
<tr class="odd">
<td>byte</td>
<td>TYPE_BYTE</td>
</tr>
<tr class="even">
<td>ushort</td>
<td>TYPE_USHORT</td>
</tr>
<tr class="odd">
<td>short</td>
<td>TYPE_SHORT</td>
</tr>
<tr class="even">
<td>uint</td>
<td>TYPE_UINT</td>
</tr>
<tr class="odd">
<td>int</td>
<td>TYPE_INT</td>
</tr>
<tr class="even">
<td>ulong</td>
<td>TYPE_ULONG</td>
</tr>
<tr class="odd">
<td>long</td>
<td>TYPE_LONG</td>
</tr>
<tr class="even">
<td>float</td>
<td>TYPE_FLOAT</td>
</tr>
<tr class="odd">
<td>double</td>
<td>TYPE_DOUBLE</td>
</tr>
<tr class="even">
<td>string</td>
<td>TYPE_STRING</td>
</tr>
<tr class="odd">
<td>list</td>
<td>TYPE_LIST_VALUES</td>
</tr>
<tr class="even">
<td>buffer</td>
<td>TYPE_BUFFER</td>
</tr>
<tr class="odd">
<td>object</td>
<td>TYPE_OBJECT</td>
</tr>
</tbody>
</table>
<h1 id="propiedades">Propiedades</h1>
<p>Las propiedades son variables y constantes, que tienen un identificador (cadena de caracteres) y un ámbito de acceso, bien sea global (entre clases) o local a la clase.</p>
<h2 id="variables-y-constantes-globales">Variables y constantes globales</h2>
<p>Es posible definir variables globales accesibles desde cualquier instancia en ejecución. Las variables globales existen en el momento en que un script las crea y mientras la instancia de dicho script perdure activa (no se borre). Para crearlas es necesario definirlas en la sección GLOBALS de la clase.</p>
<p>Del mismo modo, es posible crear etiquetas (o variables globales de solo lectura) accesibles desde cualquier script. Para ello usaremos la sección DEFINES dentro de la clase del script. Una vez creadas, al igual que las variables globales, son accesibles desde cualquier script en ejecución hasta que el objeto creador sea eliminado del sistema.</p>
<p>Las variables y constantes globales pueden tener el mismo nombre en diferentes namespaces (ámbitos) sin que haya colisión. Véase <em>NameSpaces</em>.</p>
<p>Dentro del mismo ámbito podemos tener diferentes scripts que creen las mismas variables o constantes globales. Eso no es un error y la variable/constante global no se creará dos o más veces, siempre se utilizará la misma.</p>
<p><em>Ejemplo:</em></p>
<pre><code>namespace com.retromaking.swords;</code></pre>
<pre><code>class Slurp implements Enemy
{
   globals:
      DEFAULT_HIT = 3;
   defines:
      DEFAULT_LIFE = 100;
      DEFAULT_ITEM = &quot;Random&quot;;
}</code></pre>
<h2 id="properties-y-constants">Properties y Constants</h2>
<p>Las propiedades de clase solo son accesibles desde el script que las contiene. Aunque tengamos varias instancias de la misma clase funcionando a la vez, cada instancia tendrá sus propios valores.</p>
<p>Estas propiedades pueden ser de lectura/escritura o constantes (solo lectura). En el caso de ser constantes se crearán bajo la sección CONSTANTS, y en caso de ser de lectura/escritura bajo la sección PROPERTIES. En ambos casos, podemos definir si su acceso es:</p>
<ul>
<li><p>PRIVATE: Solo accesible desde la clase que las crea.</p></li>
<li><p>PROTECTED: Accesible por la clase que las crea e hijas.</p></li>
<li><p>PUBLIC: El caso por omisión, permite el acceso desde cualquier clase.</p></li>
</ul>
<p>Para más información, véase Herencia de clases.</p>
<h2 id="locales">Locales</h2>
<p>Son aquellas que se definen en funciones o estados y solo son accesibles desde esa función o estado.</p>
<pre><code>class A
{
    properties:
         X = 5;
    function A()
    {
        _p = 6 + X;
    }
    function B()
    {
        Print(_p);
        _c = 8 + X;
    }
}</code></pre>
<p>Vemos que la propiedad &lt;X&gt; es accesible desde cualquier función. Sin embargo, en el caso de &lt;_p&gt;, que se ha definido en la función A, obtendríamos un error de compilación ya que &lt;_p&gt; no existe en la función B.</p>
<h2 id="namespaces">Namespaces</h2>
<p>La función del <strong>namespace</strong> es definir ámbitos de uso para las variables globales, etiquetas y clases.</p>
<p>Si definimos una clase con un namespace, las variables globales y etiquetas creadas se asociarán bajo dicho namespace, por lo que no colisionarán con variables globales o etiquetas con el mismo nombre definidas en otros namespaces.</p>
<h2 id="acceso-por-nombre-a-propiedades">Acceso por nombre a propiedades</h2>
<p>Mediante las sentencias _<strong>get</strong> y _<strong>set</strong> podemos leer o escribir valores en propiedades de instancia.</p>
<pre><code>_get (&quot;a&quot;);</code></pre>
<p>En el caso de que “a” no exista como propiedad, se dará un aviso de propiedad no encontrada y la función _get devolverá el valor entero cero.</p>
<pre><code>_set (&quot;a&quot;, 5);</code></pre>
<p>Si la propiedad ‘a’ no existe, se creará y la función devolverá el valor 2.</p>
<p>Si la propiedad ‘a’ ya existe, se asignará el valor y la función devolverá el valor 1.</p>
<p>Si la propiedad ‘a’ ya existe y es una constante, no se asignará el valor y la función devolverá el valor 0.</p>
<p>Con la sentencia _<strong>unset</strong> podemos eliminar las propiedades creadas.</p>
<pre><code>_unset (&quot;a&quot;);</code></pre>
<p>En caso de que la propiedad exista, devolverá verdadero y se eliminará. Si por el contrario, la propiedad no existe, devolverá falso.</p>
<h1 id="funciones-1">Funciones</h1>
<p>Mediante las funciones creamos el comportamiento de las clases. Es el mecanismo con el cual podemos escribir código dentro de las clases.</p>
<h2 id="polimorfismo">Polimorfismo</h2>
<p>Una clase puede crear el número que quiera de funciones. Estas funciones se identifican con un nombre y solo es posible usar el mismo nombre en dos o más funciones cuando el número de parámetros usado en cada una de ellas es distinto. A este mecanismo se le denomina Polimorfismo.</p>
<h2 id="virtuales">Virtuales</h2>
<p>En caso de tener herencia (véase Herencia de clases), es posible que queramos sobrescribir una función heredada. Esto podemos querer hacerlo o bien sobrescribiendo completamente el comportamiento heredado con uno nuevo, o bien ampliando o modificando dicho comportamiento.</p>
<p>Supongamos que tenemos este ejemplo:</p>
<pre><code>class Enemy
{
    properties:
        damage = 1;
    function SetDamage(_damage)
    {
        damage = _damage;
    }
}</code></pre>
<pre><code>class Troll implements Enemy
{
    properties:
        myDamage = 0;
    function SetDamage(_damage)
    {
        damage = _damage;
    }
}</code></pre>
<p>Ahora vamos a ver distintas formas de aplicar la herencia de una función en la clase hija <em>Troll.</em> Para ello vamos a ver diferentes formas de declarar la función SetDamage dentro de la clase:</p>
<h4 id="sobrescribiendo-el-comportamiento">Sobrescribiendo el comportamiento</h4>
<pre><code>function SetDamage(_damage)
{
    myDamage = _damage;
}</code></pre>
<p>Un ejemplo:</p>
<pre><code>_a = new Troll();
_a.SetDamage(5);</code></pre>
<p>Lo que hará será invocar a la función existente en la clase Troll. Por tanto solo se ejecutará el código de esa clase.</p>
<h4 id="heredando-el-comportamiento">Heredando el comportamiento</h4>
<pre><code>virtual SetDamage(_damage)
{
    myDamage += 2;
}</code></pre>
<p>Con el mismo ejemplo de antes, lo que ocurrirá es que primero se invocará la función SetDamage de Enemy y posteriormente el SetDamage de Troll.</p>
<h4 id="modificando-el-comportamiento">Modificando el comportamiento</h4>
<pre><code>function SetDamage(_damage)
{
    if (_damage &gt; 10)
        _damage = 10;
    ::SetDamage(_damage);
}</code></pre>
<p>Y, siguiendo con el mismo ejemplo que los anteriores, en este caso controlamos cuándo se invoca SetDamage del padre.</p>
<h2 id="llamada-a-funciones-por-nombre">Llamada a funciones por nombre</h2>
<p>Mediante la sentencia _<strong>call</strong> (nombre_de_funcion, [arg1, arg2, …]); podemos llamar a funciones de clase usando una cadena de caracteres con el nombre de la función. Por ejemplo:</p>
<pre><code>function Inicializar (base, nombre){}

function Salir (){}
…
_call (&#39;Inicializar&#39;, [5, &#39;Parámetro&#39;]);
_call (&#39;Salir&#39;);</code></pre>
<p>El primer parámetro de la llamada es obligatorio y recibe una cadena que determina el nombre de la función a llamar. El segundo parámetro es opcional y recibe una lista con los argumentos a pasar en la llamada. Si invocamos nombres de función que no existen o que tienen número de parámetros distintos, se generará un aviso pero no se detendrá la ejecución.</p>
<h2 id="funciones-ocultas">Funciones ocultas</h2>
<p>Es posible crear funciones ocultas, sin nombre, que solo sirven para dar funcionalidad a una llamada concreta en forma de argumento.</p>
<pre><code>_a = SetOnClick(this, function () (_sender, _event, _params)
{
        Print(&quot;Click received!&quot;);
});</code></pre>
<h1 id="el-preprocesador">El preprocesador</h1>
<p>El preprocesador se encarga de preparar el código fuente para su posterior compilación. Lo que hace es modificar el código fuente y crear uno temporal que será el que finalmente se compilará. El preprocesador es útil para poder compilar diferentes zonas de código en función de valores de estado, añadir código, definir macros, etiquetas y eliminar comentarios o texto que solo es útil al programador.</p>
<p>A continuación se muestra la sintaxis disponible:</p>
<table>
<thead>
<tr class="header">
<th>// Comentario de línea</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<pre><code></code></pre>
<p>Comentarios de línea. Terminan una vez alcanzan un retorno de carro o fin de archivo.</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 89%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
</colgroup>
<thead>
<tr class="header">
<th>/* Comentario de bloque */</th>
<th>Comentarios de bloque. Aglutina un comentario en una o varias líneas.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>#include “path”</td>
<td>Incluye un archivo. Llegada esta instrucción del preprocesador, se incluirá el archivo referenciado por “path”, que a su vez se volverá a preprocesar y compilar desde ese punto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>#filetolist “path”</td>
<td>Incluye el contenido de un archivo como una lista de bytes. Esto nos permite hacer cosas como: _a = #filetolist “image.png”</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>#define LABEL [VALUE]</td>
<td>Define una constante global con nombre LABEL y un valor VALUE. Este valor podrá ser cualquiera de los soportados por el lenguaje. En caso de omitir el valor, se usará el entero 1. Si la etiqueta ya se definió previamente, se sobrescribirá el valor.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>#undef LABEL</td>
<td>Elimina la referencia de constante global con nombre LABEL.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>#macro NAME CODE #endmacro</td>
<td>Establece una macro con nombre NAME. Cualquier referencia a dicha MACRO en el código, o sea, siempre que se detecte un uso de NAME en el código, se sustituirá por el texto CODE.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>#macro NAME(ARGS) CODE #endmacro</td>
<td>Establece una macro con nombre NAME y argumentos ARGS. Los argumentos son identificadores separados por comas y que luego podremos usar en el texto CODE. Por tanto, cualquier referencia a la macro usando argumentos, si el número de argumentos coincide con el de la macro, se sustituirá por CODE y tendrá en cuenta los argumentos para aplicar las sustituciones correspondientes. Cuando usamos # delante de un nombre de un argumento, se sustituye no por la expresión pasada a la macro, sino por el mismo nombre.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>#pragma TYPE</td>
<td>En función de TYPE, permite activar o desactivar diferentes características usadas en tiempo de compilación. Véase sección Pragmas.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>#metadata TEXT</td>
<td>Asocia metadatos a una sección del código compilado.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>#region</td>
<td>Establece una región de código. Sirve para ofrecer meta-información para el uso en aplicaciones.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>#ifdebug</td>
<td>Permite decidir si queremos compilar trozos de código en función de si estamos en DEBUG o no lo estamos, o también dependiendo del valor de ciertas etiquetas (defines). Las condiciones pueden ser:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>LABEL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>CONDITION &amp;&amp; CONDITION</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>CONDITION || CONDITION</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>LABEL == VALUE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>LABEL &gt;= VALUE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>LABEL &lt;= VALUE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>LABEL &gt; VALUE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>LABEL &lt; VALUE</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>_<em>DEBUG</em>_</td>
<td>Se sustituye por 1 o 0 en función de si estamos compilando en modo depuración o no.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>_<em>LINE</em>_</td>
<td>Se sustituye por el número de línea del código que se está compilando.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>_<em>FILE</em>_</td>
<td>Se sustituye por la ubicación del archivo de código que se está compilando.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code>#macro myMacro(x,y) x##y #endmacro </code></pre>
<p>Sustituye por las expresiones x e y concatenadas.</p>
<pre><code>#macro myMacro(x) x=#x #endmacro </code></pre>
<p>#x lo sustituirá por la expresión x convertida en texto.</p>
<p>Viendo el ejemplo anterior:</p>
<pre><code>myMacro(var);</code></pre>
<p>se sustituirá por:</p>
<pre><code>var = &quot;var&quot;;</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code>#endregion</code></pre>
<pre><code>#ifndebug</code></pre>
<pre><code>#if CONDITION </code></pre>
<pre><code>#elif CONDITION</code></pre>
<pre><code>#else</code></pre>
<pre><code>#endif</code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<pre><code></code></pre>
<h1 id="pragmas">Pragmas</h1>
<p>Utilizado por la sintaxis de preprocesador <em>#pragma</em>, permite establecer diferentes condiciones y funcionalidades del compilador.</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>typejuggling</th>
<th>Obliga o no a la especificación de tipos en todas las declaraciones. Por defecto está desactivado (especificación de tipos no obligatoria).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>strcasecmp</td>
<td>Se indica si se quiere obligar a que se tengan en cuenta mayúsculas y minúsculas a la hora de establecer nombres de propiedades, funciones, etc. Por defecto está desactivado.</td>
</tr>
<tr class="even">
<td>errorifnoreturn</td>
<td>En caso de que una función tenga que devolver algún valor, el compilador dará un error si no se especifica una sentencia &lt;return&gt;. En el caso de que queramos evitar esto, lo activaremos. Por defecto está activado.</td>
</tr>
<tr class="odd">
<td>errorifnoreturntype</td>
<td>En el caso de que tengamos que devolver algún tipo concreto en una función y no lo hagamos, mediante este pragma evitamos que el compilador provoque un error. Por defecto está activado.</td>
</tr>
<tr class="even">
<td>overrridefunctions</td>
<td>Permite sobrescribir funciones que se hayan declarado más de una vez dentro del mismo módulo. Esto quiere decir que si declaramos una función y posteriormente volvemos a declarar la misma función, la primera se anulará y el compilador no dará ningún error. Por defecto está desactivado.</td>
</tr>
<tr class="odd">
<td>constantspreserve</td>
<td>En caso de usar constantes en expresiones, el compilador las resuelve por sus valores. Mediante este pragma podemos hacer que el compilador no haga esto y obligue a hacer uso de la propiedad constante referenciada. Por defecto está desactivado.</td>
</tr>
</tbody>
</table>
<h1 id="operadores-1">Operadores</h1>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 35%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Op</strong></th>
<th><strong>Entero</strong></th>
<th><strong>Flotante</strong></th>
<th><strong>String</strong></th>
<th><strong>Lista</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>Sumar</td>
<td>Sumar</td>
<td>Concatenar</td>
<td>Concatenar</td>
</tr>
<tr class="even">
<td>+=</td>
<td>Sumar</td>
<td>Sumar</td>
<td>Concatenar</td>
<td>Concatenar</td>
</tr>
<tr class="odd">
<td>-</td>
<td>Restar</td>
<td>Restar</td>
<td>Quitar</td>
<td>Quitar</td>
</tr>
<tr class="even">
<td>-=</td>
<td>Restar</td>
<td>Restar</td>
<td>Quitar</td>
<td>Quitar</td>
</tr>
<tr class="odd">
<td>++</td>
<td>Incrementar uno</td>
<td>Incrementar uno</td>
<td>Añadir espacio al final</td>
<td>Añadir cero al final</td>
</tr>
<tr class="even">
<td>--</td>
<td>Decrementar uno</td>
<td>Decrementar uno</td>
<td>Quitar último elemento</td>
<td>Quitar último elemento</td>
</tr>
<tr class="odd">
<td>*</td>
<td>Multiplicar</td>
<td>Multiplicar</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>*=</td>
<td>Multiplicar</td>
<td>Multiplicar</td>
<td>Insertar espacio en índice</td>
<td>Insertar cero en índice</td>
</tr>
<tr class="odd">
<td>/</td>
<td>Dividir</td>
<td>Dividir</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>/=</td>
<td>Dividir</td>
<td>Dividir</td>
<td>Quitar elemento en índice</td>
<td>Quitar elemento en índice</td>
</tr>
<tr class="odd">
<td>/\</td>
<td>División Entera</td>
<td>División Entera</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>**</td>
<td>Potencia</td>
<td>Potencia</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>**=</td>
<td>Potencia</td>
<td>Potencia</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>%</td>
<td>Módulo</td>
<td>Módulo</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>%=</td>
<td>Módulo</td>
<td>Módulo</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>Desplazar bits derecha</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>&gt;&gt;=</td>
<td>Desplazar bits derecha</td>
<td></td>
<td>Añade espacios por el principio y quita caracteres por el final</td>
<td>Añade ceros por el principio y quita elementos por el final</td>
</tr>
<tr class="even">
<td>&lt;&lt;</td>
<td>Desplazar bits izquierda</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>&lt;&lt;=</td>
<td>Desplazar bits izquierda</td>
<td></td>
<td>Añade espacios por el final y quita caracteres por el principio</td>
<td>Añade ceros por el final y quita elementos por el final</td>
</tr>
<tr class="even">
<td>==</td>
<td>¿Es igual?</td>
<td>¿Es igual?</td>
<td>Comparación no sensible a mayúsculas y minúsculas</td>
<td>Comparación no sensible a mayúsculas y minúsculas</td>
</tr>
<tr class="odd">
<td>===</td>
<td>¿Es igual?</td>
<td>¿Es igual?</td>
<td>Comparación sensible a mayúsculas y minúsculas</td>
<td>Comparación sensible a mayúsculas y minúsculas</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>¿Es mayor que?</td>
<td>¿Es mayor que?</td>
<td>¿Es mayor que?</td>
<td>¿Número de elementos mayor?</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>¿Es menor que?</td>
<td>¿Es menor que?</td>
<td>¿Es menor que?</td>
<td>¿Número de elementos menor?</td>
</tr>
<tr class="even">
<td>!=</td>
<td>¿Es distinto que?</td>
<td>¿Es distinto que?</td>
<td>¿Es distinto que?</td>
<td>¿Es distinto que?</td>
</tr>
<tr class="odd">
<td>!</td>
<td>Negación</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>AND Inclusivo</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>||</td>
<td>OR Exclusivo</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>|</td>
<td>OR bits</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>&amp;</td>
<td>AND bits</td>
<td></td>
<td>Filtrar</td>
<td>Filtrar</td>
</tr>
<tr class="even">
<td>^</td>
<td>XOR bits</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>in</td>
<td></td>
<td></td>
<td>¿Valor existente?</td>
<td>¿Valor existente?</td>
</tr>
<tr class="even">
<td>()</td>
<td>Prioridad operación</td>
<td>Prioridad operación</td>
<td>Prioridad operación</td>
<td>Prioridad operación</td>
</tr>
<tr class="odd">
<td>~</td>
<td>NOT bits</td>
<td></td>
<td>Invertir la cadena</td>
<td>Invertir la lista</td>
</tr>
</tbody>
</table>
<p>NOTA: La comparación con STRINGS se realiza carácter a carácter. Mientras son iguales, la comparación se resuelve como idéntica; en el momento en que un carácter es distinto a otro, se miran sus códigos ASCII para resolver si es mayor o menor.</p>
<h4 id="operadores-con-bits-flags">Operadores con bits (Flags)</h4>
<p>En este manual existen muchas referencias al término “flags”. Este término requiere conocer el concepto de activación, desactivación y consulta de bits (banderas) mediante el uso de números enteros.</p>
<p>Los flags son siempre enteros potencia de dos: 1, 2, 4, 8, 16, 32, etc., de manera que en cada bit de un entero podemos guardar información sobre si una bandera (flag) está activa o no (vale 1 o 0). Por tanto, podremos almacenar tantas banderas como bits representen el número entero que vayamos a usar.</p>
<p>Los operadores para trabajar con flags son el OR, AND, XOR y NOT.</p>
<p>A continuación mostraremos una tabla con ejemplos de acciones básicas con flags:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>_flags = 0;</th>
<th>Inicializamos los flags. Tendremos 32 flags disponibles, ya que se inicializa como entero de 32 bits.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>_flags |= 1;</td>
<td>Activamos el flag 0.</td>
</tr>
<tr class="even">
<td>_flags |= 32;</td>
<td>Activamos el flag 5.</td>
</tr>
<tr class="odd">
<td>_flags &amp;= ~1;</td>
<td>Desactivamos el flag 0.</td>
</tr>
<tr class="even">
<td>_check = (_flags &amp; 32);</td>
<td>¿Está el flag 5 activo?</td>
</tr>
<tr class="odd">
<td>_flags |= (4 | 128 | 1024);</td>
<td>Activamos a la vez los flags 2, 7 y 10.</td>
</tr>
<tr class="even">
<td>_flags &amp;= ~(128 | 4);</td>
<td>Desactivamos los flags 2 y 7.</td>
</tr>
<tr class="odd">
<td>_check = (_flags &amp; (128 | 512));</td>
<td>¿Están los flags 7 y 9 activos?</td>
</tr>
</tbody>
</table>
<h1 id="strings">Strings</h1>
<p>Un String hace referencia a un tipo de objeto que conforma una cadena de caracteres de 8 o 16 bits, dependiendo de su codificación: las cadenas de 8 bits se gestionan como ASCII y las de 16 bits como UNICODE.</p>
<h4 id="ejemplos-de-operaciones-con-strings">Ejemplos de operaciones con strings</h4>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 58%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Operación</strong></th>
<th><strong>Acción</strong></th>
<th><strong>Resultado</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A = “123”</td>
<td>Inicializamos con un string en formato ASCIIZ</td>
<td>A = “123”</td>
</tr>
<tr class="even">
<td>A += “4”</td>
<td>Agregamos la cadena “4”</td>
<td>A = “1234”</td>
</tr>
<tr class="odd">
<td>A -= “23”</td>
<td>Quitamos la cadena “23”</td>
<td>A = “14”</td>
</tr>
<tr class="even">
<td>“6” in A</td>
<td>Busca la cadena “6” en A</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>“4” in A</td>
<td>Busca la cadena “4” en A</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>“34” in A</td>
<td>Busca la cadena “34” en A</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>A ++</td>
<td>Agrega un espacio al final</td>
<td>A = “34”</td>
</tr>
<tr class="even">
<td>A –</td>
<td>Quita el último carácter</td>
<td>A = “34”</td>
</tr>
<tr class="odd">
<td>A += 5</td>
<td>Añade 5 espacios al final</td>
<td>A = “34”</td>
</tr>
<tr class="even">
<td>A -= 5</td>
<td>Quita 5 espacios al final</td>
<td>A = “34”</td>
</tr>
<tr class="odd">
<td>A *= 1</td>
<td>Inserta un espacio en la posición 1</td>
<td>A = “3 4”</td>
</tr>
<tr class="even">
<td>A /= 1</td>
<td>Quita un carácter en la posición 1</td>
<td>A = “34”</td>
</tr>
<tr class="odd">
<td>A &gt;&gt;= 1</td>
<td>Añade un espacio por la izquierda y elimina el carácter final</td>
<td>A = " 3"</td>
</tr>
<tr class="even">
<td>A &lt;&lt;= 1</td>
<td>Añade un espacio por la derecha y elimina el primer carácter</td>
<td>A = “3”</td>
</tr>
<tr class="odd">
<td>A += ascii(‘A’)</td>
<td>Añade un carácter ASCII a la cadena</td>
<td>A = “3 A”</td>
</tr>
<tr class="even">
<td>A = ~A</td>
<td>Invierte la cadena</td>
<td>A = “A 3”</td>
</tr>
<tr class="odd">
<td>A = “123”</td>
<td>Aplica un filtro de coincidencia</td>
<td>C = “13”</td>
</tr>
<tr class="even">
<td>C = A - “2”</td>
<td>Elimina “2” de la cadena A</td>
<td>C = “13”</td>
</tr>
<tr class="odd">
<td>C = A + “2”</td>
<td>Añade “2” a la cadena A</td>
<td>C = “132”</td>
</tr>
<tr class="even">
<td>“cad” == “ena”</td>
<td>Compara las cadenas “cad” y “ena”</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>“cad” == “cad”</td>
<td>Compara las cadenas (no sensible a mayúsculas)</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>“cad” == “cAd”</td>
<td>Compara las cadenas (no sensible a mayúsculas)</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>“cad” === “cAd”</td>
<td>Compara las cadenas (sensible a mayúsculas)</td>
<td>FALSE</td>
</tr>
<tr class="even">
<td>A = “cad”</td>
<td>Accede al carácter de una cadena por índice</td>
<td>‘a’ (número con valor 97)</td>
</tr>
<tr class="odd">
<td>sizeof(“cad”)</td>
<td>Tamaño de “cad”</td>
<td>3</td>
</tr>
<tr class="even">
<td>strlen(“cad”)</td>
<td>Tamaño de “cad”</td>
<td>3</td>
</tr>
<tr class="odd">
<td>bool("")</td>
<td>Convierte una cadena a bool</td>
<td>FALSE</td>
</tr>
<tr class="even">
<td>bool(“cad”)</td>
<td>Convierte una cadena a bool</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>bool(“true”)</td>
<td>Convierte una cadena a bool</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>int(“5”)</td>
<td>Convierte una cadena a entero</td>
<td>5</td>
</tr>
<tr class="odd">
<td>int(“cad”)</td>
<td>Convierte una cadena a entero</td>
<td>0</td>
</tr>
<tr class="even">
<td>string(5)</td>
<td>Convierte un entero a cadena</td>
<td>“5”</td>
</tr>
<tr class="odd">
<td>float(“5.56”)</td>
<td>Convierte una cadena a float</td>
<td>5.56</td>
</tr>
<tr class="even">
<td>string(7.8)</td>
<td>Convierte un float a cadena</td>
<td>“7.8”</td>
</tr>
</tbody>
</table>
<pre><code>B = &quot;153&quot;</code></pre>
<pre><code>C = A &amp; B</code></pre>
<pre><code>A[1]</code></pre>
<p>NOTA: Del mismo modo que para bool, int y float, todos los tipos numéricos son susceptibles de poder ser convertidos de cadena al tipo y viceversa.</p>
<h1 id="listas">Listas</h1>
<p>Un objeto “lista” está formado por una secuencia ordenada de valores. Los valores pueden ser de cualquiera de los tipos soportados por el VR-SCRIPT, incluyendo las propias listas.</p>
<h4 id="ejemplos-de-operaciones-con-listas">Ejemplos de operaciones con listas</h4>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 51%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Operación</strong></th>
<th><strong>Acción</strong></th>
<th><strong>Resultado</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A = []</td>
<td>Inicialización</td>
<td>A = []</td>
</tr>
<tr class="even">
<td>A = [10, 8]</td>
<td>Inicialización</td>
<td>A = [10, 8]</td>
</tr>
<tr class="odd">
<td>A += [5]</td>
<td>Añadir elemento</td>
<td>A = [10, 8, 5]</td>
</tr>
<tr class="even">
<td>A -= [5]</td>
<td>Quitar elemento</td>
<td>A = [10, 8]</td>
</tr>
<tr class="odd">
<td>A += [“cad”]</td>
<td>Añadir elemento</td>
<td>A = [10, 8, “cad”]</td>
</tr>
<tr class="even">
<td>A += [10, 12]</td>
<td>Añadir elementos</td>
<td>A = [10, 8, “cad”, 10, 12]</td>
</tr>
<tr class="odd">
<td>A += [[4, 5]]</td>
<td>Añadir elemento</td>
<td>A = [10, 8, “cad”, 10, 12, [4, 5]]</td>
</tr>
<tr class="even">
<td>6 in A</td>
<td>¿Hay un 6 en A?</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>[10, 12] in A</td>
<td>¿Hay un [10, 12] en A?</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>5 in A</td>
<td>¿Hay un 5 en A?</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>A = [5, 4, 3]</td>
<td>Inicialización</td>
<td>A = [5, 4, 3]</td>
</tr>
<tr class="even">
<td>A ++</td>
<td>Añadir un cero</td>
<td>A = [5, 4, 3, 0]</td>
</tr>
<tr class="odd">
<td>A –</td>
<td>Quitar último elemento</td>
<td>A = [5, 4, 3]</td>
</tr>
<tr class="even">
<td>A += 5</td>
<td>Añadir 5 ceros</td>
<td>A = [5, 4, 3, 0, 0, 0, 0, 0]</td>
</tr>
<tr class="odd">
<td>A -= 5</td>
<td>Quitar 5 últimos elementos</td>
<td>A = [5, 4, 3]</td>
</tr>
<tr class="even">
<td>A *= 1</td>
<td>Añadir un cero en la posición 1</td>
<td>A = [5, 0, 4, 3]</td>
</tr>
<tr class="odd">
<td>A /= 2</td>
<td>Quitar elemento en la posición 2</td>
<td>A = [5, 0, 3]</td>
</tr>
<tr class="even">
<td>A &gt;&gt;= 1</td>
<td>Desplaza la lista añadiendo un cero por la izquierda</td>
<td>A = [0, 5, 0, 3]</td>
</tr>
<tr class="odd">
<td>A &lt;&lt;= 1</td>
<td>Desplaza la lista añadiendo un cero por la derecha</td>
<td>A = [5, 0, 3, 0]</td>
</tr>
<tr class="even">
<td>A = ~A</td>
<td>Invierte la lista</td>
<td>A = [0, 3, 0, 5]</td>
</tr>
<tr class="odd">
<td>A = [3, 5, 6]</td>
<td>Aplicar filtro de coincidencia</td>
<td>C = [5]</td>
</tr>
<tr class="even">
<td>C = A - [5]</td>
<td>Quitar elemento coincidente</td>
<td>C = [3, 6]</td>
</tr>
<tr class="odd">
<td>C = A + [2]</td>
<td>Añade elemento a final de la lista</td>
<td>C = [3, 6, 2]</td>
</tr>
<tr class="even">
<td>sizeof(c)</td>
<td>Tamaño de la lista</td>
<td>3</td>
</tr>
<tr class="odd">
<td>indexof(c, 6)</td>
<td>Índice del elemento en la lista</td>
<td>1</td>
</tr>
<tr class="even">
<td>C[1]</td>
<td>Acceso a la lista por índice</td>
<td>6</td>
</tr>
</tbody>
</table>
<pre><code>B = [2, 5, 2, 7]</code></pre>
<pre><code>C = A &amp; B</code></pre>
<pre><code></code></pre>
<h1 id="diccionarios">Diccionarios</h1>
<p>Un Diccionario es un tipo de lista. En este caso, denominaremos Diccionario a la lista que tiene componentes con el binomio CLAVE/VALOR, donde CLAVE es una cadena de caracteres y VALOR puede ser cualquiera de los tipos soportados por VR-SCRIPT.</p>
<p>Ejemplo de inicialización:</p>
<pre><code>A = [[&quot;barcelona&quot;, 1], [&quot;madrid&quot;, 2], [&quot;paris&quot;, 12], [&quot;luxemburgo&quot;, 123]];</code></pre>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 22%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>Operación</th>
<th>Acción</th>
<th>Resultado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A[“madrid”]</td>
<td>Acceso por nombre</td>
<td>2</td>
</tr>
<tr class="even">
<td>sizeof(A)</td>
<td>Número de elementos</td>
<td>4</td>
</tr>
<tr class="odd">
<td>A /= 1</td>
<td>Borrar elemento 1</td>
<td>A = [[“barcelona”, 1],[“paris”, 12], [“luxemburgo”, 123]];</td>
</tr>
</tbody>
</table>
<pre><code></code></pre>
<p>Las operaciones con listas también son posibles con diccionarios y siguen las mismas reglas.</p>
<h1 id="estructuras-de-control">Estructuras de control</h1>
<p>Mediante las estructuras de control vamos a gestionar qué código ejecutar y el número de veces que lo hará. En adelante veremos cómo se componen sintácticamente estas estructuras. Conviene saber qué significan los siguientes términos:</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>&lt;CONDITION&gt;</th>
<th>Se trata de una expresión que al evaluarse podrá devolver VERDADERO o FALSO, o sea, un tipo booleano.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;SENTENCE&gt;</td>
<td>Hace referencia exclusivamente a una sentencia.</td>
</tr>
<tr class="even">
<td>&lt;SENTENCES&gt;</td>
<td>Hace referencia a una o varias sentencias de código. Si se trata de varias sentencias, tendremos que ponerlas entre los símbolos { } y además, al final de cada sentencia, el separador punto y coma ‘;’</td>
</tr>
</tbody>
</table>
<p>En las estructuras de control con repeticiones podemos acabar creando bucles infinitos o sin salida si en algún momento no hacemos que la condición nos permita abandonar la iteración.</p>
<h2 id="if---else-if---else">IF - ELSE IF - ELSE</h2>
<p>Este tipo de estructuras permite controlar el flujo de ejecución del código usando condicionales. De esta manera, creamos ramas donde ejecutamos código en función de si ciertas condiciones dan verdadero o falso.</p>
<h4 id="formato-209">Formato:</h4>
<pre><code>if (&lt;CONDITION&gt;) &lt;SENTENCES&gt; [else if (&lt;CONDITION&gt;) &lt;SENTENCES&gt;] [else if (&lt;CONDITION&gt;) &lt;SENTENCES&gt;] … [else &lt;SENTENCES&gt;]</code></pre>
<h4 id="ejemplo-11"><em>Ejemplo:</em></h4>
<pre><code>if (a == 5)
{
    print (&quot;a es igual a 5&quot;);
}</code></pre>
<h2 id="while">WHILE</h2>
<p>Nos permite repetir la ejecución de código mientras se cumpla cierta condición. Es posible que el código nunca llegue a ejecutarse si inicialmente la condición no se da.</p>
<h4 id="formato-210">Formato:</h4>
<pre><code>while (&lt;CONDITION&gt;) &lt;SENTENCES&gt;</code></pre>
<h4 id="ejemplo-12">Ejemplo:</h4>
<pre><code>a = 1;
while (a &lt; 5)
{
    print (&quot;dentro del bucle&quot;);
    a = a + 1
}</code></pre>
<h2 id="do-while">DO-WHILE</h2>
<p>Esta versión del WHILE nos permite ejecutar el código al menos una vez, y continuar con la ejecución mientras se siga dando la condición.</p>
<h4 id="formato-211">Formato:</h4>
<pre><code>do &lt;SENTENCES&gt; while (&lt;CONDITION&gt;);</code></pre>
<h4 id="ejemplo-13">Ejemplo:</h4>
<pre><code>a = 5;
do
{
    a = a + 1;
    print (&quot;dentro del bucle&quot;);
}
while (a &lt; 5);</code></pre>
<h2 id="for">FOR</h2>
<p>Este tipo de estructuras está pensado para iterar entre diferentes valores o repetir un código un número determinado de veces. Por un lado, la primera sentencia suele usarse para inicializar una variable índice. La condición sirve para decidir la duración del bucle y la última sentencia define cómo varía el valor del índice. En cualquier caso, aunque suela ser el uso común del FOR, no significa que no se le puedan dar otros usos.</p>
<h4 id="formato-212">Formato:</h4>
<pre><code>for (&lt;SENTENCE_S&gt;;&lt;CONDITION&gt;;&lt;SENTENCE_E&gt;) &lt;SENTENCES&gt;</code></pre>
<h4 id="ejemplo-14">Ejemplo:</h4>
<pre><code>for (i=0; i&lt;10; i++)
{
    print (tabla[i]);
}</code></pre>
<p>Podríamos convertir un FOR en un WHILE del siguiente modo:</p>
<pre><code>&lt;SENTENCE_S&gt;;
while (&lt;CONDITION&gt;)
{
    &lt;SENTENCES&gt;
    &lt;SENTENCE_E&gt;;
}</code></pre>
<p>Se puede interrumpir la ejecución de estos bucles o ignorar una iteración usando las instrucciones BREAK y CONTINUE.</p>
<h2 id="switch">SWITCH</h2>
<p>Este tipo de estructura está pensado para ejecutar diferentes partes de código en función de valores concretos o segmentos de valores. En la sentencia SWITCH se comprueban las condiciones existentes (CASE) una a una y se ejecuta el código de todas ellas a menos que usemos la sentencia BREAK, que cancelaría esta secuencia saliendo del ámbito de la sentencia SWITCH.</p>
<h4 id="formato-213">Formato:</h4>
<pre><code>switch (&lt;EXPRESSION&gt;) { case [==,&lt;,&lt;=,&gt;,&gt;=,in] &lt;EXPRESSION&gt;: &lt;SENTENCES&gt; [break;] case [==,&lt;,&lt;=,&gt;,&gt;=,in] &lt;EXPRESSION&gt;: &lt;SENTENCES&gt; [break;] … [default: &lt;SENTENCES&gt; [break;]] }</code></pre>
<h4 id="ejemplo-15">Ejemplo:</h4>
<pre><code>switch (a)
{
    case 5: print (&quot;se trata de un error&quot;); break;
    case &lt; 12: 
    {
        print (&quot;es un animal&quot;);
        v = lista_animales[a];
    }
    break;</code></pre>
<pre><code>}</code></pre>
<h2 id="repeat">REPEAT</h2>
<p>Es una variante del WHILE y del FOR. Nos permite repetir código en base a una condición, o bien ejecutar código un número concreto de veces.</p>
<h4 id="formato-214">Formato:</h4>
<pre><code>repeat [while &lt;CONDITION&gt;] &lt;SENTENCES&gt;
repeat (&lt;EXPRESSION&gt;) &lt;SENTENCES&gt;</code></pre>
<h4 id="ejemplo-16">Ejemplo:</h4>
<pre><code>repeat (5) { print (&quot;esto se ejecutará 5 veces&quot;); }
i = 0;
repeat (i&lt;5) { print (&quot;esto también&quot;); i++; }</code></pre>
<pre><code></code></pre>
<h2 id="break-continue">BREAK, CONTINUE</h2>
<p>Para el <strong>break</strong>:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>DO/WHILE</th>
<th>Cancela la ejecución del bucle y sale del mismo. Iría a la siguiente instrucción después del WHILE.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WHILE</td>
<td>Cancela la ejecución del bucle y sale del mismo. Iría a la siguiente instrucción después del WHILE.</td>
</tr>
<tr class="even">
<td>FOR</td>
<td>Cancela la ejecución del bucle y sale del mismo. Iría a la siguiente instrucción fuera del ámbito del FOR.</td>
</tr>
<tr class="odd">
<td>SWITCH</td>
<td>Cancelar la ejecución de más código y sale del ámbito del SWITCH.</td>
</tr>
</tbody>
</table>
<p>Para el <strong>continue</strong>:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>DO/WHILE</th>
<th>Permite cancelar la iteración volviendo a la primera línea de código tras el DO.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>WHILE</td>
<td>Permite cancelar la iteración volviendo a la primera línea de código tras el WHILE.</td>
</tr>
<tr class="even">
<td>FOR</td>
<td>Ejecuta el código que define la siguiente iteración y vuelve a la primera línea de código tras el FOR.</td>
</tr>
</tbody>
</table>
<p>Tanto BREAK como CONTINUE solo tienen uso en las sentencias que se indican en las tablas anteriores. Usar estas instrucciones en otras sentencias dará un error de compilación.</p>
<h1 id="creación-y-borrado-de-instancias">Creación y borrado de instancias</h1>
<p>Para crear instancias de objetos con VR-SCRIPT se utilizan las palabras reservadas <strong>new</strong> (para la creación) y <strong>delete</strong> (para liberar recursos).</p>
<p>Podemos usar <strong>new</strong> de las siguientes formas:</p>
<pre><code>_instancia = new nombre_de_clase ();</code></pre>
<pre><code>_instancia = new nombre_de_clase (parámetros);</code></pre>
<p>nombre_de_clase hace referencia al nombre de una clase accesible por el script. Hay que tener en cuenta si la clase a la que hacemos referencia es hija de la clase desde la cual se hace la llamada a <strong>new</strong>. También si la clase pertenece al mismo namespace o si es accesible a través de los directorios importados.</p>
<p>La clase puede tener diferentes constructores _operator_new implementados. En función de cómo usemos el <strong>new</strong>, se invocará el que cumpla con el número de parámetros usado.</p>
<p>Por ejemplo:</p>
<pre><code>_enemy = new Enemy (&quot;troll&quot;, 10);</code></pre>
<p>Para eliminar una instancia de clase creada, utilizaremos:</p>
<pre><code>delete _instancia;</code></pre>
<p>Esto provocará que se ejecute el _operator_delete si está implementado en la clase de la instancia a eliminar. Este operador no usa parámetros nunca, y por tanto solo podemos definir uno por clase.</p>
<h1 id="herencia-de-clases">Herencia de clases</h1>
<p>La herencia de clases permite crear jerarquía y encapsular comportamientos. Mediante este mecanismo, podemos asociar, extender y/o redefinir código además de propiedades.</p>
<p>Ejemplo:</p>
<p>Tenemos dos archivos, Enemy.pi y Slurp.pi. Ambos son scripts.</p>
<pre><code>Archivo: Enemy.pi

class ACTOR
{
   properties:
      life = 100;
      damage = 5;

   function Init ()
   {
   }
   function Move ()
   {
   }
}

Archivo: Slurp.pi 

class ACTOR implements Enemy
{
   properties:
      life = 80; // Redefine el valor del padre
      damage = 8; // Redefine el valor del padre
      salto_h = 12.0f; // Crea una nueva propiedad

      function Init ()
      {
         ::Init (); // LLama al Init del padre
      }
      virtual Move () 
      {
      }
}</code></pre>
<p>Al declarar como virtual, siempre se llamará primero a la función Move del padre (Enemy::Move). Básicamente el virtual equivale a:</p>
<pre><code>function Move () { ::Move(); }</code></pre>
<h1 id="partials">Partials</h1>
<p>Mediante este mecanismo podemos incrustar código de archivos script dentro de otro script. No es lo mismo que “implements”, donde los métodos y propiedades forman parte de una clase. En un “partial”, se incluye el código de otro script como si fuese código propio. Una similitud a esto sería la directiva de preprocesador #include.</p>
<p>Ejemplo:</p>
<pre><code>class Base
{
    properties:
        id = 0;
        name = &quot;&quot;;

    function GetID()
    {
        return id;
    }   
}

class Book partial Base
{
    properties:
        ref = &quot;&quot;;
        content = &quot;&quot;;

    function GetContent()
    {
        return content;
    }</code></pre>
<pre><code>    function GetID()
    {
        return ref;
    }
}

_a = new Book();</code></pre>
<p>Ahora la instancia creada dispondrá tanto de funciones como de propiedades de Base como si fuesen propias, en el sentido de que si creásemos alguna propiedad con el mismo nombre en Book que en Base, tendríamos un error de compilación. En cuanto a las funciones, si en la clase Book creamos funciones que ya existen en Base, estas se ignoran y siempre se usan las que se incluyan de Base. Nótese que no hay forma de invocar la función de Book y la de Base de ningún modo: para disponer de herencia hay que usar <strong>implements</strong>.</p>
<h1 id="máquina-de-estados">Máquina de estados</h1>
<p>VR-SCRIPT permite trabajar también con una máquina de estados. Estos se declaran en el cuerpo de la clase como:</p>
<pre><code>state &lt;NAME&gt;
{
}</code></pre>
<p>Mediante la sentencia: <strong>_change</strong>(&lt;NAME&gt;); cambiamos de un estado a otro.</p>
<p>Los estados se ejecutan atómicamente; quiere decirse que todas las sentencias de un estado se ejecutan una detrás de otra dentro de la actualización de la lógica del sistema (véase Acceso al engine del sistema).</p>
<p>Ejemplo:</p>
<pre><code>class Enemy
{
    state &quot;Quiet&quot;:
    {
        if (EnemyDistance (this, player) &lt; 100.0f)
        {
            _change (&quot;FindPlayer&quot;);
        }
    }
    state &quot;FindPlayer&quot;:
    {
    }
}</code></pre>
<h1 id="evaluación-de-expresiones-al-vuelo">Evaluación de expresiones al vuelo</h1>
<p>Mediante <strong>_eval</strong> podemos evaluar expresiones en formato texto al vuelo.</p>
<pre><code>a = 10;
b = _eval (&quot;a + 10&quot;); // esto hace que b valga 20.</code></pre>
<h1 id="ejecución-de-código-al-vuelo">Ejecución de código al vuelo</h1>
<p>Mediante <strong>_run</strong> podemos ejecutar bloques en formato texto de código al vuelo.</p>
<pre><code>_block = @@ if (a==5) print (&quot;Es correcto!&quot;) else a=10; @@
_run (_block); </code></pre>
<h1 id="sobrecarga-de-operadores">Sobrecarga de operadores</h1>
<p>Son funciones que se pueden implementar y su uso va estrictamente relacionado con el tipo Pointer. El parámetro &lt;arg&gt; sería un tipo de dato (int, float, pointer, etc.). La función en teoría debería devolver el tipo requerido en la sobrecarga.</p>
<p>Mediante el uso de new y delete es posible crear nuevos objetos y eliminarlos.</p>
<pre><code>function _operator_new ()
function _operator_delete ()
function _operator_sizeof ()
function _operator_get (indice)
function _operator_set (indice, value)
function _operator_mod (v1, v2)
function _operator_mul (v1, v2)
function _operator_pow (v1, v2)
function _operator_div (v1, v2)
function _operator_add (v1, v2)
function _operator_sub (v1, v2)
function _operator_equal (v1, v2)
function _operator_notequal (v1, v2)
function _operator_great (v1, v2)
function _operator_less (v1, v2)
function _operator_greatequal (v1, v2)
function _operator_lessequal (v1, v2)
function _operator_logand (v1, v2)
function _operator_logor (v1, v2)
function _operator_lognot (v)
function _operator_not (v)
function _operator_and (v1, v2)
function _operator_xor (v1, v2)
function _operator_or (v1, v2)
function _operator_lshift (v)
function _operator_rshift (v)</code></pre>
<h1 id="optimizaciones">Optimizaciones</h1>
<p>Un acceso a una propiedad o variable global es un 25% más rápido que una llamada a función.</p>
<p>El acceso a los elementos de una cadena es más lento que el acceso a los elementos de una lista.</p>
<pre><code>cadena = &quot;ABCDEF&quot;;
lista = [65, 66, 67, 68, 69, 70];
//... dentro de un bucle
a = cadena[1]; // devuelve 66
b = lista[1]; // devuelve 66, y es más rápido
//... fin del bucle</code></pre>
<p>La condición de un bucle se evalúa en cada paso del bucle, y cada cálculo que hacemos dentro, como sizeof(value), se vuelve a calcular cada vez, así que es mejor moverlo fuera del bucle.</p>
<p>El preprocesador es lento. Cuando se define una macro el procesador debe analizar todo el archivo, hacer conversiones de texto, etc., lo cual puede ralentizar la ejecución antes del Init. Es recomendable poner las macros/defines en un archivo pequeño.</p>
<h1 id="definición-de-funciones-con-número-de-parámetros-indefinido">Definición de funciones con número de parámetros indefinido</h1>
<p>Podemos declarar una función que puede contener un numero de parámetros indefinido:</p>
<pre><code>function Test (...)
{
}</code></pre>
<p>A esta función la podemos llamar con el número de parámetros que queramos:</p>
<pre><code>Test();
Test(5);
Test(&quot;hola&quot;, 6, &quot;adios&quot;);</code></pre>
<p>Para poder acceder a los parámetros desde la función usaremos _get indicando el índice del parámetro:</p>
<pre><code>function Test (...)
{
    Print(_get(0));
}</code></pre>
<p>Con _get(“@”) obtendremos el número de parámetros variables que se le pasan a la función. En el siguiente ejemplo, tenemos un parámetro fijo obligatorio &lt;_a&gt; y el resto serían opcionales:</p>
<pre><code>function Test2 (_a, ...)
{
}</code></pre>
<p>Si la función se invoca como:</p>
<pre><code>Test2(5, 6, &quot;hello&quot;); 
_get(&quot;@&quot;) </code></pre>
<p>La función _get(“@”) nos devolverá 2.</p>
<h1 id="instanceof">Instanceof</h1>
<p>Con <strong>_instanceof</strong> podemos saber si un objeto es una instancia de una clase, y en qué grado o nivel. Por ejemplo, con la siguiente estructura de clases:</p>
<pre><code>Archivo: Animal.pi 

class Animal
{
    properties:
        A = 5;
}</code></pre>
<pre><code>Archivo: Mamifero.pi 

class Mamifero implements Animal
{
    properties:
        B = &quot;delfin&quot;;
}

Archivo: Perro.pi 

class Perro implements Mamifero
{
    properties:
        C = &quot;pastor alemán&quot;;
        function Ladra()
        {   
            // ...
        }
}</code></pre>
<p>Podemos hacer lo siguiente:</p>
<pre><code>A = new Animal();
M = new Mamifero();
P = new Perro();

_res = A._instanceof(&quot;Animal&quot;); // _res valdrá 1
_res = M._instanceof(&quot;Animal&quot;); // _res valdrá 2
_res = P._instanceof(&quot;Animal&quot;); // _res valdrá 3
_res = A._instanceof(&quot;Perro&quot;); // _res valdrá 0</code></pre>
<h1 id="implements">Implements</h1>
<p>Con la función <strong>_implements</strong>, podemos saber si un objeto implementa una función o si tiene alguna propiedad/constante que queramos averiguar. Usando el ejemplo anterior:</p>
<pre><code>_res = P._implements(&quot;Ladra&quot;); // _res = 1
_res = A._implements(&quot;Ladra&quot;); // _res = 0
_res = P._implements(&quot;C&quot;); // _res = 1
_res = P._implements(&quot;A&quot;);; // _res = 1
_res = M._implements(&quot;C&quot;);; // _res = 0</code></pre>
<h1 id="acceso-al-engine-del-sistema">Acceso al Engine del sistema</h1>
<p>El Engine del sistema o VR-ENGINE comprende la espina dorsal de todas las áreas existentes a nivel del sistema operativo. Desde aquí encontraremos todo lo necesario para controlar la máquina y sus componentes.</p>
<p>Conceptos:</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>FRAME</th>
<th>Cada FRAME representa la ejecución de los MOVE de los programas activos. En los MOVE se aplica la lógica de los programas. Cada 50/60 fotogramas por segundo (dependiendo de lo que esté configurado) se ejecuta también una secuencia de DRAW (dibujado).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MOVE</td>
<td>Denominamos al código que se ejecuta constantemente y que no utiliza ninguna llamada al API Gráfico: todo es a nivel lógico y de gestión.</td>
</tr>
<tr class="even">
<td>DRAW</td>
<td>Denominamos al código que se ejecuta cada 50/60 fotogramas por segundo y que sí utiliza llamadas al API Gráfico.</td>
</tr>
<tr class="odd">
<td>ROM BIOS</td>
<td>Referente a los archivos binarios obtenidos de volcados de memorias ROM en las diferentes máquinas virtuales.</td>
</tr>
<tr class="even">
<td>DLL</td>
<td>Dynamic Link Library (Librería de enlace dinámico). Es un archivo binario con una librería de funciones nativas, que permite extender las capacidades del sistema mediante su carga en tiempo de ejecución.</td>
</tr>
</tbody>
</table>
<h2 id="directorios">Directorios</h2>
<p>El sistema utiliza directorios de uso común. Desde estas funciones podremos obtener el acceso (ruta) a las carpetas correspondiente según la funcionalidad deseada:</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Nombre de la función</strong></th>
<th><strong>Carpeta</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GetDatabasesFolder</strong> ()</td>
<td>Bases de datos del sistema</td>
</tr>
<tr class="even">
<td><strong>GetAppsFolder</strong> ()</td>
<td>Aplicaciones instaladas</td>
</tr>
<tr class="odd">
<td><strong>GetROMBIOSFolder</strong> ()</td>
<td>ROM BIOS de las máquinas virtuales</td>
</tr>
<tr class="even">
<td><strong>GetVirtualMachinesFolder</strong> ()</td>
<td>Datos asociados a las máquinas virtuales</td>
</tr>
<tr class="odd">
<td><strong>GetVirtualMachineConfigurationsFolder</strong> ()</td>
<td>Configuraciones de las máquinas virtuales</td>
</tr>
<tr class="even">
<td><strong>GetVirtualMachineKbdLayoutsFolder</strong> ()</td>
<td>Configuraciones de teclado de las máquinas virtuales</td>
</tr>
<tr class="odd">
<td><strong>GetDocsFolder</strong> ()</td>
<td>Documentación</td>
</tr>
<tr class="even">
<td><strong>GetUserFolder</strong> ()</td>
<td>Datos de usuario</td>
</tr>
<tr class="odd">
<td><strong>GetDownloadsFolder</strong> ()</td>
<td>Descargas de Internet</td>
</tr>
<tr class="even">
<td><strong>GetTempFolder</strong> ()</td>
<td>Archivos temporales</td>
</tr>
<tr class="odd">
<td><strong>GetClassesFolder</strong> ()</td>
<td>Archivos VR-SCRIPT</td>
</tr>
<tr class="even">
<td><strong>GetDLLFolder</strong> ()</td>
<td>Librerías de carga dinámica</td>
</tr>
<tr class="odd">
<td><strong>GetLibsFolder</strong> ()</td>
<td>Librerías para desarrollo</td>
</tr>
<tr class="even">
<td><strong>GetViewFolder</strong> ()</td>
<td>Datos asociados al VR-VIEW</td>
</tr>
<tr class="odd">
<td><strong>GetViewThemesFolder</strong> ()</td>
<td>Datos asociados con los temas VR‑VIEW</td>
</tr>
<tr class="even">
<td><strong>GetViewPresetsFolder</strong> ()</td>
<td>Plantillas con las distintas configuraciones del entorno gráfico</td>
</tr>
<tr class="odd">
<td><strong>GetViewSoundsFolder()</strong></td>
<td>Sonidos asociados</td>
</tr>
<tr class="even">
<td><strong>GetViewFontsFolder()</strong></td>
<td>Fuentes asociadas</td>
</tr>
<tr class="odd">
<td><strong>GetViewRscFolder</strong> ()</td>
<td>Recursos utilizados por el VR-VIEW</td>
</tr>
<tr class="even">
<td><strong>GetBinFolder</strong> ()</td>
<td>Datos binarios genéricos</td>
</tr>
</tbody>
</table>
<h2 id="ethernet">Ethernet</h2>
<p>Permite acceder al módulo de comunicaciones de red Ethernet.</p>
<p>_ethernet = GetEngine().GetEthernet();</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Método</strong></th>
<th><strong>Funcionalidad</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>LoadParams</strong> ()</td>
<td>Carga los parámetros de configuración.</td>
</tr>
<tr class="even">
<td><strong>SaveParams</strong> ()</td>
<td>Guarda los parámetros de configuración.</td>
</tr>
<tr class="odd">
<td><strong>ApplyParams</strong> ()</td>
<td>Aplica cambios en los parámetros.</td>
</tr>
<tr class="even">
<td><strong>On</strong> ()</td>
<td>Habilita la conexión de red.</td>
</tr>
<tr class="odd">
<td><strong>Off</strong> ()</td>
<td>Deshabilita la conexión de red.</td>
</tr>
<tr class="even">
<td><strong>IsOn</strong> ()</td>
<td>Devuelve verdadero si la red está en marcha y funcionando.</td>
</tr>
<tr class="odd">
<td><strong>GetIP</strong> ()</td>
<td>Devuelve la IP existente en la configuración.</td>
</tr>
<tr class="even">
<td><strong>SetIP</strong> (ip)</td>
<td>Establece la IP que se desea utilizar.</td>
</tr>
<tr class="odd">
<td><strong>GetNetmask</strong> ()</td>
<td>Obtiene la IP de netmask en la configuración.</td>
</tr>
<tr class="even">
<td><strong>SetNetmask</strong> (_ip)</td>
<td>Establece la IP de netmask a usar.</td>
</tr>
<tr class="odd">
<td><strong>GetBroadcast</strong> ()</td>
<td>Obtiene la IP de broadcasting configurada.</td>
</tr>
<tr class="even">
<td><strong>SetBroadcast</strong> (_ip)</td>
<td>Establece la IP de broadcasting a usar.</td>
</tr>
<tr class="odd">
<td><strong>GetPrimaryDNS</strong> ()</td>
<td>Obtiene la IP del servidor DNS primario.</td>
</tr>
<tr class="even">
<td><strong>SetPrimaryDNS</strong> (_ip)</td>
<td>Establece la IP del servidor DNS primario.</td>
</tr>
<tr class="odd">
<td><strong>GetSecondaryDNS</strong> ()</td>
<td>Obtiene la IP del servidor DNS secundario.</td>
</tr>
<tr class="even">
<td><strong>SetSecondaryDNS</strong> (_ip)</td>
<td>Establece la IP del servidor DSN secundario.</td>
</tr>
<tr class="odd">
<td><strong>GetGateway</strong> ()</td>
<td>Obtiene la IP de la puerta de enlace configurada.</td>
</tr>
<tr class="even">
<td><strong>SetGateway</strong> (_ip)</td>
<td>Establece la IP de la puerta de enlace.</td>
</tr>
<tr class="odd">
<td><strong>GetDHCP</strong> ()</td>
<td>Indica si usamos el protocolo DHCP para la asignación de IPs dentro de una red.</td>
</tr>
<tr class="even">
<td><strong>SetDHCP</strong> (_v)</td>
<td>Se indica con un valor verdadero o falso si queremos usar el protocolo DHCP.</td>
</tr>
<tr class="odd">
<td><strong>CheckIP</strong> (_ip)</td>
<td>Dada una IP en formato texto, devolverá verdadero si la IP está bien conformada.</td>
</tr>
</tbody>
</table>
<p>Cuando se establecen nuevos valores en la configuración, estos no se aplican hasta llamar al método ApplyParams.</p>
<h2 id="wifi">WIFI</h2>
<p>Permite acceder al módulo de comunicaciones de red inhalámbricas.</p>
<p>_wifi = GetEngine().GetWifi();</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Método</strong></th>
<th><strong>Funcionalidad</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>LoadParams</strong> ()</td>
<td>Carga los parámetros de configuración.</td>
</tr>
<tr class="even">
<td><strong>SaveParams</strong> ()</td>
<td>Guarda los parámetros de configuración.</td>
</tr>
<tr class="odd">
<td><strong>ApplyParams</strong> ()</td>
<td>Aplica cambios en los parámetros.</td>
</tr>
<tr class="even">
<td><strong>On</strong> ()</td>
<td>Habilita la conexión de red.</td>
</tr>
<tr class="odd">
<td><strong>Off</strong> ()</td>
<td>Deshabilita la conexión de red.</td>
</tr>
<tr class="even">
<td><strong>IsOn</strong> ()</td>
<td>Devuelve verdadero si la red está en marcha y funcionando.</td>
</tr>
<tr class="odd">
<td><strong>GetHiddenSSID</strong> ()</td>
<td>Obtiene el SSID de una red oculta que queramos considerar.</td>
</tr>
<tr class="even">
<td><strong>SetHiddenSSID</strong> (ssid)</td>
<td>Establece el SSID de una red oculta que queramos considerar en el Scan.</td>
</tr>
<tr class="odd">
<td><strong>Scan</strong> ()</td>
<td>Busca redes, incluida la oculta, dentro del rango accesible por el ordenador.</td>
</tr>
<tr class="even">
<td><strong>Connect</strong> (ssid, pwd, mode = “WPA-PSK”)</td>
<td>Intenta conectarse a un dispositivo con un SSID y una contraseña. La función devolverá verdadero o falso según se haya podido iniciar la negociación de conexión.</td>
</tr>
<tr class="odd">
<td><strong>Disconnect</strong> ()</td>
<td>Si estamos conectados, cierra la conexión.</td>
</tr>
<tr class="even">
<td><strong>GetStatus</strong> ()</td>
<td>Obtiene un texto con el estado. Este podrá ser: ASSOCIATING, COMPLETED, DISCONNECTED, DISABLED, SCANNING.</td>
</tr>
<tr class="odd">
<td><strong>IsConnected</strong> ()</td>
<td>Indica si hay una conexión establecida.</td>
</tr>
<tr class="even">
<td><strong>GetIP</strong> ()</td>
<td>Devuelve la IP que se está usando en la conexión.</td>
</tr>
</tbody>
</table>
<p>Cuando se establecen nuevos valores en la configuración, estos no se aplican hasta llamar al método ApplyParams.</p>
<h2 id="httpmanager">HTTPManager</h2>
<p>Módulo para comunicarnos con el protocolo HTTP. Para hacer uso de él, es necesario crear una instancia:</p>
<pre><code>_http = GetEngine().CreateHTTPManager();</code></pre>
<p>Una vez finalicemos su utilización, habría que destruirla con tal de liberar recursos. Para ello podemos hacer:</p>
<pre><code>delete _http;</code></pre>
<p>O bien:</p>
<pre><code>GetEngine().DestroyHTTPManager(_http);</code></pre>
<p>A través de la instancia HTTPManager tenemos acceso a los siguientes métodos:</p>
<table>
<colgroup>
<col style="width: 61%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Método</strong></th>
<th><strong>Funcionalidad</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>IsProcessing</strong> ()</td>
<td>¿Existe alguna petición en curso?</td>
</tr>
<tr class="even">
<td><strong>IsDownloading</strong> ()</td>
<td>¿Existe alguna descarga en curso?</td>
</tr>
<tr class="odd">
<td><strong>Get</strong> (php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, asyncUD = null, headers = "“, postData =”")</td>
<td>Aplica una llamada GET o POST sobre una URL y obtiene los datos retornados.</td>
</tr>
<tr class="even">
<td><strong>GetDownloadedBytes</strong> (handle)</td>
<td>Obtiene los bytes descargados tras una operación Download.</td>
</tr>
<tr class="odd">
<td><strong>GetSHA1</strong> (handle)</td>
<td>Una vez descargados los datos, obtiene la firma SHA1.</td>
</tr>
<tr class="even">
<td><strong>Download</strong> (file, php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, asyncUD = null)</td>
<td>Inicia una descarga de datos hacia un archivo local desde una URL.</td>
</tr>
<tr class="odd">
<td><strong>GetInt</strong> (php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, _asyncUD = null, headers = "“, postData =”")</td>
<td>Es un GET y convierte los datos devueltos a un número entero.</td>
</tr>
<tr class="even">
<td><strong>GetString</strong> (php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, asyncUD = null, headers = "“, postData =”")</td>
<td>Es un GET y convierte los datos devueltos en una cadena.</td>
</tr>
<tr class="odd">
<td><strong>GetXML</strong> (php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, asyncUD = null, headers = "“, postData =”")</td>
<td>Es un GET y obtiene un objeto XML con los datos devueltos.</td>
</tr>
<tr class="even">
<td><strong>GetJSON</strong> (php, args = [], asyncClass = null, asyncEvent = “OnHTTPGet”, asyncUD = null, headers = "“, postData =”")</td>
<td>Es un GET y obtiene un objeto JSON con los datos devueltos.</td>
</tr>
</tbody>
</table>
<h2 id="config-1">Config</h2>
<p>Cambios en los parámetros de configuración del sistema.</p>
<p>function <strong>SetConfigProperty</strong> (section, pName, value)</p>
<p>Asigna un valor a un campo determinado dentro de una sección de la configuración. Si la sección no existe, se creará. &lt;section&gt; es una cadena de texto, &lt;pName&gt; es el nombre de la propiedad y &lt;value&gt; podrá ser un booleano, número, cadena de texto o lista.</p>
<p>function <strong>GetConfigPropertyBool</strong> (section, pName, def = false) : bool</p>
<p>Dado el nombre de una sección &lt;section&gt; y el de una propiedad &lt;pName&gt;, devolverá el valor que tenga asociado en formato booleano. En caso de no existir la propiedad o la sección, devolverá el parámetro por defecto &lt;def&gt;.</p>
<p>function <strong>GetConfigPropertyInt</strong> (section, pName, def = 0) : int</p>
<p>Dado el nombre de una sección &lt;section&gt; y el de una propiedad &lt;pName&gt;, devolverá el valor que tenga asociado en formato entero. En caso de no existir la propiedad o la sección, devolverá el parámetro por defecto &lt;def&gt;.</p>
<p>function <strong>GetConfigPropertyFloat</strong> (section, pName, def = 0) : int</p>
<p>Dado el nombre de una sección &lt;section&gt; y el de una propiedad &lt;pName&gt;, devolverá el valor que tenga asociado en formato flotante. En caso de no existir la propiedad o la sección, devolverá el parámetro por defecto &lt;def&gt;.</p>
<p>function <strong>GetConfigPropertyString</strong> (section, pName, def = "") : string</p>
<p>Dado el nombre de una sección &lt;section&gt; y el de una propiedad &lt;pName&gt;, devolverá el valor que tenga asociado en formato cadena de texto. En caso de no existir la propiedad o la sección, devolverá el parámetro por defecto &lt;def&gt;.</p>
<p>function <strong>GetConfigPropertyList</strong> (section, pName, def = []) : list</p>
<p>Dado el nombre de una sección &lt;section&gt; y el de una propiedad &lt;pName&gt;, devolverá el valor que tenga asociado en formato lista. En caso de no existir la propiedad o la sección, devolverá el parámetro por defecto &lt;def&gt;.</p>
<h2 id="registro">Registro</h2>
<p>El registro es un diccionario de claves y valores que se mantiene de forma perpetua en el sistema. Las claves pueden ser de acceso global, para todas las aplicaciones, o solamente para una aplicación en concreto.</p>
<p>function <strong>SetRegistry</strong> (name, value)</p>
<p>Asigna un valor &lt;value&gt; a la clave de registro global &lt;name&gt;. Estas claves son accesibles por cualquier aplicación.</p>
<p>function <strong>GetRegistry</strong> (name, def = "")</p>
<p>Obtiene un valor de una clave de registro global llamada &lt;name&gt;. En caso de no existir la clave, devolverá el valor por defecto &lt;def&gt;.</p>
<p>function <strong>DelRegistry</strong> (name)</p>
<p>Elimina la clave &lt;name&gt; del registro global.</p>
<p>function <strong>SetBundleRegistry</strong> (bundle, name, value)</p>
<p>Asigna un valor &lt;value&gt; a la clave de registro con nombre &lt;name&gt; para la aplicación con identificador &lt;bundle&gt;. Este identificador se puede obtener a partir del controlador de programa (véase en la sección Programas) con la función GetBundleName(). Desde el propio controlador existen las funciones SetRegistry y GetRegistry, que trabajan directamente sobre las claves de la aplicación y no las globales.</p>
<p>function <strong>GetBundleRegistry</strong> (bundle, name, def = "")</p>
<p>Obtiene el valor de una clave de registro con nombre &lt;name&gt; para la aplicación con identificador &lt;bundle&gt;. En caso de no existir la clave, devolverá el valor por defecto &lt;def&gt;.</p>
<p>function <strong>DelBundleRegistry</strong> (bundle, name)</p>
<p>Elimina una clave de registro con nombre &lt;name&gt; de la aplicación con identificador &lt;bundle&gt;.</p>
<h2 id="carpetas">Carpetas</h2>
<p>Gestión de carpetas. Una carpeta o directorio hace referencia a un apartado dentro de una unidad de almacenamiento. Dentro de una carpeta podremos crear otras carpetas y/o archivos. Existen dos tipos de rutas: LÓGICA, usada por el sistema MSXVR para hacer referencia a archivos dentro de sus unidades de almacenamiento lógicas, y NATIVA, usadas por el API nativo para ser usadas por el sistema operativo anfitrión.</p>
<p>function <strong>GetDriveNames</strong> () : list</p>
<p>Obtiene una lista donde cada elemento es el nombre de una unidad accesible por el sistema. Solo se retornan los nombres de las unidades no ocultas.</p>
<p>function <strong>GetPath</strong> (path) : string</p>
<p>A nivel de VR-ENGINE se trabaja con carpetas y archivos ubicados en unidades lógicas. Estas unidades lógicas están montadas sobre otros sistemas, como pueden ser unidades remotas o unidades locales del sistema operativo anfitrión. Si vamos a usar funciones nativas del API, estas trabajan con rutas ubicadas en el sistema operativo anfitrión, por ello será necesario convertir la ruta lógica a una nativa.</p>
<p>function <strong>GetAbsoluteLogicPath</strong> (path) : string</p>
<p>Dada una ruta lógica relativa, devolverá la ruta lógica completa. Esta incluirá unidad lógica, directorio completo, nombre de archivo y extensión.</p>
<p>function <strong>GetCWDriveVolume</strong> () : string</p>
<p>Devolverá el nombre del volumen de la unidad del directorio de trabajo actual.</p>
<p>function <strong>GetCWD</strong> () : string</p>
<p>Devolverá la ruta completa del directorio de trabajo actual. Incluye la unidad lógica en la ruta.</p>
<p>function <strong>GetCWDriveName</strong> () : string</p>
<p>Devolverá el nombre de la unidad del directorio de trabajo actual. El nombre no incluye el símbolo ‘:’ al final.</p>
<p>function <strong>GetCWPath</strong> () : string</p>
<p>Devolverá la ruta completa del directorio de trabajo actual. No incluye la unidad lógica en la ruta.</p>
<p>function <strong>ChangeFolder</strong> (path) : bool</p>
<p>Dada una ruta lógica &lt;path&gt;, cambiará el directorio de trabajo a esa nueva ruta. La ruta ha de apuntar a un directorio. En caso de que la operación no sea correcta, la función devolverá falso. Si se ha podido cambiar de directorio de trabajo, se devolverá verdadero.</p>
<p>function <strong>CreateFolder</strong> (path) : bool</p>
<p>Permite crear un directorio en la ruta lógica indicada en &lt;path&gt;. Si la ruta es correcta, apunta a un directorio, es un directorio alcanzable y no está ya creado, la función creará el directorio y devolverá verdadero. En caso de error, devolverá falso. Hay que considerar que para crear el directorio, es necesario que toda la ruta hasta el directorio esté creada, en caso de no ser así y queremos igualmente crear toda la secuencia de directorios, sería necesario utilizar la función <em>CreateRecursiveFolder</em>.</p>
<p>function <strong>DestroyFolder</strong> (path) : bool</p>
<p>Elimina un directorio accesible a través de la ruta lógica &lt;path&gt;. Si se ha podido eliminar, la función devolverá verdadero. En caso contrario, devolverá falso.</p>
<p>function <strong>CreateRecursiveFolder</strong> (path) : bool</p>
<p>Permite crear toda la secuencia de carpetas necesaria para poder alcanzar la ruta lógica indicada en &lt;path&gt;. En caso de que la operación haya sido exitosa, se devolverá verdadero. En caso contrario, devolverá falso.</p>
<p>function <strong>FolderIsEmpty</strong> (path) : bool</p>
<p>Indica si la ruta lógica hasta un directorio &lt;path&gt; está vacía, o sea, no contiene ningún otro archivo o subdirectorio. En caso de ser así, la función devolverá verdadero.</p>
<p>function <strong>FindFiles</strong> (path, ext = false) : list</p>
<p>Esta función devuelve una lista de archivos contenidos en el directorio de la ruta lógica &lt;path&gt;. Como parte del &lt;path&gt; se ha de especificar el comodín o criterio de búsqueda. Si &lt;ext&gt; es falso, se devolverán solo los nombres de los archivos; en caso de que sea verdadero, se devolverá información extendida, y por tanto cada elemento de la lista contendrá:</p>
<table>
<thead>
<tr class="header">
<th>FILENAME</th>
<th>Nombre del archivo junto a la extensión.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ATTRIBUTES</td>
<td>Atributos del archivo. Son uno o varios flags:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FFI_ATTRIBUTE_DIRECTORY</td>
<td>Es un directorio.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FFI_ATTRIBUTE_ARCHIVE</td>
<td>Es un archivo.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FFI_ATTRIBUTE_SYSTEM</td>
<td>Es de sistema.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>FFI_ATTRIBUTE_HIDDEN</td>
<td>Está oculto.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>FFI_ATTRIBUTE_READONLY</td>
<td>Es de solo lectura.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>SIZE</td>
<td>Tamaño del archivo sin comprimir. Dato en bytes.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>SIZE_COMPRESSED</td>
<td>Tamaño del archivo comprimido, si lo está. Dato en bytes.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>TIME_CREATED</td>
<td>Fecha y hora de creación. Dato en milisegundos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>TIME_MODIFICATED</td>
<td>Fecha y hora de modificación. Dato en milisegundos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<pre><code>_list = GetEngine().FindFiles(&quot;C:/graphics/*.tga&quot;);</code></pre>
<p>function <strong>FindFolders</strong> (path, ext = false) : list</p>
<p>Esta función devuelve una lista de directorios contenidos en la ruta lógica indicada por &lt;path&gt;. Como parte del &lt;path&gt; se ha de especificar el comodín o criterio de búsqueda. Si &lt;ext&gt; es falso, se devolverán solo los nombres de los directorios; en caso de que sea verdadero, se devolverá información extendida (véase <em>FindFiles</em>).</p>
<p>function <strong>FolderCopy</strong> (from, to) : bool</p>
<p>Dada una ruta lógica a un directorio &lt;from&gt; origen y otro destino &lt;to&gt;, se copiarán todos los archivos y directorios que cuelguen de &lt;from&gt; al destino &lt;to&gt;. Si la operación se ha podido realizar con éxito se devolverá verdadero.</p>
<p>function <strong>FolderMove</strong> (from, to) : bool</p>
<p>La función FolderMove funciona de un modo muy similar a FolderCopy. La diferencia está en que mueve los archivos y directorios. Por tanto, los elimina del directorio origen.</p>
<p>function <strong>FolderRename</strong> (from, to) : bool</p>
<p>Permite renombrar el nombre de la carpeta accesible a través de la ruta lógica &lt;from&gt; por el nuevo nombre indicado en &lt;to&gt;. En caso de que la operación se haya podido completar, la función devolverá verdadero.</p>
<p>function <strong>GetFolderInfo</strong> (path) : list</p>
<p>Dada una ruta lógica a un directorio, la función devolverá una lista donde cada elemento indica, en este orden: [BYTES LIBRES, BYTES TOTALES].</p>
<p>Ejemplo:</p>
<pre><code>_list = GetFolderInfo(&quot;C:/&quot;);</code></pre>
<p>Esto devolverá los bytes libres que tenemos en C:/ y el total disponible.</p>
<h2 id="archivos">Archivos</h2>
<p>function <strong>FileOpenMem</strong> (buffer) : pointer</p>
<p>Devuelve un controlador de archivo para manipular un buffer de memoria. La instancia &lt;buffer&gt; corresponde a un buffer de datos del API Nativo (véanse las funciones Buffer).</p>
<p>function <strong>FileOpen</strong> (path, mode = FILE_MODE_READ) : pointer</p>
<p>Abre un archivo ubicado en la ruta lógica &lt;path&gt;. El archivo se abrirá usando el modo establecido en &lt;mode&gt;. Para ver todos los modos véase la función <em>File_Open</em> del API Nativo. En caso de que la operación haya sido un éxito, se devolverá un controlador de archivo (véase en esta misma sección el apartado <em>Controlador de archivo</em>).</p>
<p>function <strong>FileClose</strong> (handle)</p>
<p>Dado un controlador de archivo, libera los recursos utilizados.</p>
<p>function <strong>FileExists</strong> (path) : bool</p>
<p>Dada una ruta lógica a un archivo &lt;path&gt;, la función determina si ese archivo existe (verdadero) o no (falso).</p>
<p>function <strong>FolderExists</strong> (path) : bool</p>
<p>Dada una ruta lógica a un directorio &lt;path&gt;, la función determina si ese directorio existe (verdadero) o no (falso).</p>
<p>function <strong>FileIsOpened</strong> (path) : bool</p>
<p>Dada una ruta lógica a un archivo &lt;path&gt;, la función determina si el archivo está abierto por una aplicación o por el sistema. En caso de estarlo, devolverá verdadero.</p>
<p>function <strong>FileSetAttributes</strong> (path, attrib)</p>
<p>Dada una ruta lógica a un archivo o directorio &lt;path&gt;, podemos cambiar ciertos atributos, que son:</p>
<table>
<thead>
<tr class="header">
<th>FFI_ATTRIBUTE_HIDDEN</th>
<th>Está oculto.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FFI_ATTRIBUTE_READONLY</td>
<td>Es de solo lectura.</td>
</tr>
</tbody>
</table>
<p>function <strong>FileGetAttributes</strong> (path) : int</p>
<p>Dada una ruta lógica a un archivo o directorio &lt;path&gt;, obtenemos los flags asociados a sus atributos (véase <em>FindFiles</em>).</p>
<p>function <strong>FileDelete</strong> (path) : bool</p>
<p>Dada una ruta lógica a un archivo &lt;path&gt;, esta función eliminará el archivo. Si la operación ha tenido éxito, la función devolverá verdadero.</p>
<p>function <strong>FileCopy</strong> (from, to, ctx = null, function = "") : bool</p>
<p>Dada una ruta lógica a un archivo origen &lt;from&gt; y otro destino &lt;to&gt; se copiará el archivo origen al destino. Si la operación tiene éxito, la función devolverá verdadero. El destino puede ser una ruta a un archivo o una ruta a un directorio. Esta función permite especificar un callback que nos va indicando el progreso de la copia. La función callback ha de tener el siguiente prototipo:</p>
<pre><code>function OnFileCopyCB (progress, from, to);</code></pre>
<p>El parámetro &lt;progress&gt; es un valor real que irá de 0 a 1, siendo 0 el inicio de la copia y 1 la finalización.</p>
<p>function <strong>FileMove</strong> (from, to) : bool</p>
<p>Función análoga a FileCopy. En este caso, la función borra el archivo origen &lt;from&gt;.</p>
<p>function <strong>FileRename</strong> (from, to) : bool</p>
<p>Dada una ruta lógica a un archivo origen &lt;from&gt;, se cambiará el nombre del archivo por el especificado en &lt;to&gt;. En caso de que la operación se haya completado con éxito, la función devolverá verdadero.</p>
<h4 id="controlador-de-archivo">Controlador de archivo</h4>
<p>Un controlador de archivo es un tipo de objeto que nos permite hacer uso de los siguientes métodos:</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>GetLogicalPath</strong> ()</th>
<th>Obtiene la ruta lógica al archivo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GetPath</strong> ()</td>
<td>Obtiene la ruta nativa al archivo.</td>
</tr>
<tr class="even">
<td><strong>Size</strong> ()</td>
<td>Devuelve el tamaño del archivo.</td>
</tr>
<tr class="odd">
<td><strong>SetPos</strong> (pos)</td>
<td>Sitúa el cursor de archivo en una posición &lt;pos&gt;.</td>
</tr>
<tr class="even">
<td><strong>GetPos</strong> ()</td>
<td>Obtiene la posición del cursor del archivo.</td>
</tr>
<tr class="odd">
<td><strong>Flush</strong> ()</td>
<td>Vuelca al archivo los datos que puedan estar pendientes de escritura.</td>
</tr>
<tr class="even">
<td><strong>ReadByte</strong> ()</td>
<td>Lee un byte con signo (-128, 127).</td>
</tr>
<tr class="odd">
<td><strong>ReadUByte</strong> ()</td>
<td>Lee un byte sin signo (0, 255).</td>
</tr>
<tr class="even">
<td><strong>ReadShort</strong> ()</td>
<td>Lee dos bytes con signo.</td>
</tr>
<tr class="odd">
<td><strong>ReadUShort</strong> ()</td>
<td>Lee dos bytes sin signo.</td>
</tr>
<tr class="even">
<td><strong>ReadInt</strong> ()</td>
<td>Lee cuatro bytes con signo.</td>
</tr>
<tr class="odd">
<td><strong>ReadUInt</strong> ()</td>
<td>Lee cuatro bytes sin signo.</td>
</tr>
<tr class="even">
<td><strong>ReadLong</strong> ()</td>
<td>Lee ocho bytes con signo.</td>
</tr>
<tr class="odd">
<td><strong>ReadULong</strong> ()</td>
<td>Lee ocho bytes sin signo.</td>
</tr>
<tr class="even">
<td><strong>ReadFloat</strong> ()</td>
<td>Lee cuatro bytes como número flotante.</td>
</tr>
<tr class="odd">
<td><strong>Read</strong> (buffer, off = 0, len = -1)</td>
<td>Lee &lt;len&gt; datos a un buffer.</td>
</tr>
<tr class="even">
<td><strong>ReadText</strong> (len = 256, killRet = true)</td>
<td>Lee una línea de textos de hasta &lt;len&gt; bytes y elimina el salto de línea final, si existe, en caso de que killRet sea verdadero.</td>
</tr>
<tr class="odd">
<td><strong>ReadString</strong> ()</td>
<td>Lee un string (previamente guardado como WriteString).</td>
</tr>
<tr class="even">
<td><strong>WriteByte</strong> (v)</td>
<td>Escribe un byte.</td>
</tr>
<tr class="odd">
<td><strong>WriteShort</strong> (v)</td>
<td>Escribe dos bytes.</td>
</tr>
<tr class="even">
<td><strong>WriteInt</strong> (v)</td>
<td>Escribe cuatro bytes.</td>
</tr>
<tr class="odd">
<td><strong>WriteLong</strong> (v)</td>
<td>Escribe ocho bytes.</td>
</tr>
<tr class="even">
<td><strong>WriteFloat</strong> (v)</td>
<td>Escribe cuatro bytes.</td>
</tr>
<tr class="odd">
<td><strong>Write</strong> (buffer, off = 0, len = -1)</td>
<td>Escribe &lt;len&gt; bytes de un buffer.</td>
</tr>
<tr class="even">
<td><strong>WriteFile</strong> (file)</td>
<td>Escribe el contenido del controlador de archivo indicado en &lt;file&gt;.</td>
</tr>
<tr class="odd">
<td><strong>WriteText</strong> (text)</td>
<td>Escribe la cadena de caracteres &lt;text&gt; y agrega el salto de línea correspondiente.</td>
</tr>
<tr class="even">
<td><strong>WriteChars</strong> (text)</td>
<td>Escribe únicamente los caracteres existentes en &lt;text&gt;.</td>
</tr>
<tr class="odd">
<td><strong>WriteString</strong> (string)</td>
<td>Escribe la cadena de caracteres &lt;string&gt;.</td>
</tr>
<tr class="even">
<td><strong>IsEOF</strong> ()</td>
<td>Determina si se ha alcanzado el final de archivo.</td>
</tr>
<tr class="odd">
<td><strong>CopyTo</strong> (file)</td>
<td>Copia el contenido del archivo a otro controlador de archivo &lt;file&gt;.</td>
</tr>
</tbody>
</table>
<h2 id="programas">Programas</h2>
<p>Aplicaciones VR-SCRIPT lanzadas y gestionadas por el sistema.</p>
<p>function <strong>GetActiveProgram</strong> () : pointer</p>
<p>Devuelve el programa que se encuentra actualmente en activo. Aunque puede haber varios programas a la vez funcionando, solo puede haber uno activado y con privilegios exclusivos de acceso al interfaz gráfico.</p>
<p>function <strong>GetNumPrograms</strong> () : int</p>
<p>Devuelve el número de programas cargados en memoria y por tanto ocupando recursos.</p>
<p>function <strong>KillProgram</strong> (program) : bool</p>
<p>Dado el controlador de un programa, elimina los recursos que ocupa. Si el programa es eliminado, la función devolverá verdadero. En caso de que el programa ya haya sido borrado o tenga un puntero inválido, la función devolverá falso.</p>
<p>function <strong>KillProgramWithPID</strong> (pid) : bool</p>
<p>Dado el “Program ID” &lt;pid&gt; elimina el controlador de programa asociado. SI el PID no existe, la función devolverá falso. Si el programa ha sido eliminado, devolverá verdadero.</p>
<p>function <strong>GetProgram</strong> (ix) : pointer</p>
<p>Permite obtener el controlador de programa a partir de un índice &lt;ix&gt;. Este índice irá desde 0 hasta <em>GetNumPrograms()</em> - 1.</p>
<p>function <strong>GetProgramWithPID</strong> (pid) : pointer</p>
<p>Dado el “Program ID” &lt;pid&gt; obtiene el controlador de programa asociado. En caso de que el PID no exista, devolverá NULL.</p>
<p>function <strong>GetProgramList</strong> () : list</p>
<p>Devuelve la lista de todos los controladores de programa activos.</p>
<p>function <strong>FindProgram</strong> (name) : pointer</p>
<p>Dado el nombre asociado a un programa &lt;name&gt;, devolverá su controlador en caso de que exista. Si no existiese, la función devolverá NULL.</p>
<p>function <strong>FindProgramByBundleName</strong>(name) : pointer</p>
<p>Los programas tienen un nombre de paquete asociado. En este caso, la función devolverá el controlador de programa que corresponda con el nombre de paquete &lt;name&gt;. En caso de no hallarlo, devolverá NULL.</p>
<p>function <strong>CountProgram</strong> (name) : int</p>
<p>Devolverá el número de programas cargados que tengan el mismo nombre. Esto permite conocer el número de instancias del mismo programa corriendo en el sistema.</p>
<p>function <strong>GetDOS</strong> (forceCreation = false) : pointer</p>
<p>Obtiene un controlador de programa VR-DOS activo. En caso de que no exista, la función devolverá NULL. Sin embargo, si queremos obligar a que siempre devuelva un controlador de programa VR-DOS, usaremos &lt;forceCreation&gt; con valor verdadero.</p>
<p>function <strong>RunSystem</strong> (params = [], dos = null)</p>
<p>Ejecuta la aplicación VR-SYSTEM asociada. Se le pasarán los parámetros indicados en una lista &lt;params&gt; y se le podrá asociar un controlador de programa DOS &lt;dos&gt;.</p>
<p>function <strong>RunBasic</strong> (params = [], dos = null)</p>
<p>Ejecuta la aplicación VR-BASIC asociada. Se le pasarán los parámetros indicados en una lista &lt;params&gt; y se le podrá asociar un controlador de programa DOS &lt;dos&gt;.</p>
<p>function <strong>RunTextEditor</strong> (params = [])</p>
<p>Ejecuta la aplicación de edición de texto por defecto en el sistema. Se le pasarán los parámetros indicados en una lista &lt;params&gt;.</p>
<p>function <strong>RunTextViewer</strong> (params = [])</p>
<p>Ejecuta la aplicación de visualización de texto por defecto en el sistema. Se le pasarán los parámetros indicados en una lista &lt;params&gt;.</p>
<p>function <strong>RunFileExplorer</strong> (params = [])</p>
<p>Ejecuta la aplicación de exploración de archivos por defecto en el sistema. Se le pasarán los parámetros indicados en una lista &lt;params&gt;.</p>
<p>function <strong>RunImageViewer</strong> (params = [])</p>
<p>Ejecuta la aplicación de visualización de imágenes por defecto en el sistema. Se le pasarán los parámetros indicados en una lista &lt;params&gt;.</p>
<p>function <strong>RunProgramWithParams</strong> (name, params)</p>
<p>Ejecuta un programa que se encuentre dentro de la ruta accesible. Este programa podrá tener extensión .BAT, .PI o .APP.</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>.BAT</th>
<th>Buscará en el directorio de trabajo actual y, si no se encuentra, buscará en los directorios establecidos en la variable de entorno PATH.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.PI, .APP</td>
<td>Buscará en el directorio de trabajo actual y si no se encuentra, buscará en la carpeta de aplicaciones.</td>
</tr>
</tbody>
</table>
<p>Los parámetros &lt;params&gt; se pasarán al programa en formato lista. Estos parámetros serán posteriormente accesibles por el programa usando los métodos <em>GetNumParams</em> y <em>GetParam</em> del interfaz <em>Engine_Program</em>.</p>
<p>function <strong>RunProgram</strong> (name, params = [], parent = null)</p>
<p>Funciona de forma similar a <em>RunProgramWithParams</em>, pero en este caso los parámetros se pasan directamente como un elemento más de la lista [[“params”, params]].</p>
<p>Es la llamada a bajo nivel para poder ejecutar programas bajo condiciones especiales. También permite asociar un programa como hijo de otro &lt;parent&gt;.</p>
<h4 id="controlador-de-programa">Controlador de programa</h4>
<p>Los métodos accesibles son:</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>EnableDraw</strong> ()</th>
<th>Habilita la función Draw para dibujar.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>DisableDraw</strong> ()</td>
<td>Deshabilita la función Draw de dibujado.</td>
</tr>
<tr class="even">
<td><strong>Hide</strong> ()</td>
<td>Deja de visualizar los gráficos generados por la función Draw y/o por la ventana asociada.</td>
</tr>
<tr class="odd">
<td><strong>Show</strong> ()</td>
<td>Vuelve a visualizar los gráficos generados por la función Draw y/o por la ventana asociada.</td>
</tr>
<tr class="even">
<td><strong>End</strong> (ret)</td>
<td>Finaliza la ejecución del programa y devuelve un código de error.</td>
</tr>
<tr class="odd">
<td><strong>IsDeleted</strong> ()</td>
<td>Permite saber si el programa está en proceso de eliminación.</td>
</tr>
<tr class="even">
<td><strong>LoadLibrary</strong> (name, params = [])</td>
<td>Carga una librería para hacer uso de nuevas funcionalidades.</td>
</tr>
<tr class="odd">
<td><strong>RunProgramWithParams</strong> (name, params = [])</td>
<td>Ejecuta un programa con parámetros (véase Engine::RunProgramWithParams).</td>
</tr>
<tr class="even">
<td><strong>RunChildProgramWithParams</strong> (name, params = [])</td>
<td>Igual que RunProgramWithParams, pero se vincula como programa hijo. Por tanto cuelga del programa padre y hereda comportamientos. Si el padre se hace invisible, los hijos también. Si el padre se detiene, los hijos también.</td>
</tr>
<tr class="odd">
<td><strong>PauseProgram</strong> ()</td>
<td>Pausa un programa.</td>
</tr>
<tr class="even">
<td><strong>ResumeProgram</strong> ()</td>
<td>Reanuda un programa.</td>
</tr>
<tr class="odd">
<td><strong>IsPausedProgram</strong> ()</td>
<td>Indica si un programa está pausado.</td>
</tr>
<tr class="even">
<td><strong>CreateWindow</strong> ()</td>
<td>Crea una ventana y la asocia al programa. Devuelve un controlador de ventana.</td>
</tr>
<tr class="odd">
<td><strong>Activate</strong> ()</td>
<td>Activa el programa y su ventana asociada, si la tiene.</td>
</tr>
<tr class="even">
<td><strong>GetNumParams</strong> ()</td>
<td>Obtiene el número de parámetros que se le hayan pasado.</td>
</tr>
<tr class="odd">
<td><strong>GetParam</strong> (ix)</td>
<td>Devuelve el parámetro con índice &lt;ix&gt; (dicho índice irá de 0 hasta GetNumParams-1).</td>
</tr>
<tr class="even">
<td><strong>GetDOS</strong> ()</td>
<td>Devuelve el controlador VR-DOS que lo ha creado, si existe.</td>
</tr>
<tr class="odd">
<td><strong>GetView</strong> ()</td>
<td>Devuelve el controlador VR-VIEW desde el que se controla todo el interfaz gráfico de usuario.</td>
</tr>
<tr class="even">
<td><strong>GetEngine</strong> ()</td>
<td>Devuelve el controlador de VR-ENGINE.</td>
</tr>
<tr class="odd">
<td><strong>GetWindow</strong> ()</td>
<td>Devuelve el controlador de la ventana asociada, si existe.</td>
</tr>
<tr class="even">
<td><strong>GetTopWindow</strong> ()</td>
<td>Devuelve el controlador de ventana padre. En caso de que la ventana de programa no tenga uno devolverá NULL.</td>
</tr>
<tr class="odd">
<td><strong>GetActiveWindow</strong> ()</td>
<td>Devuelve la ventana activa.</td>
</tr>
<tr class="even">
<td><strong>GetMenu</strong> ()</td>
<td>Devuelve el menú asociado a la ventana.</td>
</tr>
<tr class="odd">
<td><strong>GetDesktop</strong> ()</td>
<td>Devuelve el controlador de VR‑Desktop.</td>
</tr>
<tr class="even">
<td><strong>GetRootPath</strong> ()</td>
<td>Obtiene la ruta del programa.</td>
</tr>
<tr class="odd">
<td><strong>GetBundleName</strong> ()</td>
<td>Obtiene el nombre del paquete del programa.</td>
</tr>
<tr class="even">
<td><strong>CountChildrenPrograms</strong> ()</td>
<td>Cuenta el número de programas hijos.</td>
</tr>
<tr class="odd">
<td><strong>GetChildrenPrograms</strong> ()</td>
<td>Obtiene una lista con todos los controladores de los programas hijos.</td>
</tr>
<tr class="even">
<td><strong>SetRegistry</strong> (key, value)</td>
<td>Establece una clave de registro exclusiva y asociada al paquete del programa.</td>
</tr>
<tr class="odd">
<td><strong>GetRegistry</strong> (key, def = "")</td>
<td>Obtiene una clave de registro exclusiva y asociada al paquete del programa.</td>
</tr>
<tr class="even">
<td><strong>DelRegistry</strong> (key)</td>
<td>Borra una clave de registro exclusiva y asociada al paquete del programa.</td>
</tr>
<tr class="odd">
<td><strong>Sleep</strong> (ms)</td>
<td>Duerme el programa durante un número de milisegundos &lt;ms&gt;</td>
</tr>
</tbody>
</table>
<h2 id="geekreader">GeekReader</h2>
<p>Interfaz al hardware del ordenador. Para acceder a la instancia, debemos hacer:</p>
<pre><code>_gr = GetEngine().GetGeekReader();</code></pre>
<p>Una vez disponemos de la instancia, podemos acceder a los siguientes métodos, clasificados según el hardware sobre el que operan:</p>
<h4 id="slots">Slots</h4>
<p>function <strong>VCCOff</strong> ()</p>
<p>Apaga el voltaje de todas las ranuras de cartucho. Esto permite poder quitar o insertar cartuchos sin que se dañe el ordenador o los propios cartuchos.</p>
<p>function <strong>VCCOn</strong> ()</p>
<p>Enciende el voltaje de todas las ranuras de cartucho. Esto permite poder hacer uso de los cartuchos.</p>
<p>function <strong>IsSlotEnabled</strong> (slot) : bool</p>
<p>Permite saber si la ranura de cartucho está visible por el Z80 en alguna de sus páginas de 16Kb. El parámetro &lt;slot&gt; es un entero que podrá valer 0, 1, 2 o 3.</p>
<p>function <strong>EnableSlot</strong> (page, slot)</p>
<p>Hace visible la ranura de cartucho en una página de 16Kb de las 64Kb visibles por el Z80. En &lt;page&gt; se indica en qué página de 16Kb se hará visible, y podrá valer 0, 1, 2 o 3. En &lt;slot&gt; se indicará 0 en el caso de que no queramos visible ningún cartucho, o los valores 1, 2, 3, 4 si queremos hacer visible alguna de las ranuras de cartucho.</p>
<p>function <strong>IsCartridgePlugged</strong> (slot) : bool</p>
<p>Permite saber si hay un cartucho válido en alguna de las ranuras de cartucho. Para saber si hay un cartucho, la función busca si la cabecera 0x41 0x42 se encuentra al comienzo de alguna de las páginas de 16Kb visibles dentro de los 64Kb. El parámetro &lt;slot&gt; es un entero que podrá valer 0, 1, 2 o 3.</p>
<p>function <strong>Poke</strong> (addr, v)</p>
<p>Escribe en una dirección de memoria &lt;addr&gt; de 16 bits (0000-FFFF) el valor &lt;v&gt;, que será un entero entre 0 y 255, ambos incluidos. Si en dicha dirección está presente una de las ranuras de cartucho, la escritura se aplicará en el cartucho.</p>
<p>function <strong>Peek</strong> (addr) : ubyte</p>
<p>Lee de una dirección de memoria &lt;addr&gt; de 16 bits (0000-FFFF). El valor devuelto será un entero entre 0 y 255. Si en dicha dirección está presente una de las ranuras del cartucho, la lectura se hará desde el cartucho.</p>
<p>function <strong>Inp</strong> (port) : ubyte</p>
<p>Lee de un puerto &lt;port&gt;, que en los MSX es un entero de 8 bits (0-255) pero en otros sistemas puede ser de 16bits (0-65535). Los puertos atacan todas las ranuras de los cartuchos a la vez: si varios cartuchos responden al puerto, ocurrirá un conflicto de datos en el bus.</p>
<p>function <strong>Outp</strong> (port, value)</p>
<p>Escribe en un puerto &lt;port&gt;, que en los MSX es un entero de 8 bits (0-255) pero en otros sistemas puede ser de 16bits (0-65535). El dato a escribir es &lt;value&gt; y será un entero de 8 bits (0-255). Este dato se escribirá en todas las ranuras de cartucho. Si un cartucho no usa ese puerto, ignorará la escritura.</p>
<p>function <strong>ReadMemory</strong> (slot, addr, buffer, off, len) : uint</p>
<p>Realiza una lectura de datos en rango. Sería como hacer varias operaciones Peek seguidas. También permite especificar directamente la ranura de cartucho de la que queremos leer mediante el parámetro &lt;slot&gt;. Esta función ignora la configuración interna de slots que sí utilizan las funciones Peek/Poke. Para leer los datos, será necesaria una dirección de 16 bits, un buffer donde almacenar los datos leídos, un offset &lt;off&gt; para indicar en qué parte del buffer queremos escribir y el número de bytes a leer &lt;len&gt;.</p>
<p>function <strong>WriteMemory</strong> (slot, addr, buffer, off, len) : uint</p>
<p>Realiza una escritura de datos en rango. Sería como hacer varias operaciones Poke seguidas. También permite especificar directamente la ranura de cartucho de la que queremos escribir mediante el parámetro &lt;slot&gt;. Esta función ignora la configuración interna de slots que sí utilizan las funciones Peek/Poke. Para escribir los datos, será necesaria una dirección de 16 bits, un buffer conteniendo los datos a escribir, un offset &lt;off&gt; para indicar desde qué parte del buffer obtener los datos y el número de bytes a escribir &lt;len&gt;.</p>
<p>function <strong>SetCartridgeSlot</strong> (cart, pslot, sslot)</p>
<p>Configura el slot primario &lt;pslot&gt; y slot secundario &lt;sslot&gt; en los que queremos mapear o encontrar nuestra ranura de cartucho. En este caso &lt;cart&gt; podrá valer 0, 1, 2 o 3. El slot primario y secundario son valores enteros entre 0 y 3.</p>
<p>function <strong>DumpROM</strong> (slot, detectMappers = true) : list</p>
<p>Vuelca el contenido de un cartucho en un slot (del 0 a 3). La función retorna una lista con tres valores. El primero es el tipo de mapper detectado (ASCII8, ASCII16, KONAMI4, etc.): este valor es una cadena de caracteres que representa el tipo de mapper. El siguiente valor sería un objeto buffer con el contenido de la ROM. Finalmente la dirección donde se ha encontrado la cabecera del cartucho (0x41, 0x42).</p>
<h4 id="puertos-de-juego">Puertos de juego</h4>
<p><img src="media/3486b0467458450f077886bfc73a235b.png" /></p>
<p>Todos los pines están configurados como de entrada salvo el 8 (STROBE/COM). También es posible configurar como de entrada o salida los pines 6 y 7, correspondientes al botón de disparo I y el botón de disparo II.</p>
<p>function <strong>ReadPort</strong> (port) : ubyte</p>
<p>Lee un dato del puerto de juegos &lt;port&gt;. Los puertos pueden ser el A (valor 0) o el B (valor 1). El dato leído contiene el estado de pulsación de los botones. Si el bit correspondiente vale 0, es que el botón se encuentra pulsado:</p>
<table>
<thead>
<tr class="header">
<th><strong>Bit</strong></th>
<th><strong>Botón</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>UP</td>
</tr>
<tr class="even">
<td>1</td>
<td>DOWN</td>
</tr>
<tr class="odd">
<td>2</td>
<td>LEFT</td>
</tr>
<tr class="even">
<td>3</td>
<td>RIGHT</td>
</tr>
<tr class="odd">
<td>4</td>
<td>TRIGGER I</td>
</tr>
<tr class="even">
<td>5</td>
<td>TRIGGER II</td>
</tr>
</tbody>
</table>
<p>function <strong>WritePort</strong> (port, value)</p>
<p>Escribe un dato &lt;value&gt; en el puerto de juegos &lt;port&gt;. Los puertos pueden ser el A (valor 0) o el B (valor 1). Según el valor de los bits, configuraremos como entrada o salida los pines 6/7:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Bit</strong></th>
<th><strong>Funcionalidad</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Valor para bit de salida por Puerto A / Pin 6. Poner a 1 si queremos leer.</td>
</tr>
<tr class="even">
<td>1</td>
<td>Valor para bit de salida por Puerto A / Pin 7. Poner a 1 si queremos leer.</td>
</tr>
<tr class="odd">
<td>2</td>
<td>Valor para bit de salida por Puerto B / Pin 6. Poner a 1 si queremos leer.</td>
</tr>
<tr class="even">
<td>3</td>
<td>Valor para bit de salida por Puerto B / Pin 7. Poner a 1 si queremos leer.</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Valor para bit de salida por Puerto A / pin 8 (STROBE/COM).</td>
</tr>
<tr class="even">
<td>5</td>
<td>Valor para bit de salida por Puerto B / pin 8 (STROBE/COM).</td>
</tr>
</tbody>
</table>
<h4 id="mediaimage24.png"><a href="./media/image24.png">./media/image24.png</a></h4>
<p>Leds</p>
<p>Los 8 leds de usuario corresponden con los de color verde. El rojo es el de encendido y los 3 amarillos corresponden al control de voltaje (5V, +12V, -12V) en todas las ranuras de cartucho.</p>
<p>function <strong>SetLed</strong> (led, v)</p>
<p>Enciende o apaga el estado de un led. Usando &lt;v&gt; con valor verdadero, el led se encenderá, y con valor falso se apagará. El parámetro &lt;led&gt; es entero que va del 0 al 7. Existen 8 leds de usuario disponibles.</p>
<p>function <strong>GetLed</strong> (led) : bool</p>
<p>Consulta el estado de un led. Devolverá verdadero si está encendido o falso si está apagado.</p>
<h4 id="mediaimage25.jpeg"><a href="./media/image25.jpeg">./media/image25.jpeg</a></h4>
<p>Botones</p>
<p>Existen cuatro botones en un ordenador MSXVR.</p>
<p>Todos los programas reciben las siguientes notificaciones una vez se detecta la pulsación durante unas milésimas de segundo y posteriormente se libera dicha pulsación:</p>
<table>
<thead>
<tr class="header">
<th>OnSystemReset</th>
<th>Cuando el sistema se reinicia (reset).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OnSystemPause</td>
<td>Cuando el sistema se pausa.</td>
</tr>
<tr class="even">
<td>OnSystemExit</td>
<td>Cuando el sistema se va a apagar.</td>
</tr>
<tr class="odd">
<td>OnSystemVCCOff</td>
<td>Cuando el sistema apaga el voltaje en las ranuras.</td>
</tr>
<tr class="even">
<td>OnSystemVCCOn</td>
<td>Cuando el sistema enciende el voltaje en las ranuras.</td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<pre><code>function OnSystemExit()
{
    GetEngine().StopPowerOff();

    if (GetEngine().AlertDialogModal(&quot;Warning&quot;, &quot;Are you sure do you want to PowerOFF?&quot;, View.AD_YESNO) == 1)
    {
        GetEngine().PowerOff();
    }
    else
    {
        GetEngine().CancelPowerOff();
    }
}</code></pre>
<h4 id="puerto-io-extendido-db-37">Puerto I/O extendido DB-37</h4>
<p><img src="media/291b135d51c30e5be1062bfa89b6b27a.gif" /></p>
<p>function <strong>WriteIOExt</strong> (value)</p>
<p>Escribe en el puerto I/O extendido el valor de 32 bits &lt;value&gt;.</p>
<p>function <strong>ReadIOExt</strong> () : uint</p>
<p>Lee del puerto I/O extendido un valor de 32 bits.</p>
<p>function <strong>SetIOExtDir</strong> (flags)</p>
<p>Permite especificar cuál de los 32 pins es de salida o de entrada. El parámetro &lt;flags&gt; es un valor de 32 bits. Cada bit representa a un pin. Si el bit es 0, indica que dicho pin se configura de salida, mientras que si el bit es 1, indica que se configura de entrada.</p>
<p>function <strong>SetIOExtPu</strong> (flags)</p>
<p>En el caso de que los bits sean de entrada, es posible determinar si queremos usar el método “pull ups” para consultar el estado de los pines. Esto es, cuando el valor del pin sea 0 leeremos un 0, si el valor del pin es 1 o indeterminado, leeremos un 1.</p>
<h4 id="i2c">I2C</h4>
<p>function <strong>OpenI2C</strong> (address, hz = 100000) : pointer</p>
<p>Devuelve un controlador de dispositivo I2C si se ha podido conectar a la dirección (SLAVE ADDRESS) del dispositivo. En caso de error, devolverá NUL.</p>
<p>Los métodos disponibles por parte del controlador son:</p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>WriteByte</strong> (byte)</th>
<th>Escribe un byte al dispositivo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>ReadByte</strong> ()</td>
<td>Lee un byte del dispositivo.</td>
</tr>
<tr class="even">
<td><strong>WriteReg</strong> (reg, byte)</td>
<td>Escribe en un registro del dispositivo.</td>
</tr>
<tr class="odd">
<td><strong>ReadReg</strong> (reg)</td>
<td>Lee de un registro del dispositivo.</td>
</tr>
<tr class="even">
<td><strong>Write</strong> (buffer, off = 0, len = -1)</td>
<td>Escribe un buffer de datos al dispositivo.</td>
</tr>
<tr class="odd">
<td><strong>Read</strong> (buffer, off = 0, len = -1)</td>
<td>Lee a un buffer datos desde el dispositivo.</td>
</tr>
</tbody>
</table>
<p>function <strong>CloseI2C</strong> (i2c)</p>
<p>Cierra y libera los recursos utilizados por el controlador de dispositivo I2C.</p>
<h4 id="usb">USB</h4>
<p>function <strong>GetUSBDevices</strong> () : list</p>
<p>Obtiene una lista de dispositivos USB a los que podemos acceder.</p>
<p>function <strong>OpenUSBDevice</strong> (device) : pointer</p>
<p>Obtiene el controlador a un dispositivo USB. Mediante el uso del controlador, tenemos accesibles los siguientes métodos:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Reset</strong> ()</th>
<th>Reinicia el dispositivo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GetDescriptor</strong> ()</td>
<td>Obtiene una lista con IDs de descripción.</td>
</tr>
<tr class="even">
<td><strong>GetStringDescriptor</strong> (id)</td>
<td>Obtiene el texto asociado a un ID de descripción.</td>
</tr>
<tr class="odd">
<td><strong>IsKernelDriver</strong> (iface)</td>
<td>Verifica si el interfaz tiene el driver de núcleo activo. En tal caso, no se podrá reclamar el interfaz. &lt;iface&gt; es un número entero.</td>
</tr>
<tr class="even">
<td><strong>AttachKernelDriver</strong> (iface)</td>
<td>Asociar núcleo de driver al interfaz del dispositivo.</td>
</tr>
<tr class="odd">
<td><strong>DetachKernelDriver</strong> (iface)</td>
<td>Liberar núcleo de driver al interfaz del dispositivo.</td>
</tr>
<tr class="even">
<td><strong>ClaimInterface</strong> (iface)</td>
<td>Reclama el interfaz para acceder a sus funciones I/O.</td>
</tr>
<tr class="odd">
<td><strong>ReleaseInterface</strong> (iface)</td>
<td>Libera el interfaz de uso.</td>
</tr>
<tr class="even">
<td><strong>BulkTransfer</strong> (endpoint, buffer, timeout)</td>
<td>Realiza una operación de Bulk Transfer sobre un &lt;endpoint&gt;.</td>
</tr>
<tr class="odd">
<td><strong>InterruptTransfer</strong> (endpoint, buffer, timeout)</td>
<td>Realiza una operación de Interrupt Transfer sobre un &lt;endpoint&gt;.</td>
</tr>
<tr class="even">
<td>ControlTransfer (bmReqType, bmReq, wValue, wIndex, buffer, timeout)</td>
<td>Realiza una operación de Control Transfer.</td>
</tr>
</tbody>
</table>
<p>function <strong>CloseUSBDevice</strong> (usb)</p>
<p>Cierra y libera los recursos utilizados por el controlador de dispositivo USB.</p>
<h4 id="eeprom">EEPROM</h4>
<p>function <strong>WriteEEPROM</strong> (addr, buffer, off, len)</p>
<p>Escribe datos a la EEPROM. <em>Esta función está bloqueda y solo está disponible en un entorno de tipo Administrador/Fabricante.</em></p>
<p>function <strong>ReadEEPROM</strong> (addr, buffer, off, len)</p>
<p>Lee datos de la EEPROM. Con &lt;addr&gt; se indica la dirección partir de la cual leer datos. El rango irá de 0 a 255. También podemos especificar el destino dentro de un buffer y la cantidad de datos a leer &lt;len&gt;.</p>
<h4 id="amplificador-audio-de-slots">Amplificador audio de slots</h4>
<p>function <strong>SetSlotAudioVolume</strong> (v)</p>
<p>Permite establecer la potencia de salida en el amplificador que filtra el audio que sale de los cartuchos. El valor de &lt;v&gt; podrá ser un entero entre 0 y 255.</p>
<p>function <strong>GetSlotAudioVolume</strong> () : int</p>
<p>Obtiene el valor asociado al volumen de audio para el amplificador que filtra el audio que sale de los cartuchos. Este valor es un entero en el rango de 0 a 255.</p>
<h4 id="micrófono">Micrófono</h4>
<p>function <strong>AudioCaptureStart</strong> (ms = 5000, wavPath = "")</p>
<p>Inicializa la captura de audio en tiempo real. Podemos indicar el tiempo de captura que queremos realizar mediante el parámetro &lt;ms&gt;, medido en milisegundos. Si este valor de tiempo es 0, indicaremos que estaremos capturando audio de forma indefinida hasta usar la función <em>AudioCaptureStop</em>. También podemos indicar si queremos ir guardando los datos de la captura en un archivo WAV. Podremos consultar los datos capturados en tiempo real usando la función <em>AudioCaptureRead</em>.</p>
<p>function <strong>AudioCaptureStop</strong> ()</p>
<p>Detenemos la captura de audio.</p>
<p>function <strong>AudioCaptureRead</strong> (buffer, off, size)</p>
<p>Obtenemos datos de la captura en tiempo real. Estos datos los almacenaremos en un buffer e indicaremos el número de datos a almacenar en &lt;size&gt;.</p>
<h4 id="control-remoto">Control Remoto</h4>
<p>function <strong>SetRemote</strong> (_on)</p>
<p>Activa/Desactiva el control remoto o también el puerto REM de casete.</p>
<p>function <strong>GetRemote</strong> () : bool</p>
<p>Obtiene el estado del control remoto. Si el valor retornado es verdadero, es que el REM está encendido, y en caso de que sea falso es que está apagado.</p>
<h4 id="drivers">Drivers</h4>
<p>function <strong>AddDriver</strong> (_name) : pointer</p>
<p>Añade un controlador para gestionar algún tipo de dispositivo que use el hardware de la máquina. Los drivers disponibles son:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>MSXMOUSEA</th>
<th>Gestión del ratón usando uno MSX en el puerto A.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MSXMOUSEB</td>
<td>Gestión del ratón usando uno MSX en el puerto B.</td>
</tr>
<tr class="even">
<td>MSXJOYSTICKA</td>
<td>Gestión del ratón usando un joystick MSX en el puerto A.</td>
</tr>
<tr class="odd">
<td>MSXJOYSTICKB</td>
<td>Gestión del ratón usando un joystick MSX en el puerto B.</td>
</tr>
<tr class="even">
<td>MSXPHILIPSKEYBOARD</td>
<td>Gestión del teclado usando un teclado Philips NMS8250/NMS8280 en el puerto DB37.</td>
</tr>
</tbody>
</table>
<p>function <strong>RemoveDriver</strong> (_name)</p>
<p>Elimina el controlador de dispositivo agregado previamente con la función <em>AddDriver</em>.</p>
<p>function <strong>FindDriver</strong> (_name) : pointer</p>
<p>Busca entre los controladores añadidos uno con el mismo nombre que el indicado en el parámetro &lt;name&gt;.</p>
<p>function <strong>SetDriverProperty</strong> (_driver, _name, _value)</p>
<p>Dado un controlador permite establecer en su propiedad &lt;name&gt; un valor &lt;value&gt;.</p>
<p>function <strong>GetDriverProperty</strong> (_driver, _name) : value</p>
<p>Dado un controlador permite obtener el valor de su propiedad &lt;name&gt;.</p>
<h2 id="máquinas-virtuales">Máquinas Virtuales</h2>
<p>Gestión de las diferentes máquinas virtuales del sistema.</p>
<p>function <strong>CreateVirtualMachine</strong> (model, parent = null) : pointer</p>
<p>Dado un nombre de modelo &lt;model&gt;, crea un controlador de máquina virtual. Este controlador puede estar vinculado como hijo a un programa &lt;parent&gt;.</p>
<p>function <strong>DestroyVirtualMachine</strong> (machine)</p>
<p>Dado un controlador de máquina virtual, libera todos los recursos utilizados.</p>
<p>function <strong>GetAvailableVirtualMachineSystems</strong> () : list</p>
<p>Devuelve una lista de sistemas disponibles. Los elementos de la lista son de tipo cadena de texto. Cada sistema dispone de uno o varios modelos.</p>
<dl>
<dt>function <strong>GetAvailableVirtualMachineConfigurations</strong> (system = "“, model =”")</dt>
<dd>list
</dd>
</dl>
<p>Dado el nombre de un sistema &lt;system&gt; y/o el nombre de un modelo &lt;model&gt;, devuelve una lista con todas las configuraciones de máquina virtual que coincidan con ese sistema y modelo. Si no indicamos nada (cadena vacía) en el parámetro &lt;model&gt;, buscará todos los modelos pertenecientes al &lt;system&gt;. Si en &lt;system&gt; tampoco especificamos nada, devolverá todos los modelos disponibles de todos los sistemas.</p>
<p>function <strong>CheckVirtualMachineConfiguration</strong> (model) : bool</p>
<p>Indica si existe configuración para ese modelo. Las configuraciones se encuentran en la carpeta <em>GetEngine().GetVirtualMachineConfigurationsFolder()</em>. Estas configuraciones tienen el nombre de modelo seguido por la extensión XML.</p>
<p>function <strong>CreateVirtualMachineConfiguration</strong> (model, system, desc) : pointer</p>
<p>Dado un nombre de modelo &lt;model&gt;, crea el archivo XML correspondiente y le asocia un sistema &lt;system&gt; y una descripción &lt;desc&gt;. La función devolverá la instancia de configuración de máquina virtual.</p>
<p>function <strong>DestroyVirtualMachineConfiguration</strong> (model)</p>
<p>Dado un nombre de modelo &lt;model&gt;, se elimina el archivo XML y se liberan los recursos de la configuración cargada.</p>
<p>function <strong>UnloadVirtualMachineConfiguration</strong> (mc)</p>
<p>Dada una instancia de configuración de máquina virtual &lt;mc&gt;, se libera de memoria.</p>
<p>function <strong>CloneVirtualMachineConfiguration</strong> (modelSrc, modelDst) : bool</p>
<p>Dado un nombre de modelo origen &lt;modelSrc&gt;, se clona la configuración (el archivo XML) con nombre &lt;modelDst&gt;.</p>
<p>function <strong>RenameVirtualMachineConfiguration</strong> (modelOld, modelNew) : bool</p>
<p>Dado un nombre de modelo &lt;modelOld&gt;, se renombra el archivo de configuración con el nuevo nombre &lt;modelNew&gt;.</p>
<p>function <strong>LoadVirtualMachineConfiguration</strong> (model) : pointer</p>
<p>Dado un nombre de modelo &lt;model&gt;, se carga y devuelve la instancia de configuración de máquina virtual. En caso de no existir dicha configuración de modelo, se devolverá NULL.</p>
<p>function <strong>SaveVirtualMachineConfiguration</strong> (mc, model = "")</p>
<p>Dada una instancia de configuración de máquina virtual &lt;mc&gt;, guardaremos el archivo de configuración asociado. Si queremos usar otro nombre de modelo para dicha configuración, usaremos el parámetro &lt;model&gt;.</p>
<h4 id="virtualmachine-controller">VirtualMachine Controller</h4>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>AddCPUBreakpoint</strong> (type, addr, addrCount = 1, data = 0)</th>
<th>Añade un punto de ruptura para la CPU. Se establece un tipo &lt;type&gt;, una dirección &lt;addr&gt; y otros parámetros en función del tipo.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>AddDevice</strong> (name, ports = "“, params =”")</td>
<td>Agrega un dispositivo con nombre &lt;name&gt; usando los puertos &lt;port&gt; y parámetros adicionales &lt;params&gt;.</td>
</tr>
<tr class="even">
<td><strong>AddEvent</strong> (event, ctx, function)</td>
<td>Añade un evento y le asocia un contexto.</td>
</tr>
<tr class="odd">
<td><strong>AddMapper</strong> (name, slot, sslot, page, path, size, patch)</td>
<td>Asocia un mapper a un slot/subslot/página.</td>
</tr>
<tr class="even">
<td><strong>ApplyIPSFile</strong> (ipsFile, buffer)</td>
<td>Aplica un archivo IPS sobre un buffer.</td>
</tr>
<tr class="odd">
<td><strong>CPUCall</strong> (addr)</td>
<td>Aplica una llamada a una rutina en la dirección de memoria &lt;addr&gt;.</td>
</tr>
<tr class="even">
<td><strong>EnumDevices</strong> ()</td>
<td>Retorna una lista con los dispositivos disponibles.</td>
</tr>
<tr class="odd">
<td><strong>FindDevice</strong> (name)</td>
<td>Busca un dispositivo con nombre &lt;name&gt;.</td>
</tr>
<tr class="even">
<td><strong>FindMapper</strong> (name, slot, sslot, page)</td>
<td>Busca un mapper con nombre &lt;name&gt; y/o en un slot/subslot/página.</td>
</tr>
<tr class="odd">
<td><strong>GetCPUDASM</strong> (pc, symbols = null, buffer = null)</td>
<td>Obtiene una lista de dos componentes: por un lado una cadena de texto con el opcode y por otro el tamaño en bytes del opcode.</td>
</tr>
<tr class="even">
<td><strong>GetCPUDebug</strong> ()</td>
<td>Indica si la CPU está en modo depuración.</td>
</tr>
<tr class="odd">
<td><strong>GetCPUReg</strong> (reg)</td>
<td>Devuelve el valor de un registro.</td>
</tr>
<tr class="even">
<td><strong>GetDeviceProp</strong> (dev, prop)</td>
<td>Devuelve el valor de una propiedad de un dispositivo.</td>
</tr>
<tr class="odd">
<td><strong>GetDeviceReg</strong> (dev, reg)</td>
<td>Devuelve el valor de un registro de un dispositivo.</td>
</tr>
<tr class="even">
<td><strong>GetEmulationSpeed</strong> ()</td>
<td>Obtiene el factor de velocidad de emulación.</td>
</tr>
<tr class="odd">
<td><strong>GetMapperInfo</strong> (mapper)</td>
<td>Devuelve una lista con información sobre el mapper (nombre, slot, subslot, página y cantidad de bytes asociados).</td>
</tr>
<tr class="even">
<td><strong>GetProperty</strong> (name)</td>
<td>Devuelve el valor de una propiedad de la máquina.</td>
</tr>
<tr class="odd">
<td><strong>GetTapeCounter</strong> ()</td>
<td>Retorna el valor del contador del casete.</td>
</tr>
<tr class="even">
<td><strong>GetVideoAdjust</strong> ()</td>
<td>Indica el ajuste de vídeo.</td>
</tr>
<tr class="odd">
<td><strong>GetVideoAlign</strong> ()</td>
<td>Indica la alineación de vídeo.</td>
</tr>
<tr class="even">
<td><strong>GetVideoDevice</strong> (dev)</td>
<td>Obtiene el dispositivo de vídeo con índice &lt;dev&gt;.</td>
</tr>
<tr class="odd">
<td><strong>GetVideoDeviceNumber</strong> ()</td>
<td>Obtiene el número de dispositivos de vídeo existentes.</td>
</tr>
<tr class="even">
<td><strong>GetVideoFrameRateMode</strong> ()</td>
<td>Obtiene el modo de tasa de fotogramas.</td>
</tr>
<tr class="odd">
<td><strong>GetVideoHeight</strong> (ix = -1)</td>
<td>Obtiene la resolución vertical del dispositivo de vídeo con índice &lt;ix&gt;. En caso de ser -1, devuelve el que esté en curso.</td>
</tr>
<tr class="even">
<td><strong>GetVideoImageTex</strong> (ix = -1)</td>
<td>Obtiene la textura del dispositivo de vídeo con índice &lt;ix&gt;. En caso de ser -1, devuelve la del dispositivo de vídeo en curso.</td>
</tr>
<tr class="odd">
<td><strong>GetVideoShowAllDevices</strong> ()</td>
<td>Indica si se están mostrando todos los dispositivos de vídeo a la vez.</td>
</tr>
<tr class="even">
<td><strong>GetVideoWidth</strong> (ix = -1)</td>
<td>Obtiene la resolución horizontal del dispositivo de vídeo con índice &lt;ix&gt;. En caso de ser -1, devuelve el que esté en curso.</td>
</tr>
<tr class="odd">
<td><strong>Inp</strong> (port)</td>
<td>Realiza una lectura del puerto E/S.</td>
</tr>
<tr class="even">
<td><strong>InsertCartridge</strong> (slot, file, mapper, ipsFile = "")</td>
<td>Simula la inserción de un cartucho en una ranura &lt;slot&gt; usando un archivo &lt;file&gt;, un mapper y un parche IPS opcional.</td>
</tr>
<tr class="odd">
<td><strong>InsertDisk</strong> (id, file, rdOnly = false)</td>
<td>Simula la inserción de una imagen de disco en una de las unidades &lt;id&gt;. La imagen de disco tendrá una ruta &lt;file&gt; y podrá usarse como solo lectura de forma opcional.</td>
</tr>
<tr class="even">
<td><strong>IsPlayingTape</strong> ()</td>
<td>Indica si existe una cinta de casete en reproducción.</td>
</tr>
<tr class="odd">
<td><strong>LoadState</strong> (path)</td>
<td>Carga el estado de una máquina a partir de una ruta.</td>
</tr>
<tr class="even">
<td><strong>LoadTape</strong> (file, rdOnly = false)</td>
<td>Simula el uso de una cinta de casete con ruta en &lt;file&gt;. Por defecto se podrá escribir en ella.</td>
</tr>
<tr class="odd">
<td><strong>NextVideoDevice</strong> ()</td>
<td>Permite pasar del actual dispositivo de vídeo al siguiente.</td>
</tr>
<tr class="even">
<td><strong>Outp</strong> (port, v)</td>
<td>Realiza una escritura al puerto E/S.</td>
</tr>
<tr class="odd">
<td><strong>PatchMapper</strong> (mapper, patch)</td>
<td>Dado un objeto mapper, aplica un parche en formato texto.</td>
</tr>
<tr class="even">
<td><strong>Peek</strong> (addr)</td>
<td>Devuelve el byte leído en la dirección de memoria visible por la CPU.</td>
</tr>
<tr class="odd">
<td><strong>PlayTape</strong> ()</td>
<td>Inicia la reproducción de una cinta de casete.</td>
</tr>
<tr class="even">
<td><strong>PlugPortDevice</strong> (port, name)</td>
<td>Simula la conexión de un dispositivo en uno de los puertos de juegos.</td>
</tr>
<tr class="odd">
<td><strong>Poke</strong> (addr, v)</td>
<td>Escribe un valor en la memoria visible por la CPU.</td>
</tr>
<tr class="even">
<td><strong>PressKey</strong> (key)</td>
<td>Simula la pulsación de una tecla.</td>
</tr>
<tr class="odd">
<td><strong>PrevVideoDevice</strong> ()</td>
<td>Pasa del actual dispositivo de vídeo al anterior.</td>
</tr>
<tr class="even">
<td><strong>ReadFromPortDevice</strong> (port)</td>
<td>Lee un valor del puerto de juegos.</td>
</tr>
<tr class="odd">
<td><strong>ReleaseKey</strong> (key)</td>
<td>Simula la liberación de pulsación de una tecla.</td>
</tr>
<tr class="even">
<td><strong>RemoveCartridge</strong> (slot)</td>
<td>Elimina un cartucho insertado en una ranura.</td>
</tr>
<tr class="odd">
<td><strong>RemoveCPUBreakpoint</strong> (type, addr)</td>
<td>Elimina un punto de ruptura agregado.</td>
</tr>
<tr class="even">
<td><strong>RemoveDevice</strong> (dev)</td>
<td>Dado un objeto dispositivo, lo elimina de la máquina.</td>
</tr>
<tr class="odd">
<td><strong>RemoveDisk</strong> (id)</td>
<td>Simula la extracción de un disco.</td>
</tr>
<tr class="even">
<td><strong>RemoveMapper</strong> (mapper)</td>
<td>Dado un objeto mapper, lo elimina.</td>
</tr>
<tr class="odd">
<td><strong>RewindTape</strong> ()</td>
<td>Rebobina una cinta de casete.</td>
</tr>
<tr class="even">
<td><strong>SaveState</strong> (path)</td>
<td>Guarda el estado de la máquina.</td>
</tr>
<tr class="odd">
<td><strong>SetCPUBreakpointCallback</strong> (ctx, function)</td>
<td>Permite establecer a qué función script llamar cuando se cumple un punto de ruptura.</td>
</tr>
<tr class="even">
<td><strong>SetCPUDebug</strong> (v)</td>
<td>Establece el modo de depuración de la CPU.</td>
</tr>
<tr class="odd">
<td><strong>SetCPUReg</strong> (reg, v)</td>
<td>Da valor a un registro.</td>
</tr>
<tr class="even">
<td><strong>SetDeviceProp</strong> (dev, prop, value)</td>
<td>Asigna un valor a una propiedad de un dispositivo.</td>
</tr>
<tr class="odd">
<td><strong>SetDeviceReg</strong> (dev, reg, value)</td>
<td>Asigna un valor a un registro de un dispositivo.</td>
</tr>
<tr class="even">
<td><strong>SetEmulationSpeed</strong> (speed)</td>
<td>Establece el factor de velocidad de emulación.</td>
</tr>
<tr class="odd">
<td><strong>SetLed</strong> (led, v)</td>
<td>Enciende o apaga un led.</td>
</tr>
<tr class="even">
<td><strong>SetProperty</strong> (name, v)</td>
<td>Establece una propiedad de máquina.</td>
</tr>
<tr class="odd">
<td><strong>SetRenderSettings</strong> (w, h, ox = 0, oy = 0, xf = 1, yf = 1)</td>
<td>Indica los ajustes de renderización.</td>
</tr>
<tr class="even">
<td><strong>SetROMSFolder</strong> (path)</td>
<td>Establece la carpeta por defecto para las BIOS del sistema.</td>
</tr>
<tr class="odd">
<td><strong>SetSaveStatesFolder</strong> (path)</td>
<td>Establece la carpeta por defecto donde guardar y leer los estados de máquina.</td>
</tr>
<tr class="even">
<td><strong>SetSRAMFolder</strong> (path)</td>
<td>Establece la carpeta donde se encuentran las memorias estáticas.</td>
</tr>
<tr class="odd">
<td><strong>SetVideoAdjust</strong> (adjust)</td>
<td>Indica el nuevo ajuste de vídeo.</td>
</tr>
<tr class="even">
<td><strong>SetVideoAlign</strong> (align)</td>
<td>Indica la nueva alineación de vídeo.</td>
</tr>
<tr class="odd">
<td><strong>SetVideoDevice</strong> (dev)</td>
<td>Establece el dispositivo de vídeo con índice &lt;dev&gt;.</td>
</tr>
<tr class="even">
<td><strong>SetVideoFrameRateMode</strong> (mode)</td>
<td>Indica la tasa de fotogramas a utilizar.</td>
</tr>
<tr class="odd">
<td><strong>SetVideoShowAllDevices</strong> (show)</td>
<td>Establece si queremos o no mostrar todos los dispositivos de vídeo a la vez.</td>
</tr>
<tr class="even">
<td><strong>StopTape</strong> ()</td>
<td>Detiene la reproducción del casete.</td>
</tr>
<tr class="odd">
<td><strong>UnloadTape</strong> ()</td>
<td>Quita el casete del reproductor.</td>
</tr>
<tr class="even">
<td><strong>UnPlugPortDevice</strong> (port)</td>
<td>Quita el dispositivo del puerto de juegos.</td>
</tr>
<tr class="odd">
<td><strong>WriteToPortDevice</strong> (port, value)</td>
<td>Escribe un valor al puerto de juegos.</td>
</tr>
<tr class="even">
<td><strong>SetCPUNativeCallback</strong> (ctx, function)</td>
<td>Establece la función script a la que llamar cuando se da una instrucción TRAP 0x0003</td>
</tr>
</tbody>
</table>
<p><strong>Tipos de puntos de ruptura (Breakpoints)</strong></p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>0</th>
<th>PC_EQUAL. Cuando el registro PC sea igual a una dirección.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>MEM_BYTE_EQUAL. Cuando el valor del contenido de una dirección de memoria sea igual a un byte.</td>
</tr>
<tr class="even">
<td>2</td>
<td>MEM_BYTE_CHANGES. Cuando un rango de valores de 8 bits a partir de una dirección cambie.</td>
</tr>
<tr class="odd">
<td>3</td>
<td>MEM_WORD_EQUAL. Cuando el valor del contenido de una dirección de memoria sea igual a un número de 2 bytes.</td>
</tr>
<tr class="even">
<td>4</td>
<td>MEM_WORD_CHANGES. Cuando un rango de valores de 16 bits a partir de una dirección cambie.</td>
</tr>
<tr class="odd">
<td>5</td>
<td>PORT_WRITE. Cuando se produzca una escritura en un puerto.</td>
</tr>
<tr class="even">
<td>6</td>
<td>PORT_READ. Cuando se produzca una lectura en un puerto.</td>
</tr>
</tbody>
</table>
<p><strong>Registros CPU Z80</strong></p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>A</th>
<th>24</th>
<th>A1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>F</td>
<td>25</td>
<td>F1</td>
</tr>
<tr class="even">
<td>2</td>
<td>AF</td>
<td>26</td>
<td>AF1</td>
</tr>
<tr class="odd">
<td>3</td>
<td>B</td>
<td>27</td>
<td>B1</td>
</tr>
<tr class="even">
<td>4</td>
<td>C</td>
<td>28</td>
<td>C1</td>
</tr>
<tr class="odd">
<td>5</td>
<td>BC</td>
<td>29</td>
<td>BC1</td>
</tr>
<tr class="even">
<td>6</td>
<td>D</td>
<td>30</td>
<td>D1</td>
</tr>
<tr class="odd">
<td>7</td>
<td>E</td>
<td>31</td>
<td>E1</td>
</tr>
<tr class="even">
<td>8</td>
<td>DE</td>
<td>32</td>
<td>DE1</td>
</tr>
<tr class="odd">
<td>9</td>
<td>H</td>
<td>33</td>
<td>H1</td>
</tr>
<tr class="even">
<td>10</td>
<td>L</td>
<td>34</td>
<td>L1</td>
</tr>
<tr class="odd">
<td>11</td>
<td>HL</td>
<td>35</td>
<td>HL1</td>
</tr>
<tr class="even">
<td>12</td>
<td>IX High</td>
<td>36</td>
<td>SH High</td>
</tr>
<tr class="odd">
<td>13</td>
<td>IX Low</td>
<td>37</td>
<td>SH Low</td>
</tr>
<tr class="even">
<td>14</td>
<td>IX</td>
<td>38</td>
<td>SH</td>
</tr>
<tr class="odd">
<td>15</td>
<td>IY High</td>
<td>39</td>
<td>I</td>
</tr>
<tr class="even">
<td>16</td>
<td>IY Low</td>
<td>40</td>
<td>R</td>
</tr>
<tr class="odd">
<td>17</td>
<td>IX</td>
<td>41</td>
<td>R2</td>
</tr>
<tr class="even">
<td>18</td>
<td>PC High</td>
<td>42</td>
<td>IFF1</td>
</tr>
<tr class="odd">
<td>19</td>
<td>PC Low</td>
<td>43</td>
<td>IFF2</td>
</tr>
<tr class="even">
<td>20</td>
<td>PC</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>21</td>
<td>SP High</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>22</td>
<td>SP Low</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>23</td>
<td>SP</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Registros CPU MOS</strong></p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>A</th>
<th>3</th>
<th>SP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>X</td>
<td>4</td>
<td>PC</td>
</tr>
<tr class="even">
<td>2</td>
<td>Y</td>
<td>5</td>
<td>FLAGS</td>
</tr>
</tbody>
</table>
<h2 id="imágenes">Imágenes</h2>
<p>Carga y manipulación de texturas (bitmaps).</p>
<p>function <strong>LoadTexture</strong> (path) : pointer</p>
<p>Carga una textura que se encuentra en la ruta de archivo &lt;path&gt;. Para manipular este tipo de objetos se utilizan las funciones API Nativas Texture.</p>
<p>function <strong>DeleteTexture</strong> (tex)</p>
<p>Libera los recursos utilizados por una textura.</p>
<p>function <strong>LoadImage</strong> (path) : pointer</p>
<p>Carga una textura que se encuentra en una ruta de archivo &lt;path&gt; y la asocia a un controlador de imagen. Los métodos de un controlador de imagen son:</p>
<table>
<thead>
<tr class="header">
<th>GetTexture ()</th>
<th>Obtiene la textura asociada.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GetWidth ()</td>
<td>Devuelve un entero con el ancho de la imagen.</td>
</tr>
<tr class="even">
<td>GetHeight ()</td>
<td>Devuelve un entero con el alto de la imagen.</td>
</tr>
</tbody>
</table>
<p>function <strong>DeleteImage</strong> (img)</p>
<p>Libera los recursos utilizados por el controlador de imagen.</p>
<h2 id="localización-idiomas">Localización / Idiomas</h2>
<p>function <strong>SetLocaleLanguage</strong> (iso)</p>
<p>Establece el lenguaje a utilizar para los textos presentados por las aplicaciones y el sistema. El código de lenguaje &lt;iso&gt; debe ser un código de dos dígitos basado en la ISO-3166. Algunos ejemplos:</p>
<table>
<thead>
<tr class="header">
<th>GB</th>
<th>UK - English</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ES</td>
<td>Español</td>
</tr>
<tr class="even">
<td>IT</td>
<td>Italiano</td>
</tr>
<tr class="odd">
<td>FR</td>
<td>Francés</td>
</tr>
</tbody>
</table>
<p>function <strong>GetLocaleLanguage</strong> () : string</p>
<p>Obtiene el código ISO-3166 configurado como idioma a utilizar.</p>
<p>function <strong>SetKeyboardLayout</strong> (iso)</p>
<p>Especifica la distribución de teclado a utilizar en el sistema. Cada tecla de nuestro teclado está mapeada a un tipo de código, y podemos tener diferentes mapeados en función de la configuración elegida. En este caso, el parámetro &lt;iso&gt; consiste en un código de dos cifras basado en la normativa ISO-3166.</p>
<p>function <strong>GetKeyboardLayout</strong> () : string</p>
<p>Obtiene la distribución de teclado actual.</p>
<h2 id="logger">Logger</h2>
<p>El sistema y las aplicaciones pueden usar el Logger para registrar mensajes que ayuden a los usuarios a detectar errores, posibles problemas o eventos de cualquier tipo.</p>
<p>Existen estas categorías de mensajes:</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>SIN CATEGORÍA</th>
<th>Son mensajes de texto sin ningún formato y sin ninguna categoría. Estos mensajes siempre se registran.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VERBOSE</td>
<td>Estos mensajes van asociados a un nivel, lo que nos permite filtrar qué mensajes van a ser registrados. Este mensaje registra también la fecha/hora.</td>
</tr>
<tr class="even">
<td>WARNING</td>
<td>Mensajes asociados a errores leves. Registran la fecha/hora cuando se producen.</td>
</tr>
<tr class="odd">
<td>ERROR</td>
<td>Mensajes asociados a errores graves o críticos. Registran la fecha/hora cuando se producen.</td>
</tr>
</tbody>
</table>
<p>function <strong>LogPrint</strong> (msg)</p>
<p>Vuelca un mensaje en el sistema de registro. Sería un mensaje sin categoría establecida.</p>
<p>function <strong>LogVerbose</strong> (msg, level = 0)</p>
<p>Vuelca un mensaje en el sistema de registro con categoría VERBOSE. Estos son mensajes informativos que pueden ser registrados según esté habilitada la función <em>SetVerbose</em>.</p>
<p>function <strong>LogError</strong> (msg)</p>
<p>Vuelca un mensaje en el sistema de registro con categoría ERROR.</p>
<p>function <strong>LogWarning</strong> (msg)</p>
<p>Vuelca un mensaje en el sistema de registro con categoría WARNING.</p>
<p>function <strong>SetVerboseLevel</strong> (level)</p>
<p>Establece el nivel de mensajes de categoría VERBOSE que queremos registrar. Si &lt;level&gt; vale -1, no mostraremos ningún mensaje. Si &lt;level&gt; es un número mayor o igual que cero, solo se mostrarán aquellos mensajes con nivel mayor o igual a este.</p>
<p>function <strong>GetVerboseLevel</strong> () : int</p>
<p>Obtiene el nivel de los mensajes de categoría VERBOSE que está configurado actualmente.</p>
<h2 id="notificaciones">Notificaciones</h2>
<p>En el entorno gráfico se gestiona un tipo de Notificaciones que pretenden informar al usuario, de forma visual, del acontecimiento de eventos en el sistema.</p>
<p><img src="media/f6fb415f49209c3295fcec6337959b56.png" /></p>
<p>function <strong>CreateNotification</strong> (title, msg, id = -1)</p>
<p>Crea una notificación con un título &lt;title&gt;, un cuerpo de mensaje &lt;msg&gt; y un identificador de notificación &lt;id&gt;. Mediante el identificador podemos cambiar los textos de la misma notificación en pantalla, sin necesidad de que se cree una nueva.</p>
<h2 id="vídeo">Vídeo</h2>
<p>Las opciones de vídeo permiten cambiar la resolución de pantalla, entre otras opciones. También configurar el fitro FX de post-proceso de imagen para simular pantallas monocromo, scanlines, etc.</p>
<p>function <strong>SetVideoFX</strong> (name, v)</p>
<p>Establece el valor de una propiedad del filtro FX de post-proceso. Los nombres de propiedad accesibles son:</p>
<table>
<thead>
<tr class="header">
<th><strong>Nombre</strong></th>
<th><strong>Funcionalidad</strong></th>
<th><strong>Valores</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>enabled</td>
<td>Activa/Apaga el filtro.</td>
<td>Verdadero o falso</td>
</tr>
<tr class="even">
<td>R_blur</td>
<td>Desenfoque en el componente rojo.</td>
<td>-0.1 a 0.1</td>
</tr>
<tr class="odd">
<td>G_blur</td>
<td>Desenfoque en el componente verde.</td>
<td>-0.1 a 0.1</td>
</tr>
<tr class="even">
<td>B_blur</td>
<td>Desenfoque en el componente azul.</td>
<td>-0.1 a 0.1</td>
</tr>
<tr class="odd">
<td>Contrast_add</td>
<td>Suma al contraste.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Contrast_factor</td>
<td>Multiplicador al contraste.</td>
<td>0 a 1</td>
</tr>
<tr class="odd">
<td>Vignette_add</td>
<td>Suma al efecto viñeta.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Vignette_factor</td>
<td>Multiplicador al efecto viñeta.</td>
<td>0 a 10</td>
</tr>
<tr class="odd">
<td>Tint_r</td>
<td>Suma al componente rojo.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Tint_g</td>
<td>Suma al componente verde.</td>
<td>0 a 1</td>
</tr>
<tr class="odd">
<td>Tint_b</td>
<td>Suma al componente azul.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Scanline_add</td>
<td>Suma en el efecto scanline.</td>
<td>0 a 1</td>
</tr>
<tr class="odd">
<td>Scanline_factor</td>
<td>Multiplicador en el efecto scanline.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Scanline_crawl</td>
<td>Ruido efecto retrazo vertical.</td>
<td>0 a 10</td>
</tr>
<tr class="odd">
<td>Scanline_size</td>
<td>Tamaño del efecto scanline.</td>
<td>1 a 16</td>
</tr>
<tr class="even">
<td>Flickering</td>
<td>Parpadeo de la pantalla.</td>
<td>0 a 1</td>
</tr>
<tr class="odd">
<td>Smooth_min</td>
<td>Desenfoque general mínimo.</td>
<td>0 a 1</td>
</tr>
<tr class="even">
<td>Smooth_max</td>
<td>Desenfoque general máximo.</td>
<td>0 a 1</td>
</tr>
</tbody>
</table>
<p>function <strong>GetVideoFX</strong> (name, def = "") : value</p>
<p>Obtiene el valor de la propiedad del filtro FX de post-proceso con nombre &lt;name&gt;. En caso de que la propiedad no exista, devolvería el valor por defecto &lt;def&gt;.</p>
<p>function <strong>GetVideoFXParams</strong> () : list</p>
<p>Obtiene una lista donde obtener información sobre todos los parámetros accesibles para configurar el filtro FX de post-proceso activo. La lista estará compuesta por elementos con la siguiente información:</p>
<table>
<thead>
<tr class="header">
<th>NAME</th>
<th>Nombre del parámetro.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VALUE_MIN</td>
<td>Valor mínimo que se puede asignar.</td>
</tr>
<tr class="even">
<td>VALUE_MAX</td>
<td>Valor máximo que se puede asignar.</td>
</tr>
<tr class="odd">
<td>VALUE_STEP</td>
<td>Paso entre valores.</td>
</tr>
<tr class="even">
<td>VALUE_DEFAULT</td>
<td>Valor por defecto.</td>
</tr>
</tbody>
</table>
<p>function <strong>SetVideoOverscan</strong> (x, y, w = 1, h = 1)</p>
<p>Establece el ajuste de posición de origen (x, y) de pantalla. En algunos televisores CRT, es necesario ajustar esto para poder ver adecuadamente el contenido de la pantalla. Del mismo modo, también es posible ajustar el ancho y alto de lo que estamos viendo: para ello se usan (w, h) como factores de escalado.</p>
<p>function <strong>GetVideoOverscan</strong> () : list</p>
<p>Devuelve una lista donde los elementos son [x, y, w, h], siendo (x, y) la posición origen en la pantalla donde visualizamos los gráficos y (w, h) los factores de escalado a utilizar.</p>
<p>function <strong>SetVideoOutput</strong> (ch, dm = -1, da = -1)</p>
<p>Se establece la salida de vídeo por los siguientes canales:</p>
<table>
<thead>
<tr class="header">
<th><strong>&lt;ch&gt;</strong></th>
<th><strong>Salida</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONFIG_VIDEO_OUTPUT_DIGITAL</td>
<td>HDMI/DVI digital</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_OUTPUT_ANALOG</td>
<td>Vídeo compuesto</td>
</tr>
<tr class="odd">
<td><strong>&lt;dm&gt;</strong></td>
<td><strong>Modo Digital</strong></td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_DIGITAL_HDMI</td>
<td>Modo HDMI</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_DIGITAL_DVI</td>
<td>Modo DVI</td>
</tr>
<tr class="even">
<td><strong>&lt;da&gt;</strong></td>
<td><strong>Modo Analógico</strong></td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ANALOG_NTSC</td>
<td>NTSC</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ANALOG_JP_NTSC</td>
<td>Japan NTSC</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ANALOG_PAL</td>
<td>PAL</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ANALOG_BR_PAL</td>
<td>Brazilian PAL</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ANALOG_PRS_NTSC</td>
<td>NTSC Progresivo</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ANALOG_PRS_PAL</td>
<td>PAL Progresivo</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ANALOG_4_3</td>
<td>Flag formato 4:3</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ANALOG_14_9</td>
<td>Flag formato 14:9</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ANALOG_16_9</td>
<td>Flag formato 16:9</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ANALOG_MONOCHROME</td>
<td>Flag salida en monocromo</td>
</tr>
</tbody>
</table>
<p>En caso de usar &lt;dm&gt; como -1 o &lt;da&gt; como -1, se usarán los valores que ya estén configurados.</p>
<p>function <strong>GetVideoOutput</strong> () : int</p>
<p>Devuelve CONFIG_VIDEO_OUTPUT_ANALOG o CONFIG_VIDEO_OUTPUT_DIGITAL en función de la configuración establecida.</p>
<p>function <strong>GetVideoOutputEx</strong> () : list</p>
<p>Devuelve una lista con: [VIDEO OUTPUT, VIDEO DIGITAL, VIDEO ANALOG]. Ofrece información completa sobre la configuración de la salida de vídeo (véase <em>SetVideoOutput</em>).</p>
<p>function <strong>SetVideoAdjust</strong> (m)</p>
<p>Establece el modo de ajuste de vídeo usado por defecto en diferentes aplicaciones. Los valores pueden ser:</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>CONFIG_VIDEO_ASPECT_1X</th>
<th>1X - Tamaño original.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONFIG_VIDEO_ASPECT_2X</td>
<td>2X - Doble del tamaño original.</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ASPECT_3X</td>
<td>3X - Triple del tamaño original.</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ASPECT_ORIGINAL</td>
<td>El tamaño máximo que pueda verse en pantalla respetando la proporción.</td>
</tr>
<tr class="even">
<td>CONFIG_VIDEO_ASPECT_ORIGINAL_EX</td>
<td>El original, pero intentando maximizar el tamaño en horizontal.</td>
</tr>
<tr class="odd">
<td>CONFIG_VIDEO_ASPECT_EXPANDED</td>
<td>Ajusta el tamaño al máximo permitido por la pantalla. No respeta la proporción.</td>
</tr>
</tbody>
</table>
<p>function <strong>GetVideoAdjust</strong> ()</p>
<p>Obtiene el modo de ajuste de vídeo usado por defecto en diferentes aplicaciones.</p>
<p>function <strong>SetVideoFramerate</strong> (hz)</p>
<p>Establece la velocidad de refresco usada para representar los gráficos en pantalla. A la hora de dibujar un fotograma completo, se tiene en cuenta un tiempo de actualización que depende del refresco en pantalla deseado. Este refresco no depende de la capacidad del monitor o del hardware de vídeo.</p>
<p>function <strong>GetVideoFramerate</strong> ()</p>
<p>Obtiene la velocidad de refresco que está siendo usada para representar los fotogramas en pantalla.</p>
<p>function <strong>GetAvailableVideoFormats</strong> () : list</p>
<p>Devuelve una lista con información sobre los distintos modos de pantalla. Cada elemento de la lista tiene: [Resolución horizontal en pixeles, Resolución vertical en pixeles, Profundidad de color (bits por pixel), Refresco en Hz].</p>
<p>function <strong>SetVideoFormat</strong> (w, h, bpp, hz)</p>
<p>Establece un formato para la pantalla. Indicaremos la resolución horizontal en pixeles &lt;w&gt;, la resolución vertical en pixeles &lt;h&gt;, el número de bits por pixel &lt;bpp&gt; y el refresco de pantalla &lt;hz&gt;. Los formatos válidos son todos aquellos disponibles usando la función <em>GetAvailableVideoFormats</em>.</p>
<p>function <strong>GetVideoFormat</strong> () : list</p>
<p>Devuelve el formato de pantalla actual en una lista con los elementos: [Resolución horizontal en pixeles, Resolución vertical en pixeles, Bits por pixel, Refresco en Hz].</p>
<h2 id="audio">Audio</h2>
<p>En el MSXVR tenemos dos canales para la salida de audio:</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Canal 0</th>
<th>Audio del sistema, máquinas virtuales, sonido generado a través del chip de sonido PCM.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Canal 1</td>
<td>Audio del sistema proveniente de los slots de cartucho.</td>
</tr>
</tbody>
</table>
<p>function <strong>SetAudioOutput</strong> (mode)</p>
<p>Establece la salida de audio para el canal 0 según el modo &lt;mode&gt; establecido:</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>CONFIG_AUDIO_OUTPUT_DIGITAL</th>
<th>Salida por el puerto digital (HDMI)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CONFIG_AUDIO_OUTPUT_ANALOG</td>
<td>Salida por el puerto analógico (RCA/Jack 3.5mm)</td>
</tr>
</tbody>
</table>
<p>function <strong>GetAudioOutput</strong> () : int</p>
<p>Obtiene el modo establecido para la salida de audio del canal 0.</p>
<p>function <strong>SetAudioVolume</strong> (vol, id = 0)</p>
<p>Permite configurar el volumen de la salida de audio para alguno de los canales &lt;id&gt;. El parámetro &lt;vol&gt; será un valor entero entre 0 y 255.</p>
<p>function <strong>GetAudioVolume</strong> (id = 0) : int</p>
<p>Obtiene el volumen de audio de salida configurado para el canal &lt;id&gt;.</p>
<p>function <strong>SetAudioPanning</strong> (pan, id = 0)</p>
<p>Establece el ajuste de volumen entre altavoz izquierdo y derecho (balance) para las salidas de audio del canal establecido &lt;id&gt;. El valor de &lt;pan&gt; será un entero entre 0 y 255, siendo 0 para tener todo el volumen en el lado izquierdo, 255 para tener todo el volumen en el lado derecho, y 127 para centrar el volumen.</p>
<p>function <strong>GetAudioPanning</strong> (id = 0) : int</p>
<p>Devolverá el ajuste de volumen asociado al ajuste del balance izquierdo/derecho según el canal de audio indicado en &lt;id&gt;.</p>
<h2 id="temas">Temas</h2>
<p>function <strong>SetThemePreset</strong> (name)</p>
<p>Establece un perfil de tema con nombre &lt;name&gt;. Los perfiles se pueden crear/modificar a través del configurador de temas.</p>
<p>function <strong>GetThemePreset</strong> () : string</p>
<p>Obtiene el perfil de tema actualmente en uso.</p>
<p>function <strong>SetThemeColorIndices</strong> (fg, bg, br)</p>
<p>Establece los colores para tinta, fondo y borde del tema en curso. Estos colores son índices a una paleta de 16 entradas.</p>
<p>function <strong>SetThemeConsoleWidth</strong> (w)</p>
<p>Establece el ancho de columnas de texto en la consola. El máximo es 80.</p>
<p>function <strong>SetThemeConsoleMode</strong> (mode)</p>
<p>Establece el modo de consola (monocromo si &lt;mode&gt; es 1 o multicolor si &lt;mode&gt; es 0).</p>
<h2 id="encendido-y-apagado">Encendido y apagado</h2>
<p>function <strong>PowerOff</strong> ()</p>
<p>Manda una petición de apagado al ordenador.</p>
<p>function <strong>Reset</strong> (hw = false)</p>
<p>Manda una petición de reset al ordenador. Este reset puede reiniciar al completo el sistema, hardware incluido, con &lt;hw&gt; verdadero, o simplemente reiniciar el sistema software, con &lt;hw&gt; a falso.</p>
<p>function <strong>SystemPause</strong> ()</p>
<p>Manda una petición de Pausa a todas las aplicaciones del sistema.</p>
<p>function <strong>StopPowerOff</strong> ()</p>
<p>Permite detener el proceso de apagado del ordenador. Eso no significa que se cancele, simplemente que se detiene hasta decidir si proseguir o finalizarla.</p>
<p>function <strong>CancelPowerOff</strong> ()</p>
<p>Cancela por completo el proceso de apagado del ordenador. Cuando el ordenador inicia un proceso de apagado, se invoca la función <em>OnSystemExit</em> en todos los programas en marcha. Desde esta función podemos decidir cómo tratar esta notificación, pausándola con <em>StopPowerOff</em>, cancelándola con <em>CancelPowerOff,</em> o bien reanudando el proceso con <em>PowerOff</em> de nuevo.</p>
<pre><code></code></pre>
<h2 id="user">User</h2>
<p>function <strong>GetSerialNumber</strong> () : string</p>
<p>Obtiene el número de serie de la placa del ordenador.</p>
<p>function <strong>GetAlias</strong> () : string</p>
<p>Devuelve el nombre del alias asociado al ordenador.</p>
<p>function <strong>SetAlias</strong> (alias) : string</p>
<p>Establece el nombre del alias asociado al ordenador.</p>
<p>function <strong>GetUserName</strong>() : string</p>
<p>Obtiene el nombre del usuario activo.</p>
<p>function <strong>SetUser</strong> (name, pwd) : bool</p>
<p>Establece el usuario que está usando el ordenador (usuario activo). Esto permite al sistema establecer configuraciones asociadas a los distintos usuarios. Si la operación ha tenido éxito, devolverá verdadero.</p>
<h2 id="time-3">Time</h2>
<p>function <strong>GetTimeString</strong> (format) : string</p>
<p>Dado un formato de fecha y hora, devolverá la cadena de texto con la fecha y hora actual en dicho formato. Para conocer los distintos formatos véase la función de API Nativa <em>SysTime_ToString</em>.</p>
<p>function <strong>SetTime</strong> (year, month, day, hour, minute, second, ms)</p>
<p>Dada una fecha y hora en los parámetros de la función, se aplicará en el sistema, de tal manera que a partir de ese momento serán la nueva fecha y hora.</p>
<h1 id="programar-una-aplicación-vr-dos">Programar una aplicación VR-DOS</h1>
<p>Una aplicación VR-DOS es aquella que está pensada para hacer uso de la consola DOS o para mostrarse como parte integrada dentro de la propia utilidad DOS.</p>
<p>La aplicación heredará de la plantilla con nombre <em>DOS_Program</em></p>
<p>El punto de entrada que hemos de usar es el siguiente:</p>
<pre><code>virtual Start()
{
}</code></pre>
<p>Para que nuestro programa termine y regresemos al DOS de nuevo, habría que usar la instrucción End(0);</p>
<p>Para acceder a la consola del DOS, usaremos la función GetConsole()</p>
<p>Para acceder a la ventana del DOS, usaremos la función GetWindow()</p>
<p>Algunos de los métodos accesibles por la consola son:</p>
<p>function <strong>Print</strong> (text)</p>
<p>Manda texto a la consola a partir de la posición del cursor. La posición de este cursor se actualiza en función del número de caracteres y de si se ha superado el máximo horizontal.</p>
<p>function <strong>PrintLn</strong> (text)</p>
<p>Funciona del mismo modo de que la función <em>Print</em>, pero además añade un salto de línea.</p>
<p>function <strong>PrintError</strong> (code, extra = "")</p>
<p>Imprime un mensaje de error. El parámetro &lt;code&gt; podrá ser un número con el código de error o bien una cadena de texto. El mensaje se mostrará en pantalla con el estilo configurado para errores.</p>
<p>function <strong>PrintOk</strong> (text)</p>
<p>Imprime un mensaje con el estilo configurado para mostrar mensajes afirmativos.</p>
<p>function <strong>Input</strong> (prompt, ctx = null, cb = "", password = false)</p>
<p>Pone a la consola en modo de entrada de datos por parte del usuario. Indicaremos un texto de &lt;prompt&gt; que se mostrará en la consola, y a partir de este el usuario podrá introducir datos. Esta función es bloqueante, si no se especifica un contexto &lt;ctx&gt; y &lt;cb&gt; al que invocar. El parámetro &lt;password&gt; permite ocultar los datos insertados.</p>
<p>Si se llama a Input de forma bloqueante, los datos introducidos se devuelven en formato cadena de caracteres a la salida de la función. En caso de que no sea bloqueante, se retornará una cadena vacía, se continuará con el resto de las sentencias de código y hasta que el usuario no deje de introducir datos no se invocará la función en el contexto &lt;ctx&gt; y con nombre &lt;cb&gt;.</p>
<p>function <strong>Width</strong> (x)</p>
<p>Ajusta el número de caracteres que se pueden representar por línea horizontal.</p>
<p>function <strong>Locate</strong> (x, y, cursor = -1)</p>
<p>Modifica la posición del cursor desde donde se imprimen los caracteres en la consola.</p>
<p>function <strong>GetTextModeCols</strong> ()</p>
<p>Obtiene el número de caracteres que caben por línea horizontal de la consola.</p>
<p>function <strong>GetTextModeRows</strong> ()</p>
<p>Obtiene el número de caracteres que caben por línea vertical de la consola.</p>
<p>function <strong>SetTextColorMode</strong> (v)</p>
<p>Permite cambiar el modo de pantalla utilizado por la consola, en este caso a modo de texto multicolor. Cuando se trabaja en multicolor, podemos establecer un color de tinta distinto para cada carácter en la consola. Usando el comando <em>Print</em>, es posible indicar el color a utilizar mediante una serie de palabras reservadas:</p>
<pre><code>_console.PrintLn(&quot;Este [/yellow] es amarillo [/def] y este [/red] rojo [/def]&quot;);</code></pre>
<p>También podemos codificar un cambio de color con los valores desde \0 hasta \F, que son los índices de los 16 colores de la paleta disponible.</p>
<pre><code>_console.PrintLn(&quot;Este \\10 es amarillo \\0 y este \\8 rojo \\0&quot;);</code></pre>
<p>Existen las siguientes palabras reservadas:</p>
<table>
<thead>
<tr class="header">
<th>def</th>
<th>Activa el color por defecto.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>prev</td>
<td>Pone el color anterior previo a un cambio de color.</td>
</tr>
<tr class="even">
<td>black</td>
<td>Color negro.</td>
</tr>
<tr class="odd">
<td>green</td>
<td>Color verde.</td>
</tr>
<tr class="even">
<td>midgreen</td>
<td>Color verde claro.</td>
</tr>
<tr class="odd">
<td>lightgreen</td>
<td>Color verde brillante.</td>
</tr>
<tr class="even">
<td>blue</td>
<td>Color azul.</td>
</tr>
<tr class="odd">
<td>midBlue</td>
<td>Color azul claro.</td>
</tr>
<tr class="even">
<td>lightblue</td>
<td>Color azul brillante.</td>
</tr>
<tr class="odd">
<td>red</td>
<td>Color rojo.</td>
</tr>
<tr class="even">
<td>midred</td>
<td>Color rojo claro.</td>
</tr>
<tr class="odd">
<td>lightred</td>
<td>Color rojo brillante.</td>
</tr>
<tr class="even">
<td>cyan</td>
<td>Color cian.</td>
</tr>
<tr class="odd">
<td>yellow</td>
<td>Color amarillo.</td>
</tr>
<tr class="even">
<td>lightyellow</td>
<td>Color amarillo brillante.</td>
</tr>
<tr class="odd">
<td>magenta</td>
<td>Color morado.</td>
</tr>
<tr class="even">
<td>gray</td>
<td>Color gris.</td>
</tr>
<tr class="odd">
<td>white</td>
<td>Color blanco.</td>
</tr>
<tr class="even">
<td>error</td>
<td>Color asociado al error (por defecto Rojo).</td>
</tr>
<tr class="odd">
<td>bold</td>
<td>Color asociado al resaltado (por defecto Cian).</td>
</tr>
<tr class="even">
<td>title</td>
<td>Color asociado a un título (por defecto Amarillo).</td>
</tr>
<tr class="odd">
<td>hline</td>
<td>Dibuja una línea de guiones hasta el final de línea.</td>
</tr>
<tr class="even">
<td>hFill</td>
<td>Rellena con espacios hasta final de línea.</td>
</tr>
<tr class="odd">
<td>tab</td>
<td>Agrega un tabulador.</td>
</tr>
<tr class="even">
<td>dosname</td>
<td>Muestra el nombre de la versión del DOS.</td>
</tr>
<tr class="odd">
<td>osname</td>
<td>Muestra el nombre del Sistema Operativo.</td>
</tr>
</tbody>
</table>
<p>function <strong>GetTextColorMode</strong> ()</p>
<p>Obtiene el modo actual de pantalla de texto que se está utilizando. Retornará verdadero si se está utilizando el modo de texto multicolor.</p>
<p>function <strong>SetPal</strong> (index, color)</p>
<p>Asigna un color RGB &lt;color&gt; (véanse las funciones del API Nativo <em>RGB/ARGB</em>) a una entrada de la paleta de colores &lt;index&gt; usada por la consola. La paleta tiene un total de 16 entradas (colores) posibles.</p>
<p>function <strong>GetPal</strong> (index)</p>
<p>Retorna el valor RGB del color asociado a la entrada de la paleta &lt;index&gt;.</p>
<p>function <strong>SetColor</strong> (fg, bg, br)</p>
<p>Establece el color de tinta &lt;fg&gt;, fondo &lt;bg&gt; y borde &lt;br&gt; representado por la consola en pantalla. Estos colores son índices a la paleta de colores, o sea, solo son válidos los números enteros del 0 al 15.</p>
<p>function <strong>GetFGColor</strong> ()</p>
<p>Obtiene el índice de la paleta de colores que representa el color para la tinta. Véase <em>SetColor</em>.</p>
<p>function <strong>GetBGColor</strong> ()</p>
<p>Obtiene el índice de la paleta de colores que representa el color para el fondo. Véase <em>SetColor</em>.</p>
<p>function <strong>GetBRColor</strong> ()</p>
<p>Obtiene el índice de la paleta de colores que representa el color del border. Véase <em>SetColor</em>.</p>
<p>function <strong>Cls</strong> (ch = EMPTY_CHAR)</p>
<p>Permite limpiar todos los caracteres de la consola. Si no se especifica ningún carácter, lo hará con el usado por defecto. El cursor se volverá a colocar en la posición (0,0) de la pantalla.</p>
<h4 id="mdi">MDI</h4>
<p>Hasta ahora hemos visto cómo usar la consola del DOS para poder crear nuestras propias aplicaciones. Sin embargo, podemos crear una ventana MDI para ofrecer otro tipo de interfaz al usuario.</p>
<p>Para crear una aplicación que sea una ventana MDI flotante por encima de nuestra aplicación VR-DOS, usaremos GetWindow().CreateMDI.</p>
<p><em>GetWindow</em> nos permite obtener la ventana del VR-DOS sobre la que se está representando la consola también. Por tanto, podemos crear uno o varios MDI sobre esta ventana y disponer de las ventajas de VR-VIEW para crear una aplicación.</p>
<h4 id="ejemplo-17">Ejemplo</h4>
<pre><code>class MyHelloWord implements DOS_Program
{
    virtual Start()
    {
        _console = GetConsole();
        _console.PrintLn(&quot;Ejemplo de:&quot;);
        _console.PrintOk(&quot;Hello World!&quot;);
        End(0);
    }
}</code></pre>
<h1 id="programar-una-aplicación-vr-view">Programar una aplicación VR-VIEW</h1>
<p>VR-VIEW hace referencia al entorno gráfico del sistema operativo del MSXVR.</p>
<p>La plantilla sobre la que trabajar para que nuestra aplicación use estas características se denomina: <em>View_Program.</em></p>
<h2 id="el-desktop">El Desktop</h2>
<p>El entorno gráfico VR-VIEW se gestiona desde un objeto denominado DESKTOP. Este objeto se encarga de gestionar ventanas, distribuir eventos de dispositivos de entrada y básicamente todo lo relacionado con el interfaz de usuario. También es el encargado de representar todos los controles y gráficos en pantalla.</p>
<p>Podemos acceder al desktop desde una aplicación VR-VIEW usando la función GetDesktop().</p>
<p>El Desktop no permite mostrar más de una ventana de aplicación al mismo tiempo.</p>
<p><img src="media/00e715a24c7b607fb41543d2e92fb9b3.png" /></p>
<p>En la parte superior asociada a una ventana de aplicación encontraremos su título y el menú, en caso de tenerlo. Sin embargo, también encontraremos otros elementos propios del desktop, como son el botón de aplicaciones activas y la botonera de Widgets.</p>
<h2 id="ventanas-de-aplicación">Ventanas de Aplicación</h2>
<p>Una ventana hace referencia a una pantalla completa. Las ventanas están asociadas a aplicaciones. Sobre una ventana podemos asociar un menú y también podemos crear controles.</p>
<p>Cuando una ventana creada a pantalla completa gana el foco (se activa), no veremos barra de menú: la zona cliente de la ventana ocupará la pantalla al completo.</p>
<p>Funciones disponibles:</p>
<p>function <strong>SetBgColor</strong> (color)</p>
<p>Aplica un color de fondo a la ventana.</p>
<p>function <strong>CenterPos</strong> ()</p>
<p>Centra la posición de la ventana tanto en horizontal como vertical con respecto a su padre, es decir, otra ventana o el desktop.</p>
<p>function <strong>IsCursorOver</strong> () : bool</p>
<p>Indica si el cursor se encuentra posicionado sobre la ventana.</p>
<p>function <strong>Show</strong> ()</p>
<p>Muestra la ventana.</p>
<p>function <strong>Hide</strong> ()</p>
<p>Oculta la ventana.</p>
<p>function <strong>GetClientControl</strong> () : pointer</p>
<p>En una ventana a pantalla completa, la zona cliente es el rectángulo naranja, o sea, toda la pantalla salvo el menú de escritorio, título y widgets:</p>
<p><img src="media/00e715a24c7b607fb41543d2e92fb9b3.png" /></p>
<p>En una ventana MDI, sería similar pero sin incluir los bordes de la ventana ni la cabecera con el título y botones:</p>
<p><img src="media/ccf4da622b3fe9d39856becfac957507.png" /></p>
<p>El control cliente es un fotograma donde podemos crear otros controles o cambiar su aspecto, etc. A través del control podemos cambiar su aspecto.</p>
<p>function <strong>GetClientRect</strong> () : list</p>
<p>Devuelve una lista con los componentes [x, y, w, h], donde (x, y) es la posición del área cliente dentro de la ventana y (w, h) su tamaño. Este tamaño tiene en cuenta si la ventana muestra o no menú.</p>
<p>function <strong>GetClientArea</strong> () : list</p>
<p>Devuelve exactamente el tamaño del área cliente, incluyendo el espacio ocupado por el menú. La lista que se retorna tiene estos componentes [x, y, w, h].</p>
<p>function <strong>ClientToScreen</strong> (x, y) : list</p>
<p>Convierte un punto (x, y) localizado dentro de las coordenadas de la zona cliente a otro punto ubicado en pantalla. La función retornará una lista [xs, ys] con el punto en coordenadas de pantalla.</p>
<p>function <strong>ScreenToClient</strong> (x, y) : list</p>
<p>Dado un punto (x, y) en coordenadas de pantalla, la función retornará otro punto [xc, yc] con la transformación a coordenadas locales de la zona cliente.</p>
<p>function <strong>SetStyle</strong> (style)</p>
<p>Modifica los flags de estilo de la ventana. Estos pueden ser:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>STYLE_CAPTION</th>
<th>Mostrar la barra de aplicación donde está el título y los botones.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STYLE_MAXIMIZE_BOX</td>
<td>Mostrar botón de maximizar ventana.</td>
</tr>
<tr class="even">
<td>STYLE_CLOSE_BOX</td>
<td>Mostrar botón de cerrar ventana.</td>
</tr>
<tr class="odd">
<td>STYLE_RESIZE</td>
<td>Permitir que la ventana se pueda redimensionar.</td>
</tr>
<tr class="even">
<td>STYLE_SHOW_MAXIMIZE</td>
<td>Crear la ventana maximizada inicialmente.</td>
</tr>
<tr class="odd">
<td>STYLE_SIZE_BOX</td>
<td>Mostrar bordes de la ventana.</td>
</tr>
<tr class="even">
<td>STYLE_HIDE_MENU</td>
<td>Ocultar el menú cuando la ventana gana el foco.</td>
</tr>
<tr class="odd">
<td>STYLE_HIDE_MOUSE_CURSOR</td>
<td>Ocultar el cursor cuando la ventana gana el foco.</td>
</tr>
<tr class="even">
<td>STYLE_HIDE_BACKGROUND</td>
<td>Ocultar el fondo cuando la ventana gana el foco.</td>
</tr>
<tr class="odd">
<td>STYLE_SHOW_FULLSCREEN</td>
<td>Definir una ventana en modo pantalla completa.</td>
</tr>
</tbody>
</table>
<p>function <strong>GetStyle</strong> ()</p>
<p>Obtiene los flags del estilo de la ventana. Véase <em>SetSytle</em>.</p>
<p>function <strong>AddStyle</strong> (flags)</p>
<p>Agrega uno o más estilos a los que ya tiene la ventana.</p>
<p>function <strong>RemoveStyle</strong> (flags)</p>
<p>Quita uno o más estilos de los que ya tiene la ventana.</p>
<p>function <strong>HasStyle</strong>(flag) : bool</p>
<p>Consulta la existencia de algún estilo o estilos entre los que ya tiene la ventana.</p>
<p>function <strong>SetBounds</strong> (x, y, w,_h)</p>
<p>Modifica la posición (x, y) y el tamaño (w, h) de la ventana.</p>
<p>function <strong>SetTitle</strong> (title)</p>
<p>Asigna una cadena de caracteres &lt;title&gt; como título de la ventana.</p>
<p>function <strong>GetTitle</strong> () : string</p>
<p>Retorna el titulo asignado a la ventana.</p>
<p>function <strong>IsMaximized</strong> () : bool</p>
<p>Indica si la ventana se encuentra maximizada en ese momento.</p>
<p>function <strong>IsForeground</strong> () : bool</p>
<p>Indica si la ventana tiene el foco y se encuentra seleccionada.</p>
<p>function <strong>Activate</strong> ()</p>
<p>Permite activar una ventana, y por tanto el programa que tiene asociado.</p>
<p>function <strong>Maximize</strong> ()</p>
<p>Maximiza una ventana.</p>
<p>function <strong>Restore</strong> ()</p>
<p>Restaura la posición y tamaño originales de una ventana antes de haber sido maximizada.</p>
<p>function <strong>GetTopWindow</strong> () : pointer</p>
<p>Devuelve la ventana padre que la controla, si existe. En caso de ser NULL el valor retornado, es que es una ventana creada por el desktop.</p>
<p>function <strong>GetProgram</strong> () : pointer</p>
<p>Obtiene el controlador del programa asociado a la ventana.</p>
<p>function <strong>AddHotKey</strong> (list, ctx, function, level = 0) : pointer</p>
<p>Añade un atajo de teclado asociado a la ventana. La combinación de teclas que forma el atajo se define en el parámetro &lt;list&gt;. Si la combinación se da y es válida, se lanzará una llamada a la función &lt;function&gt; del contexto &lt;ctx&gt;. Al atajo se le puede asociar un nivel &lt;level&gt; de acceso. La función retorna un controlador de atajo de teclado.</p>
<p>El nivel de acceso sirve principalmente en ventanas MDI donde podemos querer diferenciar atajos exclusivos del MDI con otros compartidos con la ventana padre. Para decidir el nivel asociado en un MDI se ha de usar la función <em>SetHotkeysLevel</em>.</p>
<p>Los atajos creados en las ventanas MDI realmente se agregan como atajos en la ventana padre. Por eso, si creamos un atajo igual al usado en la ventana padre con el mismo nivel, lo modificaremos y perderemos el original. En tal caso, conviene usar un nivel distinto al cero, que es el usado por defecto.</p>
<p>Si lo que queremos es que los atajos del padre no afecten al MDI, simplemente subiremos el nivel de atajo al MDI con la función <em>SetHotkeysLevel</em> y solo se tendrán en cuenta los atajos con nivel mayor o igual al indicado.</p>
<p>function <strong>RemoveHotKey</strong> (handle)</p>
<p>Elimina un controlador de atajo de teclado &lt;handle&gt;.</p>
<p>function <strong>RemoveHotKey</strong> (list, ctx)</p>
<p>Elimina cualquier atajo que establezca la combinación de teclas definida en &lt;list&gt; y que tenga como contexto asociado &lt;ctx&gt;.</p>
<p>function <strong>RemoveHotKeysWithContext</strong> (ctx)</p>
<p>Elimina cualquier atajo de teclado asociado a la ventana que tenga como contexto &lt;ctx&gt;.</p>
<p>function <strong>FindHotKeyByContext</strong> (ctx, function, level = 0) : pointer</p>
<p>Busca un atajo de teclado en la ventana que tenga asociado un contexto &lt;ctx&gt; y una función &lt;function&gt; y sea de nivel &lt;level&gt;.</p>
<p>function <strong>CenterToDesktop</strong> ()</p>
<p>Permite centrar la posición de la ventana con respecto al escritorio.</p>
<p>function <strong>SetModal</strong> (v)</p>
<p>Hace que la ventana gane acceso exclusivo, de manera que el resto de controles fuera de esa ventana quedan bloqueados.</p>
<p>function <strong>GetControlByName</strong> (name, inClientArea = true) : pointer</p>
<p>Obtiene un control hijo de la ventana con nombre &lt;name&gt;. En el caso de que &lt;inClientArea&gt; sea verdadero, solo se tendrán en cuenta los hijos o controles asociados a la zona cliente.</p>
<p>function <strong>AddSideControl</strong> (sideControl, position = UI_TOP)</p>
<p>Permite asignar comportamientos a los lados (bordes) de las ventanas, principalmente con el objetivo de redimensionar su tamaño si se ha especificado el estilo correspondiente.</p>
<p>function <strong>CreateDefaultFont</strong> () : pointer</p>
<p>Crea una instancia de la fuente de letra por defecto y la asocia a la ventana, de manera que una vez se destruya la ventana, lo harán también las instancias de fuentes de letra asociadas.</p>
<h2 id="ventanas-mdi">Ventanas MDI</h2>
<p>Un MDI es un tipo de ventana que puede ser creado por una ventana de aplicación. Por tanto, las ventanas MDI cuelgan de una ventana de aplicación. Dentro de estas ventanas podemos crear controles.</p>
<p>Ejemplo de creación:</p>
<pre><code>_window = GetWindow();</code></pre>
<pre><code>_mdi = _window.CreateMDI(10, 10, 200, 350);</code></pre>
<p>Para destruir un MDI, simplemente bastaría con borrar el objeto:</p>
<pre><code>delete _mdi;</code></pre>
<p>Las ventanas MDI se ubican por encima de la ventana de aplicación. Por defecto, tienen un comportamiento y estilo visual que podemos modificar.</p>
<p><img src="media/ccf4da622b3fe9d39856becfac957507.png" /></p>
<p>Estas ventanas tienen una barra de título con unos pequeños botones, además de unos marcos que permiten, si se quiere, la posibilidad de redimensionar el tamaño de la ventana. También es posible mover estas ventanas dinámicamente haciendo, por ejemplo, clic con el ratón sobre la barra de título.</p>
<p>Los botones disponibles en la barra de título de un MDI son: MAXIMIZAR y CERRAR.</p>
<p>El estilo con el que podemos crear una ventana MDI se asocia a los siguientes flags. Por defecto estos flags son: STYLE_CLOSE_BOX | STYLE_CAPTION | STYLE_SIZE_BOX | STYLE_RESIZE | STYLE_MAXIMIZE_BOX | STYLE_HIDE_MENU</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>STYLE_CLOSE_BOX</th>
<th>Muestra el botón de cerrar</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>STYLE_CAPTION</td>
<td>Muestra una barra de título y botonera</td>
</tr>
<tr class="even">
<td>STYLE_SIZE_BOX</td>
<td>Muestra el contorno de la ventana que permite redimensionar su área</td>
</tr>
<tr class="odd">
<td>STYLE_RESIZE</td>
<td>Permite redimensionar la ventana. Es posible hacerlo en vertical y/u horizontal.</td>
</tr>
<tr class="even">
<td>STYLE_MAXIMIZE_BOX</td>
<td>Muestra el botón de maximización. La maximización extiende el tamaño que ocupa un MDI en todo el área cliente de la ventana de aplicación.</td>
</tr>
<tr class="odd">
<td>STYLE_HIDE_MENU</td>
<td>Permite ocultar el menú asociado a la ventana de aplicación en el caso de que el MDI gane el foco.</td>
</tr>
</tbody>
</table>
<p>Para modificar el estilo del MDI, deben usarse <em>SetStyle</em>, <em>AddStyle</em>, <em>RemoveStyle</em> (véanse en la sección Ventanas de aplicación)</p>
<h2 id="menús">Menús</h2>
<p>A toda ventana de aplicación podemos crearle un menú. Este menú aparece en la parte superior de la pantalla. Un menú tiene Secciones y dentro de cada sección podemos crear nuevas secciones o ítems.</p>
<p>Para crear un menú:</p>
<pre><code>_menu = _window.CreateMenu();
_section = _menu.AddSection(&quot;File&quot;);
_section.AddItem(&quot;Add link...&quot;, this, &quot;OnAddLink&quot;);
_section.AddItem(&quot;Create link...&quot;, this, &quot;OnCreateLink&quot;);
_section.AddItem(&quot;Edit link...&quot;, this, &quot;OnEditLink&quot;);</code></pre>
<p>Podemos crear un separador entre opciones mediante:</p>
<pre><code>_section.AddItem(&quot;&quot;, null, &quot;&quot;);</code></pre>
<p><img src="media/a8786b0393f139dc9e3f047a18ab2586.png" /></p>
<p>Al crearse el menú, se miran los Hotkeys asociados a la ventana para determinar si coinciden con las opciones y en ese caso, se muestra la combinación de teclas junto a cada entrada del menú. Se puede ver, en el ejemplo anterior, que la opción de menú “Add link…” tenía ya un Hotkey asociado a la tecla INSERT, y por eso se muestra junto a ella.</p>
<h2 id="eventos">Eventos</h2>
<p>La interfaz de usuario se comunica con las aplicaciones a través de eventos. Se producen eventos, por ejemplo, cuando se hace clic sobre un botón, se arrastra un control hacia otro, se añade un elemento a una lista, etc. El interfaz permite avisar a las aplicaciones con la llamada a una función que tiene el siguiente prototipo:</p>
<pre><code>function OnEvent (sender, event, params)
{
}</code></pre>
<p>Los parámetros son:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>sender</th>
<th>El control que envía el evento. Un puntero.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>event</td>
<td>El ID del evento. Un número entero.</td>
</tr>
<tr class="even">
<td>params</td>
<td>Una lista con 0 o varios parámetros dependiendo del tipo de evento.</td>
</tr>
</tbody>
</table>
<p>Eventos</p>
<table>
<thead>
<tr class="header">
<th><strong>Etiqueta</strong></th>
<th><strong>Lista de parámetros</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UI_EVENT_INIT</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_DESTROY</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_ENTER</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_LEAVE</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_MOUSE_MOVE</td>
<td>[btnId, mx, my]</td>
</tr>
<tr class="even">
<td>UI_EVENT_MOUSE_DOWN</td>
<td>[btnId, mx, my]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_MOUSE_UP</td>
<td>[btnId, mx, my]</td>
</tr>
<tr class="even">
<td>UI_EVENT_MOUSE_WHEEL</td>
<td>[offset]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_CLICK</td>
<td>[btnId, mx, my]</td>
</tr>
<tr class="even">
<td>UI_EVENT_DOUBLE_CLICK</td>
<td>[btnId, mx, my]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_VALIDATING</td>
<td>[ValidateArgs]</td>
</tr>
<tr class="even">
<td>UI_EVENT_VALIDATED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_FOCUS_LEAVE</td>
<td>[controlLost, controlWin]</td>
</tr>
<tr class="even">
<td>UI_EVENT_FOCUS_ENTER</td>
<td>[controlLost, controlWin]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_POSITION_CHANGED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_SIZE_CHANGED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_BOUNDS_CHANGED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_ENABLE_CHANGED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_DRAG_START</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_DRAG_END</td>
<td>[frame, cancel]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_DRAG_RECEIVED</td>
<td>[frame, x, y]</td>
</tr>
<tr class="even">
<td>UI_EVENT_KEYDOWN</td>
<td><a href="#key">key</a></td>
</tr>
<tr class="odd">
<td>UI_EVENT_KEYUP</td>
<td><a href="#key">key</a></td>
</tr>
<tr class="even">
<td>UI_EVENT_CHAR</td>
<td>[char]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_CHECKED_CHANGED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_PRESSED_CHANGED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_SHOW</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_HIDE</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_VALUE_CHANGED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_MINVALUE_CHANGED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_MAXVALUE_CHANGED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_ANIMATION_PLAY</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_ANIMATION_PAUSED</td>
<td>[factor]</td>
</tr>
<tr class="even">
<td>UI_EVENT_ANIMATION_STOP</td>
<td>[userStop]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_ANIMATION_LOOP</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_FONT_CHANGED</td>
<td>[key, font]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_FONT_ADDED</td>
<td>[key, font]</td>
</tr>
<tr class="even">
<td>UI_EVENT_TEXT_CHANGED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_TEXTDOC_CURSOR_CHANGED</td>
<td>[x, y, sy]</td>
</tr>
<tr class="even">
<td>UI_EVENT_TEXTDOC_TEXT_DELETED</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_TEXTDOC_TEXT_ADDED</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_SCROLL_HORIZONTAL</td>
<td>[]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_SCROLL_VERTICAL</td>
<td>[]</td>
</tr>
<tr class="even">
<td>UI_EVENT_RADIO_CHECKED_CHANGED</td>
<td>[lostChecked, gainChecked]</td>
</tr>
<tr class="odd">
<td>UI_EVENT_MOTION_CONTROLLER_AXIS</td>
<td>[axisId, value, id]</td>
</tr>
</tbody>
</table>
<h2 id="controles">Controles</h2>
<p>En toda ventana se pueden crear controles. Los controles son los objetos visuales que componen dicha ventana (frames, botones, listas, etc.). En general, son áreas definidas con posición y tamaño, que tienen un comportamiento y una representación específicos. Tanto el origen como el tamaño de un control se miden en pixeles.</p>
<p>Los controles tienen jerarquía. Unos controles pueden ser hijos de otros. En esta herencia hay propiedades que se pueden ver afectadas, como la posición, el tamaño, la visibilidad o el color.</p>
<p>Todos los controles tienen una serie de métodos comunes:</p>
<p>function <strong>SetName</strong> (name)</p>
<p>Asigna un nombre &lt;name&gt; al control, lo que permite identificarlo. Esto no es obligatorio, pero hace falta en el caso de querer usar la función <em>GetControlByName</em>.</p>
<p>function <strong>GetName</strong> () : string</p>
<p>Retorna el nombre asociado al control.</p>
<p>function <strong>Show</strong> ()</p>
<p>Hace visible el control.</p>
<p>function <strong>Hide</strong> ()</p>
<p>Hace invisible el control.</p>
<p>function <strong>EnableClipping</strong> (v)</p>
<p>Activa el recorte de los hijos dentro del área visible del padre. En caso de que &lt;v&gt; sea verdadero, ningún hijo se mostrará fuera del área visible del padre.</p>
<p>function <strong>GetVisible</strong> () : bool</p>
<p>Indica si el control está visible. Tiene en cuenta la herencia paterna. O sea, un control es invisible si él mismo lo es o alguno de sus padres es invisible.</p>
<p>function <strong>GetVisibleInternal</strong> () : bool</p>
<p>Obtiene la visibilidad asociada al control. No tiene en cuenta la herencia de visibilidad de sus padres.</p>
<p>function <strong>IsHidden</strong> () : bool</p>
<p>Indica si el control es visible. Esta función no solo tiene en cuenta la propiedad visible del mismo; además, detecta si está fuera de pantalla u oculto tras otro control.</p>
<p>function <strong>IsDragging</strong> () : bool</p>
<p>Indica si el control se encuentra en una orden pendiente de Drag &amp; Drop.</p>
<p>function <strong>ClampToScreen</strong> ()</p>
<p>Asegura que tanto la posición como el tamaño del control no exceden de las dimensiones del escritorio. En tal caso, las ajusta.</p>
<p>function <strong>SetClampedToScreen</strong> (enable)</p>
<p>Obliga a que la posición y tamaño del control nunca excedan de las dimensiones del escritorio. Cuando &lt;enable&gt; es verdadero, cada vez que el control cambie de posición o tamaño, se verificará esta condición y se ajustará automáticamente.</p>
<p>function <strong>GetLeft</strong> () : int</p>
<p>Devolverá la posición origen horizontal (x).</p>
<p>function <strong>GetTop</strong> () : int</p>
<p>Devolverá la posición origen vertical (y).</p>
<p>function <strong>GetWidth</strong> () : int</p>
<p>Devuelve el ancho del control, o sea su tamaño horizontal.</p>
<p>function <strong>GetHeight</strong> () : int</p>
<p>Devuelve el alto del control, o sea su tamaño vertical.</p>
<p>function <strong>GetRight</strong> () : int</p>
<p>Devuelve la posición del extremo derecho del control.</p>
<p>Equivale a: GetLeft() + GetWidth() -1.</p>
<p>function <strong>GetBottom</strong> () : int</p>
<p>Devuelve la posición del extremo inferior del control.</p>
<p>Equivale: GetTop() + GetHeight() - 1.</p>
<p>function <strong>GetBounds</strong> () : list</p>
<p>Retorna una lista con los elementos: [GetLeft(), GetTop(), GetWidth(), GetHeight()].</p>
<p>function <strong>GetPosition</strong> () : list</p>
<p>Retorna una lista con los elementos: [GetLeft(), GetRight()].</p>
<p>function <strong>GetSize</strong> () : list</p>
<p>Retorna una lista con los elementos: [GetWidth(), GetHeight()].</p>
<p>function <strong>GetCenter</strong> () : list</p>
<p>Retorna una lista con los elementos: [GetLeft() + GetWidth()/2, GetTop() + GetHeight()/2].</p>
<p>function <strong>GetHCenter</strong> () : float</p>
<p>Retorna el valor GetLeft() + GetWidth() / 2.</p>
<p>function <strong>GetVCenter</strong> () : float</p>
<p>Retorna el valor GetTop() + GetHeight() / 2.</p>
<p>function <strong>SetLeft</strong> (left)</p>
<p>Asigna el valor de posición origen horizontal &lt;left&gt;.</p>
<p>function <strong>IncLeft</strong> (value, cutWidth = false)</p>
<p>Incrementa el valor de la posición origen horizontal en &lt;value&gt;. Si usamos &lt;cutWidth&gt; a verdadero, también reduciremos el tamaño horizontal del control en &lt;value&gt;.</p>
<p>function <strong>SetTop</strong> (top)</p>
<p>Asigna el valor de posición origen vertical &lt;top&gt;.</p>
<p>function <strong>IncTop</strong> (value, cutHeight = false)</p>
<p>Incrementa el valor de la posición origen vertical en &lt;value&gt;. Si usamos &lt;cutHeight&gt; a verdadero, también reduciremos el tamaño vertical del control en &lt;value&gt;.</p>
<p>function <strong>IncPosition</strong> (offx, offy, cutSize = false)</p>
<p>Equivale a hacer un <em>IncLeft</em> y un <em>IncTop</em> en la misma llamada.</p>
<p>function <strong>IncSize</strong> (offx, offy, cutPosition = false)</p>
<p>Incrementa el tamaño del control en (offx, offy). Si usamos &lt;cutPosition&gt; a verdadero, reduciremos ese incremento también en la posición origen. Esto permite agrandar tanto por arriba/izquierda como por abajo/derecha.</p>
<p>function <strong>IncWidth</strong> (value, cutLeft = false)</p>
<p>Incrementa el ancho del control. En caso de que &lt;cutLeft&gt; sea verdadero, reduciremos ese incremento en la posición origen horizontal.</p>
<p>function <strong>IncHeight</strong> (value, cutTop = false)</p>
<p>Incrementa el alto del control. En caso de que &lt;cutTop&gt; sea verdadero, reduciremos ese incremento en la posición origen vertical.</p>
<p>function <strong>IncBounds</strong> (offx, offy, offw, offh)</p>
<p>Incrementa la posición origen en (offx, offy) y al mismo tiempo incrementa el tamaño del control en (offw, offh).</p>
<p>function <strong>SetWidth</strong> (width)</p>
<p>Asigna el tamaño horizontal (ancho) del control.</p>
<p>function <strong>SetHeight</strong> (height)</p>
<p>Asigna el tamaño vertical (alto) del control.</p>
<p>function <strong>SetPosition</strong> (left, top)</p>
<p>Asigna el origen del control a su nueva posición (left, top).</p>
<p>function <strong>SetSize</strong> (width, height)</p>
<p>Determina el tamaño de un control y lo establece a (width, height).</p>
<p>function <strong>CenterToParent</strong> ()</p>
<p>Centra la posición de un control a su padre. Si no tiene padre, lo hará con respecto al escritorio.</p>
<p>function <strong>SetMinimumSize</strong> (w, h)</p>
<p>Establece el tamaño mínimo que puede alcanzar el control.</p>
<p>function <strong>SetMaximumSize</strong> (w, h)</p>
<p>Establece el tamaño máximo que puede alcanzar el control.</p>
<p>function <strong>GetMinimumSize</strong> () : list</p>
<p>Obtiene el tamaño mínimo en una lista [wMin, hMin].</p>
<p>function <strong>GetMinimumWidth</strong> () : int</p>
<p>Obtiene el tamaño mínimo horizontal.</p>
<p>function <strong>GetMinimumHeight</strong> () : int</p>
<p>Obtiene el tamaño mínimo vertical.</p>
<p>function <strong>GetMaximumWidth</strong> () : int</p>
<p>Obtiene el tamaño máximo horizontal.</p>
<p>function <strong>GetMaximumHeight</strong> () : int</p>
<p>Obtiene el tamaño máximo vertical.</p>
<p>function <strong>SetBounds</strong> (left, top, width, height)</p>
<p>Establece tanto origen del control (left, top) como tamaño del mismo (width, height).</p>
<p>function <strong>PointToClient</strong> (x, y)</p>
<p>Dado un punto en coordenadas absolutas (es decir, respecto al escritorio), determina su posición relativa al control.</p>
<p>function <strong>PointToScreen</strong> (x, y)</p>
<p>Dado un punto en coordenadas locales (relativas al control), determina su posición absoluta.</p>
<p>function <strong>GetFBounds</strong> () : list</p>
<p>Devuelve las características absolutas (coordenadas X e Y, ancho y altura) de un control en el escritorio: [x, y, w, h]. Estos valores determinan exactamente la posición y tamaño del control una vez aplicadas todas las dependencias y transformaciones que se requieran.</p>
<p>function <strong>CursorInRect</strong> (x, y, w, h) : bool</p>
<p>Indica si el cursor de escritorio se encuentra en el rectángulo definido por (x, y) y tamaño (w, h). Las coordenadas (x, y) son locales al control, siendo (0, 0) el origen del control.</p>
<p>function <strong>GetCursorPoint</strong> () : list</p>
<p>Obtiene la posición del cursor de escritorio teniendo en cuenta las transformaciones de escala aplicadas al control.</p>
<p>function <strong>AlignToParent</strong> (flags, offset = 0)</p>
<p>Permite alinear un control con respecto a su padre utilizando los &lt;flags&gt;:</p>
<table>
<thead>
<tr class="header">
<th>UI_HCENTER</th>
<th>Lo centra horizontalmente y le resta &lt;offset&gt;.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UI_VCENTER</td>
<td>Lo centra verticalmente y le resta &lt;offset&gt;.</td>
</tr>
<tr class="even">
<td>UI_LEFT</td>
<td>Le suma &lt;offset&gt; a la posición horizontal.</td>
</tr>
<tr class="odd">
<td>UI_RIGHT</td>
<td>Lo coloca a la derecha y lo separa &lt;offset&gt;.</td>
</tr>
<tr class="even">
<td>UI_BOTTOM</td>
<td>Lo coloca abajo y lo separa &lt;offset&gt;.</td>
</tr>
<tr class="odd">
<td>UI_TOP</td>
<td>Le suma &lt;offset&gt; a la posición vertical.</td>
</tr>
</tbody>
</table>
<p>function <strong>SetPin</strong> (flags)</p>
<p>Permite establecer los flags de anclado. Estos flags permiten establecer cómo se ve afectado un control con respecto al cambio de posición y tamaño de su padre. Los flags pueden ser uno o varios de los siguientes:</p>
<table>
<thead>
<tr class="header">
<th>UI_PIN_LEFT</th>
<th>Anclar a la izquierda.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UI_PIN_RIGHT</td>
<td>Anclar a la derecha.</td>
</tr>
<tr class="even">
<td>UI_PIN_TOP</td>
<td>Anclar arriba.</td>
</tr>
<tr class="odd">
<td>UI_PIN_BOTTOM</td>
<td>Anclar abajo.</td>
</tr>
<tr class="even">
<td>UI_PIN_ALL</td>
<td>Una combinación de todos los anteriores.</td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<pre><code>_button.SetPin(UI_PIN_LEFT | UI_PIN_BOTTOM);</code></pre>
<p>function <strong>AddPin</strong> (flags)</p>
<p>Añade un flag de anclado a los ya existentes.</p>
<p>function <strong>RemovePin</strong> (flags)</p>
<p>Elimina un flag de anclado de entre los existentes.</p>
<p>function <strong>HasPin</strong> (flags) : bool</p>
<p>Pregunta por un flag de anclado. En caso de estar activo, devolverá verdadero.</p>
<p>function <strong>PinToBounds</strong> ()</p>
<p>Ajusta la posición y el tamaño del control a los del padre. Al mismo tiempo, aplica un UI_PIN_ALL, de manera que crecerá o decrecerá en proporción al padre.</p>
<p>function <strong>ClearPin</strong> ()</p>
<p>Elimina todos los flags de anclado asignados. Equivale a un <em>SetPin</em>(0).</p>
<p>function <strong>SetAlpha</strong> (value)</p>
<p>Determina el nivel de transparencia/opacidad del control. Si &lt;value&gt; es 0, el control será totalmente transparente. Si &lt;value&gt; es 255, el control será totalmente opaco. Por defecto todos los controles se crean con 255 (totalmente opacos).</p>
<p>function <strong>GetAlpha</strong> () : float</p>
<p>Obtiene la transparencia asociada al control.</p>
<p>function <strong>GetEffectiveAlpha</strong> () : float</p>
<p>Obtiene la transparencia efectiva, teniendo en cuenta la jerarquía del control. Si un padre tiene un alpha de 127, y el hijo de 255, el alpha efectivo será de 127 ((255*127)/255).</p>
<p>function <strong>EnableExternalMove</strong> (context, func)</p>
<p>Activa la actualización externa del control. Esto permite asociar un contexto y funciones externos donde gestionar o controlar la lógica del control.</p>
<p>function <strong>EnableExternalDraw</strong> (context, func, flags = 1)</p>
<p>Activa la actualización externa de la representación gráfica del control. Esto permite asociar un contexto y funciones externos donde poder aplicar cambios en la visualización del control. Mediante el uso de &lt;flags&gt; controlamos en qué momentos queremos que se invoque la función:</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>Antes de que se dibujen los gráficos asociados al control.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>Antes de que se dibujen los hijos del control.</td>
</tr>
<tr class="even">
<td>4</td>
<td>Después de dibujar los hijos del control.</td>
</tr>
</tbody>
</table>
<p>function <strong>SetScale</strong> (value)</p>
<p>Asigna una escala que afecta directamente al tamaño y posición del objeto (si tiene <em>EnableScalePosition</em> activado). El valor de escala &lt;value&gt; es un número con decimales. Si &lt;value&gt; es 1, el control se dibujará con las dimensiones establecidas. Si &lt;value&gt; es 0.5, el control se dibujará a la mitad de su tamaño. Si &lt;value&gt; es 2, el control se dibujará al doble de su tamaño.</p>
<p>function <strong>GetScale</strong> () : float</p>
<p>Obtiene la escala asociada al control.</p>
<p>function <strong>GetEffectiveScale</strong> () : float</p>
<p>Obtiene la escala efectiva una vez aplicada la escala en jerarquía.</p>
<p>function <strong>EnableScalePosition</strong> ()</p>
<p>Hace que la escala afecte también a la posición del control.</p>
<p>function <strong>DisableScalePosition</strong> ()</p>
<p>Hace que la escala solo afecte a las dimensiones del control (ancho y alto).</p>
<p>function <strong>GetScalePosition</strong> () : list</p>
<p>Devuelve una lista de dos componentes con la posición del control, teniendo en cuenta la escala aplicada.</p>
<p>function <strong>SetScalePivot</strong> (x, y)</p>
<p>Asigna la posición relativa del pivote para el escalado. Por defecto esta posición es el origen del objeto (top, left). En este caso, sería como hacer <em>SetScalePivot</em> (0, 0).</p>
<p>function <strong>SetScalePivotX</strong> (x)</p>
<p>Asigna la posición relativa del pivote para el escalado solo en la componente horizontal.</p>
<p>function <strong>SetScalePivotY</strong> (y)</p>
<p>Asigna la posición relativa del pivote para el escalado solo en la componente vertical.</p>
<p>function <strong>GetScalePivot</strong> () : list</p>
<p>Obtiene una lista de dos componentes con el pivote de escalado. Por defecto [0, 0].</p>
<p>function <strong>GetScalePivotX</strong> () : float</p>
<p>Devuelve la componente horizontal del pivote de escalado. Por defecto es 0.</p>
<p>function <strong>GetScalePivotY</strong> () : float</p>
<p>Devuelve la componente vertical del pivote de escalado. Por defecto es 0.</p>
<p>function <strong>SetUserData</strong> (data)</p>
<p>Asocia datos de usuario al control. &lt;data&gt; puede ser cualquier tipo de dato aceptado en el script.</p>
<p>function <strong>GetUserData</strong> () : value</p>
<p>Obtiene los datos de usuario asociados al control.</p>
<p>function <strong>SetMask</strong> (texture)</p>
<p>Asigna una textura de máscara al control. La textura de máscara es una textura que mediante color blanco y negro define qué zona del control es visible o no. La zona en negro de dicha textura enmascara al control y hace no visible esa parte del gráfico del control.</p>
<p>function <strong>EnableMask</strong> (value, broadcastChildren = false)</p>
<p>Permite activar el uso de la textura de máscara en el control. Permite también aplicar en jerarquía, de padre a hijos, el uso de la máscara poniendo &lt;broadcastChildren&gt; a verdadero.</p>
<p>function <strong>AreAllTexturesLoaded</strong> (askToChildren = true) : bool</p>
<p>La carga de texturas puede ser en segundo plano. Esta función permite consultar el estado de la carga y saber si el proceso se ha completado o no. También permite hacer la consulta en jerarquía de padre a hijos poniendo &lt;askToChildren&gt; a verdadero.</p>
<p>function <strong>SetParent</strong> (parent)</p>
<p>Establece el padre del control. Si el control ya era hijo de otro control, al aplicar esta función dejará de ser hijo de ese control y pasará a serlo de &lt;parent&gt;.</p>
<p>function <strong>SetOwner</strong> (owner)</p>
<p>Determina el control propietario.</p>
<p>function <strong>GetOwner</strong> () : pointer</p>
<p>Obtiene el control propietario.</p>
<p>function <strong>GetChildren</strong> () : list</p>
<p>Devuelve una lista con todos los controles hijos. Cada elemento de la lista es un puntero a cada control hijo.</p>
<p>function <strong>GetControlByName</strong> (name) : pointer</p>
<p>Devuelve un objeto hijo con nombre &lt;name&gt;. En caso de que no exista ningún control con ese nombre, devolverá NULL.</p>
<p>function <strong>GetChildrenCount</strong> ()</p>
<p>Determina el número de controles hijos existente.</p>
<p>function <strong>GetParent</strong> () : pointer</p>
<p>Devuelve el padre del control. En caso de que no tenga, devolverá NULL.</p>
<h2 id="frame">Frame</h2>
<p>Este control permite, a su vez, crear otros controles dentro del mismo. Un frame define un área de trabajo.</p>
<p>Métodos disponibles:</p>
<p>function <strong>GetDesktop</strong> () : pointer</p>
<p>Obtiene acceso al controlador de escritorio.</p>
<p>function <strong>GetView</strong> () : pointer</p>
<p>Obtiene acceso al controlador de UI.</p>
<p>function <strong>GetEngine</strong> ()</p>
<p>Obtiene acceso al controlador principal.</p>
<p>function <strong>ClearFonts</strong> ()</p>
<p>Elimina todas las fuentes de letra existentes.</p>
<p>function <strong>DestroyFont</strong> (font)</p>
<p>Elimina una fuente de letra creada previamente. El parámetro es un puntero a un controlador de fuente.</p>
<p>function <strong>Activate</strong> ()</p>
<p>Activa el frame.</p>
<p>function <strong>SetMouseCursor</strong> (cursor)</p>
<p>Permite establecer un tipo de gráfico para el cursor. Estos tipos están disponibles a través del controlador Desktop y son estos:</p>
<table>
<thead>
<tr class="header">
<th>CURSOR_NORMAL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CURSOR_MOVE</td>
</tr>
<tr class="even">
<td>CURSOR_SELECTION</td>
</tr>
<tr class="odd">
<td>CURSOR_HAND</td>
</tr>
<tr class="even">
<td>CURSOR_PROHIBITED</td>
</tr>
<tr class="odd">
<td>CURSOR_RESIZE_HORIZONTAL</td>
</tr>
<tr class="even">
<td>CURSOR_RESIZE_VERTICAL</td>
</tr>
<tr class="odd">
<td>CURSOR_RESIZE_DIAG_LR</td>
</tr>
<tr class="even">
<td>CURSOR_RESIZE_DIAG_RL</td>
</tr>
<tr class="odd">
<td>CURSOR_WAITING</td>
</tr>
<tr class="even">
<td>CURSOR_DRAGGING_MOVE</td>
</tr>
</tbody>
</table>
<p>function <strong>SetBgColor</strong> (color)</p>
<p>Determina un color de fondo para el área que ocupa el frame. El parámetro &lt;color&gt; es un entero con las componentes ARGB empaquetadas A8R8G8B8 (véanse <em>RGB</em> y <em>ARGB</em>).</p>
<p>function <strong>CreateFont</strong> (name, size) : font</p>
<p>Crea un controlador de fuente a partir de un nombre de fuente &lt;name&gt; y un tamaño &lt;size&gt;. El archivo de fuente debe ser accesible por el sistema, en caso contrario se devolverá NULL.</p>
<p>function <strong>CreateDefaultFont</strong> (size) : font</p>
<p>Crea una fuente por defecto, utilizando la que haya por defecto en el tema UI establecido y con tamaño &lt;size&gt;.</p>
<p>function <strong>GetClientControl</strong> () : pointer</p>
<p>Devuelve el frame que representa el área de cliente donde el usuario puede agregar nuevos controles.</p>
<p>function <strong>CreateControl</strong> (class, name = null, params = []) : pointer</p>
<p>Crea un control a partir del nombre de clase &lt;class&gt;. Se le puede asociar un nombre al control mediante una cadena de texto en &lt;name&gt;. También se le pueden pasar parámetros al constructor del control en &lt;params&gt; si fuese necesario. Esta función, además de permitir crear controles ya existentes en el UI, nos permite poder crear controles ad hoc, bien heredados o desde cero.</p>
<p>function <strong>CreateControl</strong> (class, x, y, w, h, name = null, params = []) : pointer</p>
<p>Crea un control (véase <em>CreateControl</em>) y además le aplica una posición y tamaño.</p>
<p>function <strong>CreateRect</strong> (x, y, w, h, color) : pointer</p>
<p>Crea un control de tipo Rect. Este control es un rectángulo con color con posición relativa a la zona de cliente (x, y) y tamaño (w, h).</p>
<p>Ejemplo:</p>
<pre><code>_rect = GetTopWindow().CreateRect(10, 10, 100, 100, RGB(255,0,0));</code></pre>
<p><img src="media/67f7d12c9e7b650489f5b0eca845cdd2.png" /></p>
<p>function <strong>CreateLabel</strong> (x, y, w, h = -1, text = "", fontH = -1) : pointer</p>
<p>Crea una etiqueta de texto en la posición (x, y) y con tamaño (w, h). En el caso de que &lt;h&gt; sea -1, usará el tamaño determinado por la fuente de letra por defecto. Del mismo modo &lt;fontH&gt; igual a -1 indica que se use el tamaño por defecto para la fuente.</p>
<p>Ejemplo:</p>
<pre><code>_label = GetTopWindow().CreateLabel(10, 10, 100, -1, &quot;Label&quot;);</code></pre>
<p><img src="media/18d5864a27b04c25e8b83d165dbf9acc.png" /></p>
<p>function <strong>CreateImage</strong> (x, y, w, h, texName = "") : pointer</p>
<p>Crea una imagen a partir de la ruta nativa al archivo pasada como parámetro en &lt;texName&gt;. La textura/imagen se colocará en (x, y) relativa al área cliente y con tamaño (w, h).</p>
<p>Ejemplo:</p>
<pre><code>_img = GetTopWindow().CreateImage(10, 10, 200, 200, GetEngine().GetPath(&quot;logo.png&quot;));</code></pre>
<p><img src="media/00424df72cc5fbcbd853ea2b7447d6bc.png" /></p>
<p>function <strong>CreateColorPicker</strong> (x, y, w, h = -1)</p>
<p>Crea un control de selección de color ARGB en la posición (x, y) relativa al área cliente con tamaño (w, h). Si &lt;h&gt; es -1, se utilizará el tamaño más apropiado por defecto. Este control está compuesto por un Rect que indica el color seleccionado y un botón que permite abrir un seleccionador de color.</p>
<p>Ejemplo:</p>
<pre><code>_img = GetTopWindow().CreateColorPicker(10, 10, 100, -1);</code></pre>
<p><img src="media/e2faf6c722e609eb56d5a8e6ce3d359b.png" /></p>
<p>function <strong>CreateTextBox</strong> (x, y, w, h = -1, fontH = 0) : pointer</p>
<p>Crea un control de caja de texto en la posición (x, y) relativa al área cliente y con tamaño (w, h). En el caso de &lt;h&gt; igual a -1, elegimos el alto por defecto para este tipo de control. Si no especificamos ningún tamaño de fuente en &lt;fontH&gt;, se usará el tamaño de fuente por defecto.</p>
<p>Ejemplo:</p>
<pre><code>_tb = GetTopWindow().CreateTextBox(10, 10, 100);
_tb.SetText(&quot;Texto&quot;);</code></pre>
<p><img src="media/702c7fc2a73e3cb51f6794735d94ed2a.png" /></p>
<p>function <strong>CreateListBox</strong> (x, y, w, h) : pointer</p>
<p>Crea un control lista de texto en la posición (x, y) relativa al área cliente y con tamaño (w, h).</p>
<p>Ejemplo:</p>
<pre><code>_lb = GetTopWindow().CreateListBox(10, 10, 100, 200);
_lb.AddItem(&quot;Item1&quot;);
_lb.AddItem(&quot;Item2&quot;);</code></pre>
<p><img src="media/46a8b408ada4abf705148d49ac505256.png" /></p>
<p>function <strong>CreateComboBox</strong> (x, y, w, h = -1) : pointer</p>
<p>Crea un control caja seleccionable en la posición (x, y) relativa al área cliente y con tamaño (w, h).</p>
<p>Ejemplo:</p>
<pre><code>_lb = GetTopWindow().CreateComboBox(10, 10, 100);
_lb.AddItem(&quot;Item1&quot;);
_lb.AddItem(&quot;Item2&quot;);</code></pre>
<p><img src="media/bd68e39f082eddca654ad9219feaff6d.png" /></p>
<p>function <strong>CreateTrackbar</strong> (x, y, size, layout = UI_HORIZONTAL) : pointer</p>
<p>Crea un control barra de seguimiento en la posición (x, y) relativa al área cliente. El ancho o el alto del control dependerán de &lt;size&gt; y del parámetro &lt;layout&gt;, que podrá ser UI_HORIZONTAL o UI_VERTICAL.</p>
<p>Ejemplo:</p>
<pre><code>_tb = GetTopWindow().CreateTrackbar(10, 10, 100, UI_HORIZONTAL);</code></pre>
<p><img src="media/116d8fddc7d2b0d8735cf8af2c5998e5.png" /></p>
<p>function <strong>CreateScrollBar</strong> (x, y, size, layout = UI_VERTICAL) : pointer</p>
<p>Crea un control de barra de desplazamiento en la posición (x, y) relativa al área cliente. El ancho o alto del control dependerán de &lt;size&gt; y del parámetro &lt;layout&gt;, que podrá ser UI_HORIZONTAL o UI_VERTICAL.</p>
<p>Ejemplo:</p>
<pre><code>_ctrl = GetTopWindow().CreateScrollbar(10, 10, 100, UI_HORIZONTAL);</code></pre>
<p><img src="media/fa4420904cf3df7ff34afc6e6b929104.png" /></p>
<p>function <strong>CreateFrame</strong> (x, y, w, h) : pointer</p>
<p>Crea un control frame en la posición (x, y) relativa al área cliente y con tamaño (w, h). En un frame podemos crear a su vez otros frames y/o controles.</p>
<p>function <strong>CreateScrollFrame</strong> (x, y, w, h) : pointer</p>
<p>Crea un control frame de scroll. Este frame permite asociar contenido desplazable en su interior.</p>
<p>function <strong>CreateButton</strong> (x, y, w, h = -1, text = "") : pointer</p>
<p>Crea un control botón en la posición (x, y) relativa al área cliente y con tamaño (w, h). Podemos crear el botón con un texto &lt;text&gt;. Si &lt;h&gt; es -1 se usará el tamaño por defecto para este tipo de control.</p>
<p>Ejemplo:</p>
<pre><code>_button = GetTopWindow().CreateButton(10, 10, 100, -1, &quot;Button&quot;);</code></pre>
<p><img src="media/7be81c72791bb5e65203e9ef6109fcc2.png" /></p>
<p>function <strong>CreateCheckBox</strong> (x, y, w, h = -1, text = "") : pointer</p>
<p>Crea una casilla seleccionable en la posición (x, y) relativa al área cliente y con tamaño (w, h). Podemos crear la casilla con un texto &lt;text&gt;. Si &lt;h&gt; es -1 se usará el tamaño por defecto para este tipo de control.</p>
<p>Ejemplo:</p>
<pre><code>_cb = GetTopWindow().CreateCheckBox(10, 10, 100, -1, &quot;CheckBox&quot;);</code></pre>
<p><img src="media/f49606f042f9245696e172443b435319.png" /></p>
<p>function <strong>CreateRadioButton</strong> (x, y, w, h = -1, text = "") : pointer</p>
<p>Crea una casilla seleccionable única. Si tenemos varias casillas hermanas de este tipo, solo una de ellas puede estar seleccionada. Podemos crear la casilla con un texto &lt;text&gt;. Si &lt;h&gt; es -1 se usará el tamaño por defecto para este tipo de control.</p>
<p>Ejemplo:</p>
<pre><code>_rb = GetTopWindow().CreateRadioButton(10, 10, 100, -1, &quot;Radio Button&quot;);</code></pre>
<p><img src="media/e4605c7b49f4208516e9d662f94f99b7.png" /></p>
<p>function <strong>CreateImageButton</strong> (x, y, w, h, imageNormal = "“, imagePressed =”“, imageOver =”“, cbCtx = null, callback =”") : pointer</p>
<p>Crea un botón con aspecto a partir de imágenes. Estableceremos la posición (x, y) y tamaño (w, h) a utilizar, junto a las rutas nativas a las diferentes imágenes que representarán los aspectos o estados del botón. En caso de no usar ruta (cadena vacía), se ignorará el cambio de aspecto cuando haya cambio de estado. Los estados son:</p>
<table>
<thead>
<tr class="header">
<th>NORMAL</th>
<th>Cuando el botón ni está seleccionado ni se opera con él.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRESSED</td>
<td>Cuando el botón está siempre presionado con un clic de cursor.</td>
</tr>
<tr class="even">
<td>OVER</td>
<td>Cuando el cursor está encima del control.</td>
</tr>
</tbody>
</table>
<p>Se podrá establecer el SetOnClick del botón directamente si pasamos como parámetro el contexto &lt;cbCtx&gt; y la función a invocar &lt;callback&gt;.</p>
<p>Ejemplo:</p>
<pre><code>_ib = GetTopWindow().CreateImageButton(10, 10, 32, 32, GetEngine().GetPath(&quot;icon_os.png&quot;));</code></pre>
<p>function <strong>CreateRichTextEditor</strong> (x, y, w, h) : pointer</p>
<p>Crea una caja de edición de texto avanzada en la posición (x, y) y con tamaño (w, h) dentro del área cliente. Este tipo de control permite editar texto con varias fuentes, imágenes, colores y estilos. Está pensado para incluir un control de edición de textos más avanzado.</p>
<p>function <strong>CreateSplitter</strong> (x, y, w, h, direction = UI_VERTICAL) : pointer</p>
<p>Crea un tipo particular de frame, con lo que es posible albergar otros controles dentro del mismo. Este control permite crear zonas divisorias que pueden desplazarse y cambiar su tamaño de forma dinámica.</p>
<p>Ejemplo:</p>
<pre><code>_splitter = GetTopWindow().CreateSplitter(10, 10, 100, 100, UI_VERTICAL);</code></pre>
<p><img src="media/d9f7ee24c248435158646ad0fd0f1ac0.png" /></p>
<p>function <strong>CreateProgressBar</strong> (x, y, size, direction = UI_HORIZONTAL, overrideThemeSize = -1) : pointer</p>
<p>Crea una barra de progreso en la posición (x, y) y con tamaño &lt;size&gt; dependiendo de la dirección &lt;direction&gt; a utilizar: UI_HORIZONTAL o UI_VERTICAL. Si &lt;overrideThemeSize&gt; es -1, se usará el tamaño establecido por defecto para ese control en el tema UI activo. Si es un valor &gt;= 0 se usará el tamaño indicado.</p>
<p>Ejemplo:</p>
<pre><code>_pb = GetTopWindow().CreateProgressbar(10, 10, 100, UI_HORIZONTAL);</code></pre>
<pre><code>_pb.SetMinValue(0);
_pb.SetMaxValue(100);
_pb.SetValue(50);</code></pre>
<p><img src="media/39c553d67bfc798234b6ad06fde35593.png" /></p>
<p>function <strong>CreateSpin</strong> (x, y, w, h = -1, fontH = -1) : pointer</p>
<p>Crea un objeto Spin en la posición (x, y) y con tamaño (w, h). Si &lt;h&gt; es -1 se usará el tamaño establecido por defecto para este tipo de controles con en tema UI activo.</p>
<p>Ejemplo:</p>
<pre><code>_spin = GetTopWindow().CreateSpin(10, 10, 100);</code></pre>
<p><img src="media/62b3be2b6ff1e01b1cc794ff9e4dfd35.png" /></p>
<p>function <strong>CreateGroupBox</strong> (x, y, w, h, text = "", textAlign = UI_LEFT) : pointer</p>
<p>Crea un grupo donde contener otro tipo de controles. Los grupos representan visualmente difentes áreas mediante un borde y un texto &lt;text&gt; que hace de título de grupo.</p>
<p>Ejemplo:</p>
<pre><code>_gb = GetTopWindow().CreateGroupBox(10, 10, 100, 100, &quot;GroupBox&quot;);</code></pre>
<p><img src="media/3fd7090b62d32e60f9640317b3a94afd.png" /></p>
<h2 id="scrollframe">ScrollFrame</h2>
<p>Es un tipo de frame pensado para poder desplazar los controles que contiene en su interior. Es una especialización (hereda) del control Frame.</p>
<p>Tiene disponibles los métodos de Frame, y además:</p>
<p>function <strong>SetScrollChild</strong> (frame)</p>
<p>Permite asociar el frame que hará de contenedor de controles y a su vez podrá gestionar su desplazamiento.</p>
<p>function <strong>GetScrollChild</strong> () : pointer</p>
<p>Obtiene el frame contenedor.</p>
<p>function <strong>GetHorizontalScroll</strong> () : float</p>
<p>Obtiene el desplazamiento horizontal actual en base al rango.</p>
<p>function <strong>GetHorizontalScrollRange</strong> () : float</p>
<p>Obtiene el desplazamiento posible en función del ancho del frame contenedor.</p>
<p>function <strong>GetVerticalScroll</strong> () : float</p>
<p>Obtiene el desplazamiento vertical actual en base al rango.</p>
<p>function <strong>GetVerticalScrollRange</strong> () : float</p>
<p>Obtiene el desplazamiento posible en función del alto del frame contenedor.</p>
<p>function <strong>SetHorizontalScroll</strong> (scroll)</p>
<p>Establece el desplazamiento horizontal. &lt;scroll&gt; es un valor en base al rango.</p>
<p>function <strong>SetVerticalScroll</strong> (scroll)</p>
<p>Establece el desplazamiento vertical. &lt;scroll&gt; es un valor en base al rango.</p>
<p>function <strong>GetHorizontalScrollPctg</strong> () : float</p>
<p>Obtiene el desplazamiento horizontal normalizado (valores entre 0 y 1).</p>
<p>function <strong>SetHorizontalScrollPctg</strong> (scroll)</p>
<p>Establece el desplazamiento horizontal. &lt;scroll&gt; es un valor entre 0 y 1.</p>
<p>function <strong>GetVerticalScrollPctg</strong> () : float</p>
<p>Obtiene el desplazamiento vertical normalizado (valores entre 0 y 1).</p>
<p>function <strong>SetVerticalScrollPctg</strong> (scroll)</p>
<p>Establece la posición del desplazamiento vertical normalizada. &lt;scroll&gt; será un valor entre 0 y 1.</p>
<h2 id="button">Button</h2>
<p>function <strong>SetOnClick</strong> (ctx, function)</p>
<p>Establece el contexto &lt;ctx&gt; y el nombre de función &lt;function&gt; que se invocará cuando se haga clic sobre un botón. El clic es una pulsación y posterior liberación del cursor sobre el botón.</p>
<p>function <strong>SetOnPress</strong> (ctx, function, ms = 100)</p>
<p>Establece el contexto &lt;ctx&gt; y el nombre de función &lt;function&gt; que se invocará cuando se detecte la pulsación continua del botón. La llamada al evento se realizará cada cierto número de milisegundos &lt;ms&gt; que indiquemos.</p>
<p>function <strong>SetTextColor</strong> (color)</p>
<p>Establece el color del texto mostrado en el botón.</p>
<p>function <strong>SetTextAlign</strong> (align)</p>
<p>Establece la alineación del texto en el botón. Los valores de &lt;align&gt; podrán ser:</p>
<table>
<thead>
<tr class="header">
<th>DT_LEFT</th>
<th>Ajuste izquierda</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DT_TOP</td>
<td>Ajuste arriba</td>
</tr>
<tr class="even">
<td>DT_RIGHT</td>
<td>Ajuste derecha</td>
</tr>
<tr class="odd">
<td>DT_BOTTOM</td>
<td>Ajuste abajo</td>
</tr>
<tr class="even">
<td>DT_CENTER</td>
<td>Ajuste centrado horizontal</td>
</tr>
<tr class="odd">
<td>DT_VCENTER</td>
<td>Ajuste centrado vertical</td>
</tr>
</tbody>
</table>
<p>function <strong>GetText</strong> () : string</p>
<p>Obtiene el texto que muestra un botón.</p>
<p>function <strong>SetFont</strong> (name, size)</p>
<p>Establece la fuente usada para el texto que muestra el botón. Se indicará un nombre de fuente disponible &lt;name&gt; y un tamaño &lt;size&gt;.</p>
<p>function <strong>SetFontSize</strong> (size)</p>
<p>Establece el tamaño &lt;size&gt; que queremos dar a la fuente actual usada para representar el texto que muestra el botón.</p>
<p>function <strong>SetIcon</strong> (imagePath, w = -1, h = -1)</p>
<p>Establece la imagen que queremos representar como icono del botón. Se ha de indicar la ruta al archivo de la imagen &lt;imagePath&gt; y podemos indicar el tamaño de la misma dentro del botón (w, h). En caso de usar -1 para el ancho y/o alto, estaremos indicando que se use el tamaño original obtenido del archivo de la imagen.</p>
<p>function <strong>SetIconColor</strong> (color)</p>
<p>Establece el color de tintado del icono representado en el botón. Si el &lt;color&gt; es blanco, es decir RGB(255,255,255), el icono se representará con su color original.</p>
<p>function <strong>SetDefaultFont</strong> ()</p>
<p>Establece la fuente de letra por defecto usada por el tema UI en curso en el texto representado por el botón.</p>
<p>function <strong>SetColoredButton</strong> (normalColor, highlightColor = 0, pressedColor = 0, disabledColor = 0, chechedColor = 0)</p>
<p>Permite indicar colores planos en vez de texturas para los distintos estados del botón. Si el color de los estados es cero (totalmente transparente), se estará indicando que no se aplique el cambio de color para ese estado.</p>
<p>function <strong>SetNormalColor</strong> (color)</p>
<p>Establece un color plano para el estado “normal” de un botón.</p>
<p>function <strong>SetHighlightColor</strong> (color)</p>
<p>Establece un color plano para el estado “highlight” de un botón.</p>
<p>function <strong>SetPressedColor</strong> (color)</p>
<p>Establece un color plano para el estado “pressed” de un botón.</p>
<p>function <strong>SetDisabledColor</strong> (color)</p>
<p>Establece un color plano para el estado “disabled” de un botón.</p>
<p>function <strong>SetCheckedColor</strong> (color)</p>
<p>Establece un color plano para el estado “checked” de un botón.</p>
<p>function <strong>SetTintColor</strong> (color)</p>
<p>Aplica un color de tinta para los distintos estados gráficos asociados a un botón. En el caso de que &lt;color&gt; sea blanco, es decir RGB(255,255,255), se utilizará el color por defecto de los distintos estados. Si el color, por ejemplo, fuese un rojo, es decir RGB(255,0,0), los gráficos de los estados del botón se verían teñidos de color rojo.</p>
<p>function <strong>SetTextPadding</strong> (x, y)</p>
<p>Establece un margen superior e inferior para el texto mostrado en el botón.</p>
<p>function <strong>SetPressedTextOffset</strong> (x, y)</p>
<p>En el caso de que haga pulsación sobre un botón, establece cuánto desplazamiento sufrirá el texto mostrado. Esto permite crear un efecto visual más reforzado.</p>
<p>function <strong>GetPressedTextOffset</strong> () : list</p>
<p>Obtiene el offset [x, y] asociado al desplazamiento del texto en estado “pressed”.</p>
<h2 id="checkbox">CheckBox</h2>
<p>Es un tipo de botón que permite albergar dos estados, encendido y apagado.</p>
<p>Además de los métodos de un botón, dispone de estos otros:</p>
<p>function <strong>SetOnChange</strong> (ctx, function)</p>
<p>Cuando el estado de un checkbox cambia, se invoca esta función.</p>
<p>function <strong>SetChecked</strong> (v)</p>
<p>Establece el estado de un checkbox. El parámetro &lt;v&gt; es un booleano.</p>
<p>function <strong>GetChecked</strong> () : bool</p>
<p>Obtiene el estado actual de un checkbox.</p>
<h2 id="colorpicker">ColorPicker</h2>
<p>function <strong>SetColor</strong> (c)</p>
<p>Establece el color seleccionado &lt;c&gt; como ARGB dentro del control.</p>
<p>function <strong>GetColor</strong> () : int</p>
<p>Obtiene el color actualmente seleccionado dentro del control.</p>
<p>function <strong>SetOnColorChanged</strong> (ctx, function)</p>
<p>Cuando cambia el color seleccionado dentro del control, se invoca esta función.</p>
<h2 id="combobox">ComboBox</h2>
<p>Es un control de lista combinada. Dispone de una caja de texto, de un botón de despliegue de lista y de una lista.</p>
<p>function <strong>GetSelectedIndex</strong> () : int</p>
<p>Retorna el índice del elemento de la lista seleccionado, empezando a contar desde cero. En caso de que no haya ninguno seleccionado devolverá -1.</p>
<p>function <strong>SelectIndex</strong> (index)</p>
<p>Marca como seleccionado el elemento con posición &lt;index&gt; dentro de la lista. En el caso de que el índice usado esté fuera de rango, se ignorará la operación.</p>
<p>function <strong>SelectItemByUserData</strong> (userData)</p>
<p>Selecciona el elemento que tenga asociado el valor de datos de usuario igual al proporcionado como parámetro &lt;userData&gt;.</p>
<p>function <strong>SelectItemByText</strong> (text)</p>
<p>Selecciona el elemento que tenga el mismo texto que el indicado como parámetro &lt;text&gt;.</p>
<p>function <strong>SetText</strong> (text)</p>
<p>Establece el texto que aparece en la caja de texto del control.</p>
<p>function <strong>AddItem</strong> (text, userData = null)</p>
<p>Añade un elemento a la lista. En la lista veremos el texto &lt;text&gt; y podremos asociar a ese elemento datos de usuario &lt;userData&gt;.</p>
<p>function <strong>SetItemText</strong> (ix, text)</p>
<p>Establece el texto &lt;text&gt; asociado a un elemento con índice &lt;ix&gt; dentro de la lista.</p>
<p>function <strong>SetItemUserData</strong> (ix, userData)</p>
<p>Establece los datos de usuario &lt;userData&gt; asociados al elemento con índice &lt;ix&gt; dentro de la lista.</p>
<p>function <strong>GetItemUserData</strong> (ix = -1) : pointer</p>
<p>Obtiene los datos de usuario asociados al elemento con índice &lt;ix&gt; dentro de la lista.</p>
<p>function <strong>ClearItems</strong> ()</p>
<p>Borra todos los elementos de la lista.</p>
<p>function <strong>RemoveItem</strong> (ix)</p>
<p>Elimina el elemento con índice &lt;ix&gt; dentro de la lista.</p>
<p>function <strong>FindItemByText</strong> (text) : int</p>
<p>Obtiene el índice del elemento dentro de la lista, cuyo texto coincide con el facilitado como parámetro &lt;text&gt;. En caso de no encontrarse ese elemento, se devolverá -1.</p>
<p>function <strong>FindItemByUserData</strong> (userData) : int</p>
<p>Obtiene el índice del elemento dentro de la lista, donde los datos de usuarios coinciden con los facilitados como parámetro &lt;userData&gt;. En caso de no encontrarse ese elemento, se devolverá -1.</p>
<p>function <strong>GetSelectedText</strong> () : string</p>
<p>Devuelve el texto asociado al elemento seleccionado. Si no hay ningún elemento seleccionado devolverá cadena vacía.</p>
<p>function <strong>GetSelectedUserData</strong> () : pointer</p>
<p>Devolverá los datos de usuario asociados al elemento seleccionado. Si no hay ningún elemento seleccionado devolverá NULL.</p>
<p>function <strong>RemoveSelectedItem</strong> ()</p>
<p>Elimina de la lista el elemento seleccionado.</p>
<p>function <strong>GetNumItems</strong> () : int</p>
<p>Devuelve el número de elementos en la lista.</p>
<p>function <strong>SetOnButtonClick</strong> (ctx, function)</p>
<p>En el caso de que que se haga clic en el botón de desplegar la lista, se invocará esta función.</p>
<p>function <strong>SetOnChange</strong> (ctx, function)</p>
<p>En el caso de que cambie la selección de la lista, se invocará esta función.</p>
<p>function <strong>Apply</strong> (ctx, function, userData = null)</p>
<p>Se ejecutará la función &lt;function&gt; en el contexto &lt;ctx&gt; con el siguiente prototipo:</p>
<pre><code>function &lt;event&gt; (comboBox, itemIndex, userData);</code></pre>
<p>Por tanto, por cada elemento de la lista combinada, se hará una llamada a la función.</p>
<h2 id="image">Image</h2>
<p>Este tipo de control permite representar una textura (imagen) en una posición, tamaño y color establecidos.</p>
<p>function <strong>SetAutoReleaseTextures</strong> (value)</p>
<p>Se indica si queremos que las referencias de texturas asociadas se eliminen junto al control. Por defecto esto siempre está activado.</p>
<p>function <strong>GetAutoReleaseTextures</strong> () : bool</p>
<p>Indica si tenemos activada o no la eliminación automática de referencias de texturas asociadas.</p>
<p>function <strong>SetTextureLoadWithCache</strong> (value)</p>
<p>Indicamos si queremos cargar las texturas como instancias únicas o referencias. Por defecto se cargan como referencias. Cuando una textura se intenta cargar por segunda vez, si la caché está activada, no se vuelve a cargar, sino que se emplea una referencia.</p>
<p>function <strong>SetTexture</strong> (path, ox = 0, oy = 0)</p>
<p>Establece la textura que queremos que represente el control. La textura estará ubicada en la ruta indicada en &lt;path&gt;. Podremos darle un desplazamiento relativo a la posición del control usando las coordenadas (ox, oy).</p>
<p>function <strong>SetTexturePtr</strong> (ptr, ox = 0, oy = 0)</p>
<p>Establece la textura que queremos que represente el control. La textura será un puntero &lt;ptr&gt; previamente cargado o creado. Podremos darle un desplazamiento relativo a la posición del control usando las coordenadas (ox, oy).</p>
<p>function <strong>SetUrlTexture</strong> (url)</p>
<p>Establece la textura que queremos que represente el control. Esta textura será una url válida y se cargará en segundo plano. Mientras la textura se está descargando, se mostrará la imagen que haya establecida previamente. Una vez descargada, se sustituirá.</p>
<p>function <strong>SetIFLTexture</strong> (path, textureFolder = "", createAnimationsForFrames = true, speedForAnimation = 1)</p>
<p>Establece una secuencia de texturas (animación) obtenidas del archivo IFL que se cargue de la ruta &lt;path&gt;. Podremos establecer una carpeta origen donde estén las texturas almacenadas &lt;textureFolder&gt;; en caso de no indicar nada, se obtendrán de las carpetas accesibles. Se indicará si en vez de cargar una textura en IFL se desea cargar cada fotograma del IFL como fotograma independiente, esto se hará con &lt;createAnimationsForFrames&gt; en valor verdadero. Finalmente estableceremos la velocidad de animación &lt;speedForAnimation&gt;, que por defecto es 1.</p>
<p>function <strong>SetTexture</strong> (a, r, g, b)</p>
<p>Establece como textura de la imagen un color plano formado por las componentes ARGB(a, r, g, b).</p>
<p>function <strong>SetTextureColor</strong> (color)</p>
<p>Establece como textura de la imagen, un color plano formado por el ARGB pasado como parámetro &lt;color&gt;.</p>
<p>function <strong>GetTextureColor</strong> () : int</p>
<p>Devuelve el color ARGB asociado a la textura.</p>
<p>function <strong>GetTexture</strong> (frame = 0) : pointer</p>
<p>Devuelve la textura asociada al fotograma con índice &lt;frame&gt;.</p>
<p>function <strong>ClearFrames</strong> ()</p>
<p>Borra todos los fotogramas.</p>
<p>function <strong>SetFrameTexture</strong> (frame, texture)</p>
<p>Establece una textura en el índice de fotograma &lt;frame&gt;.</p>
<p>function <strong>GetFramesCount</strong> () : int</p>
<p>Devuelve el número de fotogramas asociados al control imagen.</p>
<p>function <strong>SetFrame</strong> (index)</p>
<p>Asigna como fotograma visible el que tiene por índice &lt;index&gt;. Si existe una animación, esta no se reproducirá y solo veremos el fotograma visible.</p>
<p>function <strong>SetAnimationForFrames</strong> (speed = 0)</p>
<p>Establece la velocidad de animación para los fotogramas. Si la velocidad es cero, la animación permanecerá estática y solo se verá el fotograma visible.</p>
<p>function <strong>SetAnimation</strong> (start, end, loop = -1)</p>
<p>Establece una animación formada por los fotogramas que tengamos asociados al control. La animación irá desde el fotograma con índice &lt;start&gt; hasta el fotograma con índice &lt;end&gt;. En caso de que &lt;loop&gt; sea -1, se volverá al fotograma inicial automáticamente cada vez que se alcance &lt;end&gt;. En el caso de que &lt;loop&gt; sea -2, se quedará de forma estática el último fotograma &lt;end&gt;. En el caso de que &lt;loop&gt; sea otro valor, al alcanzar el último fotograma &lt;end&gt; se volverá al índice de fotograma indicado por &lt;loop&gt;.</p>
<p>function <strong>SetAnimationSpeed</strong> (speed)</p>
<p>Establece la velocidad &lt;speed&gt; para la animación en curso.</p>
<p>function <strong>SetRadians</strong> (rad)</p>
<p>Da un ángulo (rotación) al control imagen. Este ángulo se establece en radianes.</p>
<p>function <strong>SetDegrees</strong> (deg)</p>
<p>Da un ángulo (rotación) al control imagen. Este ángulo se establece en grados.</p>
<p>function <strong>GetDegrees</strong> () : float</p>
<p>Devuelve el número de grados que está rotada la imagen.</p>
<p>function <strong>GetRadians</strong> () : float</p>
<p>Devuelve el número de radianes que está rotada la imagen.</p>
<p>function <strong>GetTexCoord</strong> (frame) : list</p>
<p>Retorna una lista con las coordenadas de textura asociadas al índice de fotograma &lt;frame&gt;. Esta lista tendrá los elementos: [x, y, w, h].</p>
<p>function <strong>SetTexCoord</strong> (frame, x, y, w, h)</p>
<p>Del mismo modo que <em>SetTextCoord</em>, pero en este caso indicamos sobre qué índice de fotograma &lt;frame&gt; queremos asignar las coordenadas.</p>
<p>function <strong>SetTexCoordAll</strong> (x, y, w, h)</p>
<p>Establece las coordenadas de textura de todos los fotogramas. Las coordenadas están en formato normalizado (valores entre 0 y 1). Las coordenadas indican el área a representar dentro de la textura asociada. Si estas coordenadas son (0, 0, 1, 1) estaremos indicando la textura al completo.</p>
<p>function <strong>FlipHorizontal</strong> (enable)</p>
<p>Aplica o quita el efecto de volteo horizontal sobre la imagen.</p>
<p>function <strong>HasHorizontalFlip</strong> () : bool</p>
<p>Indica si hay aplicado un efecto de volteo horizontal sobre la imagen.</p>
<p>function <strong>FlipVertical</strong> (enable)</p>
<p>Aplica o quita el efecto de volteo vertical sobre la imagen.</p>
<p>function <strong>HasVerticalFlip</strong> ()</p>
<p>Indica si hay aplicado un efecto de volteo vertical sobre la imagen.</p>
<h2 id="listbox">ListBox</h2>
<p>Control al que se le pueden agregar una serie de líneas de texto y que representa en forma de lista.</p>
<p>function <strong>SetBgColor</strong> (color)</p>
<p>Asigna un color de fondo para el fondo de la lista.</p>
<p>function <strong>SetFont</strong> (font)</p>
<p>Establece la fuente a utilizar para los textos de la lista. En este caso el parámetro &lt;font&gt; es un puntero a una fuente previamente creada o cargada.</p>
<p>function <strong>SetHideScrollbarIfDisabled</strong> (value)</p>
<p>Indica si queremos ocultar la barra de desplazamiento cuando el control está deshabilitado. Por defecto está desactivado.</p>
<p>function <strong>SetAutoScrollOnListChange</strong> (value)</p>
<p>Indica si queremos que el desplazamiento de la lista se ajuste automáticamente cada vez que la selección cambie. Por defecto está desactivado.</p>
<p>function <strong>SetFixTopItemOnInsert</strong> (value)</p>
<p>Sirve para mantener el scroll en el índice actual al insertar. Por defecto está desactivado.</p>
<p>function <strong>SetOwnerDrawRow</strong> (ctx, function)</p>
<p>Permite redireccionar mediante una llamada, cómo queremos representar cada elemento de nuestra lista. Para cada elemento a representar se invoca una función con el siguiente prototipo:</p>
<pre><code>function &lt;event&gt; (list, row, text, selected, ishover, x, y, w, h);</code></pre>
<p>function <strong>EnableHover</strong> (value)</p>
<p>Sirve para habilitar o inhabilitar los eventos de ratón cuando el cursor se posiciona sobre el control. Por defecto está activada.</p>
<p>function <strong>GetRowHeight</strong> () : int</p>
<p>Retorna el tamaño vertical requerido por cada elemento de la lista a la hora de representarse.</p>
<p>function <strong>SetRowHeight</strong> (value)</p>
<p>Establece el tamaño vertical requerido para la representación de cada elemento de la lista.</p>
<p>function <strong>SetTextAlign</strong> (ta)</p>
<p>Establece la alineación a emplear para el texto de cada elemento de la lista. El parámetro &lt;ta&gt; podrá ser una o varias de las combinaciones: DT_LEFT, DT_TOP, DT_RIGHT, DT_BOTTOM, DT_CENTER, DT_VCENTER.</p>
<p>Ejemplo:</p>
<pre><code>_lb.SetTextAlign(DT_CENTER | DT_VCENTER);</code></pre>
<p>Que permite centrar el texto de los elementos de la lista tanto en vertical como en horizontal.</p>
<p>function <strong>GetHoverIndex</strong> () : int</p>
<p>Devuelve el índice del elemento de la lista sobre el cual se encuentra el cursor del ratón.</p>
<p>function <strong>GetListHeight</strong> () : int</p>
<p>Obtiene el tamaño vertical que ocupan todos los elementos de la lista.</p>
<p>function <strong>SetMultiSelect</strong> (value)</p>
<p>Se establece si se quiere selección múltiple, donde se pueden seleccionar varios elementos de la lista a la vez, o selección simple, donde un solo elemento a la vez puede estar seleccionado. Para la selección simple, &lt;value&gt; ha de ser falso. Por defecto hay selección simple.</p>
<p>function <strong>ClearItems</strong> ()</p>
<p>Elimina todos los elementos de la lista.</p>
<p>function <strong>SetStringList</strong> (list)</p>
<p>Establece la lista de elementos que queremos usar. Esta lista está compuesta por sublistas donde cada una de ella representa: [text, userData, color, icon]. O sea, cada sublista representa el texto de cada elemento, datos de usuario asociados, color para el texto e icono a visualizar. En caso de no querer representar ningún icono, podemos pasar una sublista con 3 elementos o indicar NULL.</p>
<p>function <strong>GetListSize</strong> () : int</p>
<p>Devuelve el número de elementos de la lista.</p>
<p>function <strong>ClearSelection</strong> ()</p>
<p>Quita cualquier selección de elementos en la lista.</p>
<p>function <strong>SelectIndex</strong> (index, value = true, addToSelection = true)</p>
<p>Establece (&lt;value&gt; verdadero) o quita (&lt;value&gt; falso) la selección del elemento con índice &lt;index&gt;. En caso de selección múltiple, con &lt;addToSelection&gt; iremos agregando o quitando elementos de la selección múltiple.</p>
<p>function <strong>SelectRange</strong> (from, to, mode = 0)</p>
<p>Establece la selección desde el índice &lt;from&gt; hasta el índice &lt;to&gt;. Se puede establecer según el valor de &lt;mode&gt;:</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>Añadir a la selección.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Quitar de la selección.</td>
</tr>
<tr class="even">
<td>2</td>
<td>Invertir la selección.</td>
</tr>
</tbody>
</table>
<p>function <strong>SelectNext</strong> (step = 1)</p>
<p>Mueve la selección al siguiente índice según un número de pasos &lt;step&gt;. Una vez se alcanza el final, se queda en ese último índice.</p>
<p>function <strong>SelectPrevious</strong> (step = 1)</p>
<p>Mueve la selección al anterior índice según un número de pasos &lt;step&gt;. Una vez se alcanza el principio, se queda en ese primer índice.</p>
<p>function <strong>SetMatchPattern</strong> (mp)</p>
<p>Establece un filtro para mostrar elementos en la lista. Los elementos con textos que coincidan con el patrón &lt;mp&gt; serán los únicos que aparecerán en la lista.</p>
<p>function <strong>GetSelectedIndex</strong> () : int</p>
<p>Obtiene el índice seleccionado en caso de selección simple. Si no hay ningún elemento seleccionado, devolverá -1.</p>
<p>function <strong>GetSelectedIndexRange</strong> () : list</p>
<p>Devuelve una lista con todos los índices que estén seleccionados. Si no hay índices seleccionados la lista devuelta estará vacía.</p>
<p>function <strong>IsSelectedIndex</strong> (index) : bool</p>
<p>Consulta si un índice de la lista está seleccionado o no.</p>
<p>function <strong>ScrollAtEnd</strong> ()</p>
<p>Posiciona el desplazamiento al final de la lista.</p>
<p>function <strong>GetText</strong> (index) : string</p>
<p>Obtiene el texto asociado a un elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>SetText</strong> (index, text)</p>
<p>Establece el texto &lt;text&gt; asociado a un elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>SetTextColor</strong> (index, color)</p>
<p>Establece el color del texto asociado a un elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>GetTextColor</strong> (index) : int</p>
<p>Obtiene el color de texto asociado a un elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>SetIcon</strong> (index, icon)</p>
<p>Establece un icono &lt;icon&gt; al elemento de la lista con índice &lt;index&gt;. El icono será un puntero a una textura.</p>
<p>function <strong>GetIcon</strong> (index) : pointer</p>
<p>Obtiene la textura del icono asociado a un elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>SetUserData</strong> (index, userdata)</p>
<p>Establece datos de usuario &lt;userdata&gt; del elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>GetUserData</strong> (index) : value</p>
<p>Obtiene los datos de usuario asociados al elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>FindUserData</strong> (userdata) : int</p>
<p>Dado unos datos de usuario &lt;userdata&gt;, se obtendrá el índice del primer elemento de la lista que los tenga asociados. En caso de no encontrar ningún elemento se retornará ‑1.</p>
<p>function <strong>FindText</strong> (text) : int</p>
<p>Dado un texto, se obtendrá el índice del primer elemento de la lista que tenga asociado el mismo texto. En caso de no encontrar ningún elemento se retornará -1.</p>
<p>function <strong>AddItem</strong> (text, userdata = null, color = 0, icon = null)</p>
<p>Añade un elemento al final de la lista con texto &lt;text&gt;, datos de usuario &lt;userdata&gt;, color para el texto y una textura de icono &lt;icon&gt;. Se pueden omitir los datos de usuario, el color y el icono. En el caso de que el color tenga el valor cero, estaremos asumiendo que se usará el valor de color por defecto para el texto de la lista.</p>
<p>function <strong>InsertItem</strong> (index, text, userdata = null, color = 0, icon = null)</p>
<p>Esta función es igual a <em>AddItem</em>, con la diferencia de que en vez de insertar al final lo hace delante de la posición indicada en &lt;index&gt;.</p>
<p>function <strong>DeleteItem</strong> (index)</p>
<p>Elimina el elemento de la lista con índice &lt;index&gt;.</p>
<p>function <strong>SetOnChangeSelection</strong> (ctx, function)</p>
<p>Establece la llamada a la función que se invoca cuando la lista cambia su selección. El parámetro &lt;ctx&gt; es el contexto y el &lt;function&gt; es el nombre de la función dentro del contexto.</p>
<p>function <strong>SetOnItemDoubleClick</strong> (ctx, function)</p>
<p>Establece la llamada a la función que se invoca cuando se hace doble clic sobre un elemento de la lista. El parámetro &lt;ctx&gt; es el contexto y el &lt;function&gt; es el nombre de la función dentro del contexto.</p>
<p>function <strong>GetSelectedUserData</strong> () : pointer</p>
<p>Devuelve los datos de usuario asociados al elemento seleccionado actualmente. En caso de no existir selección, devolverá NULL. Funciona solo para selección simple.</p>
<p>function <strong>GetSelectedText</strong> () : string</p>
<p>Obtiene el texto asociado al elemento seleccionado actualmente. En caso de no existir selección, devolverá NULL. Funciona solo para selección simple.</p>
<p>function <strong>GetNumItems</strong> () : int</p>
<p>Obtiene el número de elementos en la lista.</p>
<p>function <strong>SetDefaultTextColor</strong> ()</p>
<p>Determina el color por defecto para el texto de la lista.</p>
<p>function <strong>GetDefaultTextColor</strong> () : int</p>
<p>Obtiene el color por defecto para el texto de la lista.</p>
<p>function <strong>SetSelectionColor</strong> (colorfg, colorbg)</p>
<p>Establece el color de texto &lt;colorfg&gt; y de fondo &lt;colorbg&gt; para la selección de un elemento.</p>
<p>function <strong>GetSelectionColor</strong> () : list</p>
<p>Retorna una lista con dos valores, [colorfg, colorbg], correspondientes al color de texto y color de fondo utilizados en la selección de un elemento.</p>
<h2 id="progressbar">ProgressBar</h2>
<p>Permite representar visualmente, tanto en vertical como en horizontal, el progreso de un valor dentro de un rango.</p>
<p>function <strong>SetMinValue</strong> (value)</p>
<p>Determina el valor mínimo a considerar en el rango de valores dentro de una barra de progreso.</p>
<p>function <strong>SetMaxValue</strong> (value)</p>
<p>Determina el valor máximo a considerar en el rango de valores dentro de una barra de progreso.</p>
<p>function <strong>SetValue</strong> (value)</p>
<p>Establece un valor dentro del rango establecido. Si &lt;value&gt; está fuera de rango, este se ajustará al mínimo y máximo establecidos.</p>
<p>function <strong>GetValue</strong> () : float</p>
<p>Retorna el valor establecido en el control de progreso.</p>
<p>function <strong>SetInvertChunkDirection</strong> (value)</p>
<p>Invierte la forma de rellenarse la barra de progreso. Por defecto de izquierda a derecha.</p>
<p>function <strong>SetDirectionLayout</strong> (direction)</p>
<p>Indica si la barra de progreso es vertical u horizontal. El parámetro dirección podrá ser UI_VERTICAL o UI_HORIZONTAL.</p>
<h2 id="richtexteditor">RichTextEditor</h2>
<p>Caja de edición de texto enriquecido. Permite la edición de texto con diferentes estilos, colores, agregar imágenes, etc. No solo admite texto simple, también hipertexto para poder hacer uso de todas estas funcionalidades.</p>
<p>function <strong>GetDefaultFont</strong> () : pointer</p>
<p>Retorna el puntero a la fuente por defecto.</p>
<p>function <strong>GetBGColor</strong> () : int</p>
<p>Devuelve el color usado como fondo en el editor.</p>
<p>function <strong>GetFGColor</strong> () : int</p>
<p>Devuelve el color usado para el texto en el editor.</p>
<p>function <strong>SetReadOnly</strong> (v)</p>
<p>Permite establecer como de solo lectura el editor; por tanto, no será viable ninguna acción de modificación de texto. Igualmente, el cursor del editor será visible y navegable y podremos movernos por el editor de forma normal.</p>
<p>function <strong>GetReadOnly</strong> () : bool</p>
<p>Indica si el editor está funcionando en modo solo lectura.</p>
<p>function <strong>SetWordWrap</strong> (v)</p>
<p>Permite aplicar el recorte de palabras una vez el texto alcanza el límite horizontal. De este modo, las palabras que quedan fuera del tamaño del control pasan a la siguiente línea de texto.</p>
<p>function <strong>SetEditable</strong> (v)</p>
<p>Permite establecer el editor en modo edición o en modo visualización. En modo edición, el cursor es visible y podemos navegar por el editor de forma normal.</p>
<p>function <strong>SetModified</strong> (v)</p>
<p>Activa o desactiva la bandera de texto modificado.</p>
<p>function <strong>IsModified</strong> () : bool</p>
<p>Indica si la bandera de texto modificado está activa.</p>
<p>function <strong>ShowLineNumber</strong> ()</p>
<p>Muestra los números de línea en el editor.</p>
<p>function <strong>HideLineNumber</strong> ()</p>
<p>Oculta los números de línea en el editor.</p>
<p>function <strong>IsLineNumber</strong> () : bool</p>
<p>Indica si los números de línea se están mostrando en el editor.</p>
<p>function <strong>InsertText</strong> (text, pos = -1)</p>
<p>Inserta un texto &lt;text&gt; en la posición &lt;pos&gt; que indiquemos. Cuando &lt;pos&gt; es -1, indicamos que lo haga en la posición del cursor de texto actual. Esta acción no desplaza la posición del cursor de texto.</p>
<p>function <strong>SetText</strong> (text, htmlMode = false)</p>
<p>Asigna un texto &lt;text&gt; al control editor. El texto podrá estár en formato extendido o texto plano según el valor de &lt;htmlMode&gt;. En el texto con formato extendido, se considerarán palabras reservadas dentro del propio texto que vengan en formato HTML, por ejemplo: &lt;p&gt;Esto es un párrafo&lt;/p&gt;</p>
<p>function <strong>SetCursorPos</strong> (pos)</p>
<p>Mueve el cursor de texto a la nueva posición &lt;pos&gt;.</p>
<p>function <strong>GetCursorPos</strong> () : int</p>
<p>Obtiene la posición actual del cursor de texto.</p>
<p>function <strong>SetCursorLine</strong> (line)</p>
<p>Mueve el cursor a la primera posición del texto en la línea &lt;line&gt;.</p>
<p>function <strong>GetCursorLine</strong> () : int</p>
<p>Obtiene el número de línea en la que se encuentra el cursor de texto.</p>
<p>function <strong>GetCursorLinePos</strong> ()</p>
<p>Obtiene la posición del primer carácter de la línea en la que se encuentra el cursor de texto.</p>
<p>function <strong>GetCurrentLineText</strong> () : string</p>
<p>Obtiene el texto de la línea en la que se encuentra el cursor.</p>
<p>function <strong>GetText</strong> (htmlMode = false) : string</p>
<p>Obtiene el texto completo existente en el editor. Devolverá el texto en formato extendido o en texto plano en función del parámetro &lt;htmlMode&gt;.</p>
<p>function <strong>SetOnTextChanged</strong> (ctx, function)</p>
<p>Permite asociar una llamada a función cuando el texto cambia de valor.</p>
<p>function <strong>SetOnChar</strong> (ctx, function)</p>
<p>Permite asociar una llamada a función cuando el texto recibe un carácter.</p>
<p>function <strong>SetOnCursorMoved</strong> (ctx, function)</p>
<p>Permite asociar una llamada a función cuando el cursor cambia de posición en el editor.</p>
<p>function <strong>Undo</strong> ()</p>
<p>Aplica una operación de deshacer en el editor.</p>
<p>function <strong>Redo</strong> ()</p>
<p>Aplica una operación de rehacer en el editor.</p>
<p>function <strong>HasUndo</strong> () : bool</p>
<p>Indica si existe alguna operación de deshacer pendiente.</p>
<p>function <strong>DeleteSelection</strong> ()</p>
<p>Borra el texto existente en una selección.</p>
<p>function <strong>DeleteText</strong> (start, count)</p>
<p>Borra un número de caracteres &lt;count&gt; del editor desde la posición &lt;start&gt;.</p>
<p>function <strong>DeleteLine</strong> (line = -1)</p>
<p>Borra una línea entera del editor. Si &lt;line&gt; es -1, borrará la línea donde se encuentra el cursor de texto.</p>
<p>function <strong>Copy</strong> ()</p>
<p>Aplica una operación de copia de los elementos seleccionados.</p>
<p>function <strong>Paste</strong> ()</p>
<p>Aplica una operación de pegado. Si hay datos copiados, se pegarán a partir de la posición del cursor de texto.</p>
<p>function <strong>Cut</strong> ()</p>
<p>Aplica una operación de corte. Esto es, una copia y un borrado posterior de la selección.</p>
<p>function <strong>SelectWord</strong> ()</p>
<p>Selecciona la siguiente palabra completa a partir de la posición del cursor.</p>
<p>function <strong>ShowSpecialChars</strong> (v)</p>
<p>Muestra los caracteres especiales retorno de carro, tabulador y espacio, con un símbolo junto al resto de elementos del editor de texto.</p>
<p>function <strong>IsSpecialChars</strong> () : bool</p>
<p>Indica si la activación de muestra de caracteres especiales está activa o no.</p>
<p>function <strong>FindText</strong> (textFind, begin = 0, end = -1, cs = false, whole = false, regExp = false, replace = false, replaceText = "") : int</p>
<p>Permite encontrar la posición de un texto a encontrar &lt;textFind&gt; desde una posición inicial &lt;begin&gt; hasta otra final &lt;end&gt;. Podemos indicar si queremos hacer la búsqueda teniendo en cuenta mayúsculas y minúsculas poniendo &lt;cs&gt; a verdadero. También podemos indicar con &lt;whole&gt; si queremos encontrar el texto de forma aislada (con verdadero) o cualquier referencia a una subcadena que lo incluya (con falso). En el caso de que &lt;regExp&gt; sea verdadero, no se considerará &lt;textFind&gt; como una expresión regular. Podemos también indicar si queremos reemplazar las evidencias encontradas por otro texto poniendo &lt;replace&gt; a verdadero y el texto a reemplazar en &lt;replaceText&gt;.</p>
<p>function <strong>SetOnEnterLink</strong> (ctx, function)</p>
<p>Se invocará a la función con nombre &lt;function&gt; del contexto &lt;ctx&gt; cada vez que el cursor pase por encima de un objeto de tipo “link”. La función ha de tener el prototipo function OnEnterLink(_edit, _url);</p>
<p>function <strong>SetOnLeaveLink</strong> (ctx, function)</p>
<p>Se invocará a la función con nombre &lt;function&gt; del contexto &lt;ctx&gt; cada vez que el cursor abandone la zona visual ocupada por un objeto de tipo “link”. La función ha de tener el prototipo: function OnLeaveLink(_edit, _url);</p>
<p>function <strong>GetVerticalScroll</strong> () : float</p>
<p>Obtiene el valor del scroll vertical en formato normalizado (valores de 0 a 1).</p>
<p>function <strong>SetVerticalScroll</strong> (ny)</p>
<p>Asigna la posición del scroll vertical en formato normalizado, por tanto &lt;ny&gt; podrá tener un valor numérico entre 0 y 1.</p>
<h2 id="scrollbar">ScrollBar</h2>
<p>Representa una barra de desplazamiento que puede ser vertical u horizontal, con un botón en cada extremo para para avanzar o retroceder. Recorriendo la barra, un tercer botón permite desplazarse de una forma más directa entre los posibles valores.</p>
<p>function <strong>SetDirectionLayout</strong> (direction)</p>
<p>Establece la orientación a utilizar para la barra de desplazamiento. &lt;direction&gt; podrá valer UI_VERTICAL o UI_HORIZONTAL.</p>
<p>function <strong>GetValue</strong> () : float</p>
<p>Devuelve el valor del estado actual de la barra de desplazamiento. El valor estará comprendido entre el mínimo y el máximo establecidos. Véanse <em>SetMinValue</em> y <em>SetMaxValue</em>.</p>
<p>function <strong>SetValue</strong> (value)</p>
<p>Establece el valor en el que situar la barra de desplazamiento. &lt;value&gt; ha de ser un número entre el valor mínimo y máximo establecidos. Véanse <em>SetMinValue</em> y <em>SetMaxValue</em>.</p>
<p>function <strong>GetValuePctg</strong> () : float</p>
<p>Retorna el valor normalizado (entre 0 y 1) del estado actual de la barra de desplazamiento. En este caso 0 representa al valor mínimo y 1 al máximo.</p>
<p>function <strong>SetValuePctg</strong> (value)</p>
<p>Establece el valor del estado de la barra de desplazamiento mediante &lt;value&gt;, que será un número entre 0 y 1, donde 0 representa al valor mínimo y 1 al máximo.</p>
<p>function <strong>SetMinValue</strong> (value)</p>
<p>Establece el valor mínimo para el conjunto de valores entre los que se puede mover la posición de la barra de desplazamiento.</p>
<p>function <strong>GetMinValue</strong> () : float</p>
<p>Devuelve el valor mínimo establecido para la barra de desplazamiento.</p>
<p>function <strong>SetMaxValue</strong> (value)</p>
<p>Establece el valor máximo para el conjunto de valores entre los que se puede mover la posición de la barra de deplazamiento.</p>
<p>function <strong>GetMaxValue</strong> () : float</p>
<p>Devuelve el valor máximo establecido para la barra de desplazamiento.</p>
<p>function <strong>SetStepValue</strong> (value)</p>
<p>Define el paso con el que avanzar o retroceder en el estado de la barra de desplazamiento. El paso se aplica cuando se pulsa alguno de los botones asociados al control para ir hacia delante o atrás.</p>
<p>function <strong>DoStepDown</strong> ()</p>
<p>Aplica un paso hacia delante, o sea, suma el paso al valor actual de la barra de desplazamiento.</p>
<p>function <strong>DoStepUp</strong> ()</p>
<p>Aplica un paso hacia atrás, o sea, resta el paso al valor actual de la barra de desplazamiento.</p>
<p>function <strong>SetOnChange</strong> (ctx, function)</p>
<p>Invoca a la función con nombre &lt;function&gt; del contexto &lt;ctx&gt; cada vez que el valor de la barra de desplazamiento cambia. El prototipo de la función será:</p>
<pre><code>function OnChange (_sender, _event, _params);</code></pre>
<h2 id="spin">Spin</h2>
<p>Es una caja de texto que representa un valor numérico y dos botones que incrementan o decrementan este valor.</p>
<p>function <strong>SetValue</strong> (v)</p>
<p>Asigna el valor actual del control. Este valor siempre se ajustará al máximo y mínimo establecidos. Por defecto, no hay máximo ni mínimo.</p>
<p>function <strong>SetStepValue</strong> (v)</p>
<p>Establece el paso (incremento/decremento) en el que variará el valor del control cada vez que los apliquemos.</p>
<p>function <strong>SetRange</strong> (min, max)</p>
<p>Establece a la vez los valores mínimo y máximo aceptados por el control.</p>
<p>function <strong>SetMinValue</strong> (min)</p>
<p>Permite establecer el valor mínimo posible en el control. De esta manera, aunque hagamos un <em>SetValue</em> con un valor menor, este se ajustará al mínimo.</p>
<p>function <strong>SetMaxValue</strong> (max)</p>
<p>Permite establecer el valor máximo posible en el control. De esta manera, aunque hagamos un <em>SetValue</em> con un valor mayor, este se ajustará al máximo.</p>
<p>function <strong>GetMinValue</strong> (min) : int</p>
<p>Obtiene el valor mínimo establecido.</p>
<p>function <strong>GetMaxValue</strong> (min) : int</p>
<p>Obtiene el valor máximo establecido.</p>
<h2 id="textbox">TextBox</h2>
<p>Caja donde introducir y manipular texto simple. Se permite la edición tanto en línea simple como en multilínea.</p>
<p>function <strong>SetFontHeight</strong> (h)</p>
<p>Establece el tamaño de la fuente a utilizar en el control.</p>
<p>function <strong>SetBgColor</strong> (c)</p>
<p>Indica qué color usar para el fondo ocupado por el control.</p>
<p>function <strong>RestoreBgColor</strong> ()</p>
<p>Restaura el color del fondo por el correspondiente al tema utilizado.</p>
<p>function <strong>SetOnTextChanged</strong> (ctx, function)</p>
<p>Invoca a la función &lt;function&gt; del contexto &lt;ctx&gt; cada vez que el texto del control modifica su contenido. El prototipo de la función es:</p>
<pre><code>function OnTextChanged (_sender, _event, _params);</code></pre>
<p>function <strong>SetOnChar</strong> (ctx, function)</p>
<p>Invoca a la función &lt;function&gt; del contexto &lt;ctx&gt; cada vez que se agrega algún carácter en el contenido del control. El prototipo de la función es:</p>
<pre><code>function OnChar(_sender, _event, _params);</code></pre>
<p>function <strong>GetValue</strong> () : value</p>
<p>Devolverá el valor del contenido en formato entero, flotante o cadena según se haya establecido el modo. Por defecto el modo es cadena de caracteres.</p>
<p>function <strong>SetValue</strong> (value)</p>
<p>Establecerá el valor del contenido de la caja de texto según se haya establecido que sea entero, flotante o cadena de caracteres.</p>
<p>function <strong>SetIntegerMode</strong> (allowNegative = false)</p>
<p>Establece que el control almacene un valor de tipo entero. Se podrá indicar si se desea operar con enteros negativos o no.</p>
<p>function <strong>SetFloatMode</strong> (allowNegative = false, decimals = 2)</p>
<p>Establece que el control almacene un valor de tipo flotante. Se podrá indicar si se quieren negativos y el número de decimales permitidos.</p>
<p>function <strong>SetTextMode</strong> ()</p>
<p>Establece que el control almacene una cadena de texto.</p>
<p>function <strong>SetEmptyText</strong> (text)</p>
<p>Establece el texto que aparecerá por defecto cuando el valor del control no tiene nada asignado.</p>
<p>function <strong>SetEmptyTextColor</strong> (color)</p>
<p>Establece el color del texto que aparecerá por defecto cuando el valor del control no tiene nada asignado.</p>
<p>function <strong>EnablePassword</strong> (value)</p>
<p>Establece el modo password en el control. Si está activo, todos los caracteres que introduzcamos se visualizarán con el símbolo asterisco.</p>
<p>function <strong>SetMultiLine</strong> (value)</p>
<p>Establece el modo multilínea para el control. Por defecto las cajas de texto se crean en línea simple. En multilínea, hay saltos de línea y se visualiza el texto en varias líneas.</p>
<p>function <strong>GetMultiLine</strong> () : bool</p>
<p>Indica si el control está en modo multilínea o línea simple.</p>
<p>function <strong>SetWordWrap</strong> (value)</p>
<p>Activa el modo de ajuste de palabras en el caso de que el control sea multilínea. En este modo, cuando una palabra no cabe en el ancho visible del control, automáticamente se representa en una nueva línea.</p>
<p>function <strong>GetWordWrap</strong> () : bool</p>
<p>Indica si el ajuste de palabras está activo o no.</p>
<p>function <strong>SetTextAlign</strong> (value)</p>
<p>Permite establecer el modo de alineación del texto en el control. Este podrá ser una combinación de los siguientes valores: DT_LEFT, DT_TOP, DT_CENTER, DT_VCENTER, DT_RIGHT, DT_BOTTOM.</p>
<p>function <strong>SetReadOnly</strong> (value)</p>
<p>Establece el modo de solo lectura en el control. Esto quiere decir que el usuario no podrá modificar el contenido del control de forma interactiva ya que no se admitirán modificaciones. Sí se podrá navegar por el texto, pero no cambiarlo.</p>
<p>function <strong>SetTextColor</strong> (color)</p>
<p>Establece el color que tendrá el texto en el control.</p>
<p>function <strong>GetTextColor</strong> () : int</p>
<p>Obtiene el color que está siendo usado por el texto en el control.</p>
<h2 id="toolbar">ToolBar</h2>
<p>Distribuye una serie de botones (aunque también otro tipo de controles) a modo de menú en la parte superior de la ventana y por debajo de la zona de menú.</p>
<p>function <strong>Clear</strong> ()</p>
<p>Elimina cualquier objeto agregado a la barra de herramientas.</p>
<p>function <strong>SetAutoSize</strong> (value)</p>
<p>Especifica un tamaño a partir del cual la barra de herramientas auto-ajusta las posiciones de los objetos agregados.</p>
<p>function <strong>GetContentSize</strong> () : int</p>
<p>En función de la orientación de la barra de herramientas (vertical u horizontal) devolverá el tamaño reservado para el contenido.</p>
<p>function <strong>SetLeftAlign</strong> ()</p>
<p>Establece una barra de herramientas horizontal y con los objetos ajustados a la izquierda.</p>
<p>function <strong>SetRightAlign</strong> ()</p>
<p>Establece una barra de herramientas horizontal y con los objetos ajustados a la derecha.</p>
<p>function <strong>SetTopAlign</strong> ()</p>
<p>Establece una barra de herramientas vertical y con los objetos ajustados arriba.</p>
<p>function <strong>AddItem</strong> (itemName) : pointer</p>
<p>Añade un objeto a la barra de herramientas. El objeto será de la clase &lt;itemName&gt;. La clase tendrá que heredar de View_UI_Toolbar_Item_Base.</p>
<p>function <strong>AddItemButton</strong> () : pointer</p>
<p>Añade un objeto de tipo Botón a la barra de herramientas.</p>
<p>function <strong>AddItemLabel</strong> () : pointer</p>
<p>Añade un objeto de tipo Etiqueta a la barra de herramientas.</p>
<p>function <strong>AddSeparator</strong> () : pointer</p>
<p>Añade un objeto de tipo Separador a la barra de herramientas.</p>
<h2 id="trackbar">TrackBar</h2>
<p>Este control representa un posicionador con el que podemos seleccionar distintos valores dentro de un rango.</p>
<p>function <strong>SetValue</strong> (v)</p>
<p>Establece el valor comprendido entre un mínimo y máximo establecidos.</p>
<p>function <strong>SetThumbType</strong> (type)</p>
<p>Permite indicar el tipo de posicionador a utilizar. El valor de &lt;type&gt; podrá ser un entero con los valores THUMB_TYPE_POINTER (0) o THUMB_TYPE_BOTH (1).</p>
<p>function <strong>SetOnChange</strong> (ctx, function)</p>
<p>Invoca la función &lt;function&gt; en el contexto &lt;ctx&gt; cada vez que el valor del control cambia.</p>
<p>function <strong>SetOnMove</strong> (ctx, function)</p>
<p>Invoca la función &lt;function&gt; en el contexto &lt;ctx&gt; cada vez que se desplaza el posicionador.</p>
<p>function <strong>SetRange</strong> (min, max)</p>
<p>Establece en una única función los valores mínimo y máximo posibles en el control.</p>
<p>function <strong>SetMinValue</strong> (min)</p>
<p>Permite establecer el valor mínimo posible en el control. De esta manera, aunque hagamos un SetValue con un valor menor, este se ajustará al mínimo.</p>
<p>function <strong>SetMaxValue</strong> (max)</p>
<p>Permite establecer el valor máximo posible en el control. De esta manera, aunque hagamos un SetValue con un valor mayor, este se ajustará al máximo.</p>
<p>function <strong>GetMinValue</strong> (min) : int</p>
<p>Obtiene el valor mínimo establecido.</p>
<p>function <strong>GetMaxValue</strong> (min) : int</p>
<p>Obtiene el valor máximo establecido.</p>
<h2 id="diálogos-genéricos">Diálogos genéricos</h2>
<p>Los diálogos genéricos son aquellos que se ofrecen desde el interfaz <em>GetEngine(),</em> y son accesibles por todas las aplicaciones. Son una herramienta sencilla para realizar acciones de uso genérico.</p>
<p>FileDialog</p>
<p><img src="media/64a561c2e01621931ab864d67d25b34e.png" /></p>
<p>Este tipo de diálogos permiten facilitar la selección de archivos para abrirlos o guardarlos desde una aplicación. Existen por tanto el <em>OpenFileDialog/SaveFileDialog</em> y el <em>OpenFolderDialog</em>/<em>SaveFolderDialog</em>, en función de si queremos leer, escribir o crear archivos y/o carpetas.</p>
<p>Las cuatro funciones usan los mismos parámetros:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 76%" />
<col style="width: 12%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
<col style="width: 0%" />
</colgroup>
<thead>
<tr class="header">
<th>title</th>
<th>Título de la ventana MDI. Por defecto cadena vacía.</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>filename</td>
<td>Valor inicial del campo de texto nombre de archivo. Por defecto cadena vacía.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>folder</td>
<td>Carpeta por defecto donde guardar el archivo. Por defecto cadena vacía.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>filters</td>
<td>Filtros de archivo. Por defecto cadena vacía. Los filtros son una secuencia de cadenas separadas por el carácter ‘|’ y formadas por el binomio Título | comodín. Ejemplos: “PNG Files|*.png”; “Graphic Files|*.png;*.jpg;*.tga|All Files|*.*”</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>flags</td>
<td>SFD_ALLOWMULTISELECT</td>
<td>Permite la multiselección de archivos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>SFD_OVERWRITEPROMPT</td>
<td>No se pide permiso para sobrescribir un archivo. Solo para diálogo de escritura.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>SFD_FILEMUSTEXIST</td>
<td>Obliga a que los archivos seleccionados existan.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>SFD_HIDEREADONLY</td>
<td>No muestra los archivos ocultos.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>ctx</td>
<td>Contexto donde estará la función a invocar una vez aceptemos el guardado.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>function</td>
<td>Función que se invocará para gestionar el guardado. El prototipo de esta función será el siguiente:</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>userdata</td>
<td>Datos de usuario que podremos asociar para que se nos envíen a la función como parámetro.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ismodal</td>
<td>Por defecto a verdadero. Bloquea el uso de otros diálogos y menús y será necesario cerrar el FileDialog para volver a tener acceso al resto del escritorio.</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>function () (fd, files, userdata) { }</code></pre>
<p>Aquí, &lt;fd&gt; hace referencia al controlador del FileDialog. El archivo seleccionado para el guardado vendrá como primer elemento de la lista &lt;files&gt;. Si en la llamada facilitamos datos de usuario, estos nos llegarán a &lt;userdata&gt;.</p>
<h5 id="ejemplo-de-uso">Ejemplo de uso:</h5>
<pre><code>GetEngine().OpenFileDialog(&quot;Open PNG Files&quot;, &quot;&quot;, &quot;&quot;, &quot;PNG Files|*.png|All Files|*.*&quot;, this &quot;OnOpenFile&quot;);

...

function OnOpenFile(_fd, _files, _userData)
{
    _image = GetEngine().LoadImage(_files[0]);</code></pre>
<pre><code>}</code></pre>
<p>AlertDialog</p>
<p><img src="media/bfab40bfa1e275855b1f5908726fde0b.png" /></p>
<p>function <strong>AlertDialog</strong> (title, text, mode = 0, ctx = null, f1 = “OnAlertDialogOK”, f2 = “OnAlertDialogCancel”, f3 = "")</p>
<p>Abre un diálogo de alerta en forma no modal, o sea, no bloquea la ejecución del programa. Un AlertDialog consta de un título &lt;title&gt; que se muestra en la ventana MDI y un texto &lt;text&gt; que ocuparía la zona central de la ventana, y adicionalmente se pueden configurar diferentes modos de funcionamiento de botones mediante &lt;mode&gt;:</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>View.AD_OK</th>
<th>Un botón OK. Se usa &lt;f1&gt;.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>View.AD_CANCEL</td>
<td>Un botón CANCEL. Se usa &lt;f1&gt;.</td>
</tr>
<tr class="even">
<td>View.AD_YES</td>
<td>Un botón YES. Se usa &lt;f1&gt;.</td>
</tr>
<tr class="odd">
<td>View.AD_NO</td>
<td>Un botón NO. Se usa &lt;f1&gt;.</td>
</tr>
<tr class="even">
<td>View.AD_OKCANCEL</td>
<td>Dos botones OK y CANCEL usan &lt;f1&gt; para el OK y &lt;f2&gt; para el CANCEL.</td>
</tr>
<tr class="odd">
<td>View.AD_YESNO</td>
<td>Dos botones YES y NO usan &lt;f1&gt; para el YES y &lt;f2&gt; para el NO.</td>
</tr>
<tr class="even">
<td>View.AD_YESNOCANCEL</td>
<td>Tres botones YES, NO y CANCEL usan &lt;f1&gt; para el YES, &lt;f2&gt; para el NO y &lt;f3&gt; para el CANCEL.</td>
</tr>
</tbody>
</table>
<p>En función del número de botones, podemos usar las diferentes llamadas que recibiremos al hacer clic en los botones. Estas llamadas usan un prototipo como el siguiente:</p>
<pre><code>function OnClick () { }</code></pre>
<p>function <strong>AlertDialogModal</strong> (title, text, mode = 0) : int</p>
<p>Funciona exactamente igual que AlertDialog, salvo que en este caso, la ejecución del programa no continúa hasta que no se cierra el diálogo. Como valor de retorno, obtendremos el ID del botón que se haya pulsado o 0 en caso de cerrar la ventana.</p>
<p>InputDialog</p>
<p><img src="media/f5eaa6c0ece713dca32d6accc43aa3b0.png" /></p>
<p>function <strong>InputDialogModal</strong> (title, text = "", mode = 0) : string</p>
<p>Permite obtener datos introducidos por el usuario. Estos datos se obtendrán como valor de retorno de la función ya que, en este caso, la llamada es modal y por tanto bloqueante: hasta que no se cierra el diálogo no se continúa con la ejecución del programa.</p>
<p>Los parámetros son un título para la ventana MDI &lt;title&gt; y un texto descriptivo opcional para dar más información sobre el texto a introducir. Este texto se borra una vez el usuario escribe algún carácter. Y luego el modo &lt;mode&gt;, que podrá ser:</p>
<table>
<thead>
<tr class="header">
<th>View.AD_OK</th>
<th>Un botón OK.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>View.AD_CANCEL</td>
<td>Un botón CANCEL.</td>
</tr>
<tr class="even">
<td>View.AD_OKCANCEL</td>
<td>Dos botones OK y CANCEL.</td>
</tr>
</tbody>
</table>
<p>Los datos introducidos solo serán devueltos por la función en caso de pulsar sobre el botón de OK. En caso de hacerlo en CANCEL o cerrando la ventana MDI, se devolverá cadena vacía.</p>
<h1 id="programar-una-aplicación-vr-basic">Programar una aplicación VR-BASIC</h1>
<p>Para crear una aplicación hecha en VR-SCRIPT donde se haga uso de los comandos conocidos del VR-BASIC / MSX-BASIC disponemos de la plantilla <em>BASIC_Program</em>.</p>
<p>Este tipo de aplicación crea un contexto gráfico junto al interprete VR-BASIC y le da control para poder hacer uso en exclusiva.</p>
<p>El punto de entrada será:</p>
<pre><code>virtual Start(){}</code></pre>
<p>Los métodos disponibles heredados por la plantilla <em>Basic_Program</em> equivalen en funcionalidad a los vistos en la sección VR-BASIC, y serían los siguientes:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Asc</strong> (str)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Atn</strong> (v)</td>
</tr>
<tr class="even">
<td><strong>Beep</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>Base</strong> (n)</td>
</tr>
<tr class="even">
<td><strong>BaseSet</strong> (n, expr)</td>
</tr>
<tr class="odd">
<td><strong>Bin$</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>Bload</strong> (path, brun, off = 0)</td>
</tr>
<tr class="odd">
<td><strong>Bsave</strong> (path, init, end, start = 0)</td>
</tr>
<tr class="even">
<td><strong>Call</strong> (name, params = []);</td>
</tr>
<tr class="odd">
<td><strong>Cdbl</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>Chr$</strong> (expr)</td>
</tr>
<tr class="odd">
<td><strong>Cint</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>Cls</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>CSng</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>Csrlin</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>Circle</strong> (x, y, rad, color, start_angle = "“, end_angle =”“, aspect_ratio =”")</td>
</tr>
<tr class="even">
<td><strong>Cload</strong> (path, verify)</td>
</tr>
<tr class="odd">
<td><strong>Close</strong> (list)</td>
</tr>
<tr class="even">
<td><strong>Color</strong> (fg = "“, bg =”“, bc =”")</td>
</tr>
<tr class="odd">
<td><strong>ColorNew</strong> ()</td>
</tr>
<tr class="even">
<td><strong>ColorRestore</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>ColorSet</strong> (index, r, g, b)</td>
</tr>
<tr class="even">
<td><strong>ColorSprite</strong> (index, color)</td>
</tr>
<tr class="odd">
<td><strong>ColorSprite$</strong> (index, color)</td>
</tr>
<tr class="even">
<td><strong>Cont</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>CopyVRAMToVRAM</strong> (x1, y1, bStep, x2, y2, pageS, x3, y3, pageD, logOp)</td>
</tr>
<tr class="even">
<td><strong>CopyFileToArray</strong> (src, var)</td>
</tr>
<tr class="odd">
<td><strong>CopyArrayToFile</strong> (var, dst)</td>
</tr>
<tr class="even">
<td><strong>CopyFileToFile</strong> (src, dst)</td>
</tr>
<tr class="odd">
<td><strong>Clear</strong> (size = 0, high = 0)</td>
</tr>
<tr class="even">
<td><strong>Draw</strong> (expr)</td>
</tr>
<tr class="odd">
<td><strong>Dim</strong> (var, dims)</td>
</tr>
<tr class="even">
<td><strong>DefFn</strong> (fName, paramList, expr)</td>
</tr>
<tr class="odd">
<td><strong>DefInt</strong> (varList)</td>
</tr>
<tr class="even">
<td><strong>DefSng</strong> (varList)</td>
</tr>
<tr class="odd">
<td><strong>DefDbl</strong> (varList)</td>
</tr>
<tr class="even">
<td><strong>DefStr</strong> (varList)</td>
</tr>
<tr class="odd">
<td><strong>DefUsr</strong> (num, expr)</td>
</tr>
<tr class="even">
<td><strong>Erl</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>Err</strong> ()</td>
</tr>
<tr class="even">
<td><strong>Error</strong> (num)</td>
</tr>
<tr class="odd">
<td><strong>Let</strong> (var, dimExpr, expr, type = "")</td>
</tr>
<tr class="even">
<td><strong>Motor</strong> (_mode)</td>
</tr>
<tr class="odd">
<td><strong>Mid$</strong> (str, start, len = -1)</td>
</tr>
<tr class="even">
<td><strong>Len</strong> (str)</td>
</tr>
<tr class="odd">
<td><strong>Fix</strong> (num)</td>
</tr>
<tr class="even">
<td><strong>Files</strong> (wildcard)</td>
</tr>
<tr class="odd">
<td><strong>Fn</strong> (name, params)</td>
</tr>
<tr class="even">
<td><strong>Kill</strong> (wildcard)</td>
</tr>
<tr class="odd">
<td><strong>KeyOn</strong> ()</td>
</tr>
<tr class="even">
<td><strong>KeyOff</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>KeyList</strong> ()</td>
</tr>
<tr class="even">
<td><strong>KeySet</strong> (num, str)</td>
</tr>
<tr class="odd">
<td><strong>KeyMode</strong> (num, mode)</td>
</tr>
<tr class="even">
<td><strong>MaxFiles</strong> (num)</td>
</tr>
<tr class="odd">
<td><strong>Fre</strong> (num)</td>
</tr>
<tr class="even">
<td><strong>GetDate</strong> (var, alarm)</td>
</tr>
<tr class="odd">
<td><strong>GetTime</strong> (var, alarm)</td>
</tr>
<tr class="even">
<td><strong>Hex</strong>$ (expr)</td>
</tr>
<tr class="odd">
<td><strong>InStr</strong> (ix, str1, str2)</td>
</tr>
<tr class="even">
<td><strong>InStr</strong> (str1, str2)</td>
</tr>
<tr class="odd">
<td><strong>End</strong> ()</td>
</tr>
<tr class="even">
<td><strong>Inkey</strong>$ ()</td>
</tr>
<tr class="odd">
<td><strong>Inp</strong> (port)</td>
</tr>
<tr class="even">
<td><strong>Input</strong> (file, prompt, list)</td>
</tr>
<tr class="odd">
<td><strong>Input$</strong> (num, file = 0)</td>
</tr>
<tr class="even">
<td><strong>IntervalMode</strong> (mode)</td>
</tr>
<tr class="odd">
<td><strong>Left$</strong> (x, n)</td>
</tr>
<tr class="even">
<td><strong>Locate</strong> (x, y, cursor = false)</td>
</tr>
<tr class="odd">
<td><strong>Line</strong> (x1, y1, x2, y2, color, logOp = 0)</td>
</tr>
<tr class="even">
<td><strong>Line</strong> (bStep1, x1, y1, bStep2, x2, y2, color, bFlag, logOp = 0)</td>
</tr>
<tr class="odd">
<td><strong>LineInput</strong> (file, prompt, var)</td>
</tr>
<tr class="even">
<td><strong>Oct$</strong> (expr)</td>
</tr>
<tr class="odd">
<td><strong>Open</strong> (path, mode, fileNum, len)</td>
</tr>
<tr class="even">
<td><strong>Out</strong> (port, value)</td>
</tr>
<tr class="odd">
<td><strong>Rnd</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>Right$</strong> (x, n)</td>
</tr>
<tr class="odd">
<td><strong>Pad</strong> (n)</td>
</tr>
<tr class="even">
<td><strong>Pdl</strong> (n)</td>
</tr>
<tr class="odd">
<td><strong>Pos</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>Paint</strong> (x, y, color, border_color = "")</td>
</tr>
<tr class="odd">
<td><strong>Paint</strong> (bStep, x, y, color, border_color)</td>
</tr>
<tr class="even">
<td><strong>IsPlaying</strong> (channel)</td>
</tr>
<tr class="odd">
<td><strong>Play</strong> (mode, chList)</td>
</tr>
<tr class="even">
<td><strong>PrintUsing</strong> (file, expr)</td>
</tr>
<tr class="odd">
<td><strong>Print</strong> (file, expr)</td>
</tr>
<tr class="even">
<td><strong>Print</strong> (str)</td>
</tr>
<tr class="odd">
<td><strong>Point</strong> (x, y)</td>
</tr>
<tr class="even">
<td><strong>PSet</strong> (x, y, color)</td>
</tr>
<tr class="odd">
<td><strong>PSet</strong> (bStep, x, y, color)</td>
</tr>
<tr class="even">
<td><strong>Preset</strong> (x, y, color)</td>
</tr>
<tr class="odd">
<td><strong>Preset</strong> (bStep, x, y, color)</td>
</tr>
<tr class="even">
<td><strong>Poke</strong> (addr, v)</td>
</tr>
<tr class="odd">
<td><strong>Peek</strong> (addr)</td>
</tr>
<tr class="even">
<td><strong>PutSprite</strong> (plane, x, y, color, num = "")</td>
</tr>
<tr class="odd">
<td><strong>PutSprite</strong> (plane, bStep, x, y, color, num)</td>
</tr>
<tr class="even">
<td><strong>Screen</strong> (m = "“, spr =”“, click =”“, baud =”“, printer =”“, interlace =”")</td>
</tr>
<tr class="odd">
<td><strong>SetAdjust</strong> (x, y)</td>
</tr>
<tr class="even">
<td><strong>SetPrompt</strong> (prompt)</td>
</tr>
<tr class="odd">
<td><strong>SetPage</strong> (display, active)</td>
</tr>
<tr class="even">
<td><strong>SetScroll</strong> (x, y, m, s)</td>
</tr>
<tr class="odd">
<td><strong>Sgn</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>Space$</strong> (x)</td>
</tr>
<tr class="odd">
<td><strong>Spc</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>Sqr</strong> (x)</td>
</tr>
<tr class="odd">
<td><strong>Str$</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>String$</strong> (n, expr)</td>
</tr>
<tr class="odd">
<td><strong>Stop</strong> ()</td>
</tr>
<tr class="even">
<td><strong>StopMode</strong> (mode)</td>
</tr>
<tr class="odd">
<td><strong>Sound</strong> (reg, value)</td>
</tr>
<tr class="even">
<td><strong>Sprite$</strong> (num, expr)</td>
</tr>
<tr class="odd">
<td><strong>SpriteMode</strong> (mode)</td>
</tr>
<tr class="even">
<td><strong>Strig</strong> (n)</td>
</tr>
<tr class="odd">
<td><strong>StrigMode</strong> (n, mode)</td>
</tr>
<tr class="even">
<td><strong>Stick</strong> (n)</td>
</tr>
<tr class="odd">
<td><strong>Tron</strong> ()</td>
</tr>
<tr class="even">
<td><strong>Troff</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>Tab</strong> (x)</td>
</tr>
<tr class="even">
<td><strong>Time</strong> ()</td>
</tr>
<tr class="odd">
<td><strong>Time</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>Usr</strong> (n, param)</td>
</tr>
<tr class="odd">
<td><strong>Val</strong> (expr)</td>
</tr>
<tr class="even">
<td><strong>VPoke</strong> (addr, value)</td>
</tr>
<tr class="odd">
<td><strong>VPeek</strong> (addr)</td>
</tr>
<tr class="even">
<td><strong>VDP</strong> (reg) : ubyte</td>
</tr>
<tr class="odd">
<td><strong>VDP</strong> (reg, value)</td>
</tr>
<tr class="even">
<td><strong>Width</strong> (x)</td>
</tr>
</tbody>
</table>
<h1 id="programar-una-aplicación-vr-gl">Programar una aplicación VR-GL</h1>
<p>VR-GL es una librería VR-SCRIPT que permite trabajar con gráficos dentro del entorno MSXVR. El concepto de esta librería es trabajar con diferentes tipos de objetos que nos permitan principalmente desarrollar proyectos multimedia como videojuegos, aunque cabe cualquier posibilidad donde gráficos y música interactúen.</p>
<p>Conceptos:</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>CLONACIÓN</th>
<th>Hace referencia a la creación y posterior copia exacta de las propiedades de un objeto original.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>INSTANCIACIÓN</td>
<td>Hace referencia a la creación y posterior copia exacta de algunas propiedades de un objeto original. En este caso, habrá otras propiedades que serán referencia de las del objeto original.</td>
</tr>
<tr class="even">
<td>PROPIEDADES DE ESTADO</td>
<td>Son aquellas propiedades que definen el estado del objeto. Estas propiedades son únicas en todos los objetos.</td>
</tr>
<tr class="odd">
<td>CLASES</td>
<td>Los tipos de clases de objeto de la librería son: GL_Collider, GL_Controller, GL_Mapper, GL_Music, GL_Pad, GL_Route, GL_Script, GL_Sound, GL_Sprite, GL_Stage, GL_Text, GL_Timer. Todos ellos heredan de GL_Object.</td>
</tr>
</tbody>
</table>
<h2 id="gl_program">GL_Program</h2>
<p>Interfaz para la creación de programas que requieren del uso de la librería VR-GL.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>SetBgColor</strong> (color)</p>
<p>Establece un color sólido para el fondo del escenario (véase GL_Stage).</p>
<p>function <strong>SetBackColor</strong> (color)</p>
<p>Establece un color sólido para el fondo de la pantalla.</p>
<p>function <strong>SetBgImage</strong> (path)</p>
<p>Pone como fondo de escenario una imagen (textura) que se carga de un &lt;path&gt; determinado como argumento.</p>
<p>function <strong>Play</strong> ()</p>
<p>Pone en marcha los objetos VR-GL.</p>
<p>function <strong>Stop</strong> ()</p>
<p>Detiene la ejecución de los objetos VR-GL.</p>
<p>function <strong>GetActiveStage</strong> () : pointer</p>
<p>Devuelve el escenario (objeto de tipo GL_Stage) activo.</p>
<p>function <strong>GetOffX</strong> () : int</p>
<p>Devuelve la posición X desde la cual se representan los objetos VR-GL. Por defecto es cero.</p>
<p>function <strong>GetOffY</strong> () : int</p>
<p>Devuelve la posición Y desde la cual se representan los objetos VR-GL. Por defecto es cero.</p>
<p>function <strong>GetResX</strong> () : int</p>
<p>Devuelve la resolución horizontal utilizada para representar los objetos VR-GL. Por defecto es el tamaño horizontal de escritorio (Desktop).</p>
<p>function <strong>GetResY</strong> () : int</p>
<p>Devuelve la resolución vertical utilizada para representar los objetos VR-GL. Por defecto es el tamaño vertical de escritorio (Desktop).</p>
<p>function <strong>CloneObject</strong> (name, obj) : pointer</p>
<p>Permite crear una copia exacta de otro objeto VR-GL &lt;obj&gt; con nombre de instancia &lt;name&gt;.</p>
<p>function <strong>NewObject</strong> (name, className, stage = null) : pointer</p>
<p>Crea un nuevo objeto VR-GL con nombre &lt;name&gt; y del tipo indicado en &lt;className&gt;. Si se pasa NULL en el &lt;stage&gt;, este objeto se creará en la escena activa; en caso contrario, se creará en la instancia de escenario que pasemos. El nombre de clase podrá ser GL_Stage, GL_Sprite, GL_Music, GL_Sound, GL_Pad, etc. o una clase de usuario que herede de GL_Object.</p>
<p>function <strong>NewStage</strong> (name) : pointer</p>
<p>Crea un nuevo objeto Escenario (GL_Stage) con nombre &lt;name&gt;.</p>
<p>function <strong>NewSprite</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Sprite (GL_Sprite) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewText</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Texto (GL_Text) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewMapper</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Mapeador (GL_Mapper) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewRoute</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Ruta (GL_Route) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewController</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Controlador (GL_Controller) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewSound</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Sonido (GL_Sound) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewMusic</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Música (GL_Music) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewTimer</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Temporizador (GL_Timer) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewCollider</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Colisionador (GL_Collider) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>NewPad</strong> (name, stage = null) : pointer</p>
<p>Crea un nuevo objeto Mando (GL_Pad) en la escena que pasemos como parámetro en &lt;stage&gt;. En el caso de que sea NULL, se creará en la escena activa.</p>
<p>function <strong>FindObject</strong> (name, stage = null) : pointer</p>
<p>Busca la instancia de objeto con nombre &lt;name&gt; en la escena &lt;stage&gt; que pasemos como argumento. Si &lt;stage&gt; es NULL buscará en la escena activa.</p>
<p>function <strong>SetResolution</strong> (w, h)</p>
<p>Establece la resolución a utilizar para los objetos GL creados. Por defecto se usa el tamaño del escritorio, pero se puede utilizar otra resolución para crear aplicaciones basadas en otros formatos de pantalla.</p>
<p>function <strong>SetViewScale</strong> (scale)</p>
<p>Aplica una escala a la vista, de manera que podemos aumentar o reducir el formato de los gráficos que salen en pantalla.</p>
<p>function <strong>Trace</strong> (msg)</p>
<p>Genera un mensaje de traza que nos permite una depuración sencilla y rápida.</p>
<p>function <strong>LoadVGS</strong> (name) : pointer</p>
<p>Carga un archivo de tipo GameSaurus en la instancia GL asociada a nuestro programa. Del archivo GameSaurus obtendrá toda la información para inicializarse. De esta forma, es posible plantear un esquema donde el diseñador trabaje con VGS y maquete todo lo necesario para el proyecto, mientras que el programador cree todo lo necesario fuera del VGS para dar comportamiento a los objetos que se usen a nivel de diseño y/o fuera de este.</p>
<p>GameSaurus es una aplicación que permite desarrollar juegos y aplicaciones multimedia usando VR-GL de forma visual en los MSXVR.</p>
<h2 id="gl_object">GL_Object</h2>
<p>Representa el interfaz principal de todos los tipos de objetos con los que puede trabajar la librería VR-GL.</p>
<p>function <strong>GetGL</strong> () : pointer</p>
<p>Obtiene la instancia del objeto VR-GL asociada.</p>
<p>function <strong>GetEngine</strong> () : pointer</p>
<p>Obtiene acceso al motor del sistema.</p>
<p>function <strong>SetName</strong> (name)</p>
<p>Asigna un nombre &lt;name&gt; a la instancia de objeto. No se permiten nombres iguales entre objetos del mismo tipo. En caso de asignar un nombre existente, automáticamente se renombrará con el prefijo "_1".</p>
<p>function <strong>GetName</strong> () : string</p>
<p>Obtiene el nombre asignado.</p>
<p>function <strong>SetUserData</strong> (data)</p>
<p>Asocia datos de usuario a la instancia de objeto.</p>
<p>function <strong>GetUserData</strong> () : pointer</p>
<p>Obtiene los datos de usuario asociados.</p>
<p>function <strong>SetStop</strong> (v)</p>
<p>Establece el estado de parado o no de la instancia. &lt;v&gt; será un valor booleano. Si es verdadero estará parado, y si es falso no.</p>
<p>function <strong>GetStop</strong> () : bool</p>
<p>Devuelve el estado de parado de la instancia.</p>
<p>function <strong>SetVisible</strong> (v)</p>
<p>Establece el estado de visibilidad de la instancia. &lt;v&gt; será un valor booleano. Si es verdadero será visible, y si es falso invisible.</p>
<p>function <strong>GetVisible</strong> () : bool</p>
<p>Obtiene el estado de visibilidad de la instancia.</p>
<p>function <strong>SetPriority</strong> (p)</p>
<p>Establece la prioridad de la instancia de objeto. El valor de la prioridad &lt;p&gt; será un valor flotante y cada objeto implementará este método según corresponda.</p>
<p>function <strong>GetPriority</strong> () : float</p>
<p>Obtiene la prioridad asociada a la instancia.</p>
<p>function <strong>ClearObjects</strong> ()</p>
<p>Borra todos los objetos hijos creados.</p>
<p>function <strong>SetParent</strong> (obj)</p>
<p>Permite establecer un nivel de jerarquía. Con esta función indicamos que el nuevo padre será &lt;obj&gt;. Al realizar esta acción, si ya teníamos un padre, eliminaremos dicha relación para formar parte de la nueva.</p>
<p>function <strong>GetParent</strong> () : pointer</p>
<p>Devuelve el objeto padre, si existe. En caso de no existir devolverá NULL.</p>
<p>function <strong>AddObject</strong> (obj)</p>
<p>Añade un objeto &lt;obj&gt; como hijo.</p>
<p>function <strong>RemoveObject</strong> (obj)</p>
<p>Elimina un objeto &lt;obj&gt; de la lista de hijos.</p>
<p>function <strong>GetObjectOrder</strong> (obj) : int</p>
<p>Devuelve la posición de un objeto &lt;obj&gt; dentro de la lista de hijos. El valor devuelto estará entre 0 y <em>GetNumObjects</em>-1.</p>
<p>function <strong>ChangeObjectOrder</strong> (obj, ix)</p>
<p>Permite intercambiar el orden dentro de la lista de hijos. El parámetro &lt;obj&gt; hace referencia al hijo que queremos mover en la lista y con &lt;ix&gt; indicamos la nueva posición. Esta nueva posición estará entre 0 y <em>GetNumObjects</em>-1.</p>
<p>function <strong>FindObjects</strong> (match, classType = "") : list</p>
<p>Permite buscar objetos dentro de la jerarquía, o sea, entre los hijos y dentro de los hijos. El parámetro &lt;match&gt; permite establecer el patrón de búsqueda. Esta cadena de caracteres podrá ser:</p>
<table>
<thead>
<tr class="header">
<th>&lt;match&gt;*</th>
<th>Nombres que comienzan por &lt;match&gt;</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*&lt;match&gt;</td>
<td>Nombres que acaban por &lt;match&gt;</td>
</tr>
<tr class="even">
<td>*&lt;match&gt;*</td>
<td>Nombres que contienen &lt;match&gt;</td>
</tr>
<tr class="odd">
<td>&lt;match&gt;</td>
<td>Nombre exactamente igual a &lt;match&gt;</td>
</tr>
</tbody>
</table>
<p>Por ejemplo:</p>
<pre><code>_list = _obj.FindObjects(&quot;*trol*&quot;);</code></pre>
<p>En el parámetro &lt;classtype&gt; podemos indicar sobre qué clase de objetos queremos aplicar la búsqueda, por ejemplo: “GL_Sprite” o “GL_Sound”.</p>
<p>function <strong>DeleteObjects</strong> (match, classType = "")</p>
<p>Aplicando el mismo criterio de búsqueda que <em>FindObjects,</em> borra todos los objetos que cumplan dicho patrón.</p>
<p>function <strong>FindObject</strong> (name, classType = "") : pointer</p>
<p>Busca un objeto hijo, o dentro de los hijos, que tenga de nombre &lt;name&gt; y sea de la clase &lt;classType&gt; a buscar. En caso de que no se especifique el tipo de clase, se buscará entre todos los existentes.</p>
<p>function <strong>GetObjectNameList</strong> () : list</p>
<p>Devuelve una lista con los nombres de todos los objetos hijos de primer nivel.</p>
<p>function <strong>NewObject</strong> (name, classType) : pointer</p>
<p>Crea un objeto hijo con nombre &lt;name&gt; y de tipo &lt;classType&gt;. Las clases han de heredar siempre de GL_Object. Podrán ser las ofrecidas por la librería (GL_Sprite, GL_Sound, GL_Route, etc.) o creadas por el usuario siempre que estén accesibles.</p>
<p>function <strong>NewXRefObject</strong> (name, xref) : pointer</p>
<p>Permite crear un objecto hijo con nombre &lt;name&gt; y referenciando a un script externo (XREF). El parámetro &lt;xref&gt; será la ruta completa a dicho script y, este ha de heredar su comportamiento de GL_Object.</p>
<p>function <strong>GetXRef</strong> () : pointer</p>
<p>Devuelve la ruta completa de un objeto XREF. Si el objeto no es XREF devolverá cadena vacía.</p>
<p>function <strong>IsXRef</strong> () : bool</p>
<p>Indica si el objeto es XREF o no.</p>
<p>function <strong>CloneChilds</strong> (name, obj) : bool</p>
<p>Permite crear hijos clonados de los hijos del objeto &lt;obj&gt;. Estos nuevos hijos tendrán como nombre el prefijo &lt;name&gt; más el nombre del objeto clonado. En caso de que la clonación haya tenido éxito, la función devolverá verdadero.</p>
<p>function <strong>CloneObject</strong> (name, obj) : pointer</p>
<p>Dado un objeto &lt;obj&gt;, se clonará como hijo y se le asignará el nombre &lt;name&gt;. La clonación es una copia exacta del original.</p>
<p>function <strong>InstancedObject</strong> (name, obj) : pointer</p>
<p>Permite crear una instanciación del objeto &lt;obj&gt; y con nombre &lt;name&gt;. En este caso, el nuevo objeto hijo estará instanciado de &lt;obj&gt; y por tanto &lt;obj&gt; será su objeto original, con el que compartirá algunas propiedades.</p>
<p>function <strong>GetInstancedObject</strong> () : pointer</p>
<p>En el caso de que seamos un objeto instanciado, devolverá el objeto original. En caso contrario, se devolverá NULL.</p>
<p>function <strong>RemoveInstancedObject</strong> ()</p>
<p>Permite dejar de ser objeto instanciado, en caso de estarlo.</p>
<p>function <strong>CopyObject</strong> (obj)</p>
<p>Aplica una copia de propiedades del objeto &lt;obj&gt;. El nombre se conservará.</p>
<p>function <strong>DeleteObject</strong> (obj)</p>
<p>Elimina el objeto &lt;obj&gt;. En este caso &lt;obj&gt; puede ser hijo o no.</p>
<p>function <strong>OrderToFront</strong> ()</p>
<p>Posiciona al objeto por delante de sus hermanos. Todos los objetos tienen una lista de objetos hijos; en este caso, es la lista de objetos del padre la que se reordena.</p>
<p>function <strong>OrderToBack</strong> ()</p>
<p>Posiciona al objeto por detrás de sus hermanos. Todos los objetos tienen una lista de objetos hijos; en este caso, es la lista de objetos del padre la que se reordena.</p>
<p>function <strong>GetNumObjects</strong> (classType = "")</p>
<p>Devuelve el número de objetos hijos que hay. Si indicamos en &lt;classType&gt; algún nombre de clase, contaremos solo los de dicha clase.</p>
<p>function <strong>GetObject</strong> (ix, classType = "") : pointer</p>
<p>Devuelve el objeto hijo en la posición &lt;ix&gt;. Este índice dependerá del &lt;classType&gt; establecido. El índice &lt;ix&gt; será siempre un entero que irá de 0 hasta <em>GetNumObjects(classType)-1</em>.</p>
<p>function <strong>GetObjects</strong> (classType = "", recursive = false) : list</p>
<p>Devuelve todos los objetos hijos en una lista. Se puede considerar que sean solo los hijos de primer nivel o también los hijos de los hijos si indicamos &lt;recursive&gt; a verdadero. Podemos también filtrar por tipo de clase &lt;classType&gt;.</p>
<p>function <strong>BroadcastToObjects</strong> (callName, params = [], classType = "")</p>
<p>Permite aplicar una llamada &lt;callName&gt; a todos los objetos hijos. A esta llamada se le pueden pasar parámetros y también filtrar por &lt;classType&gt;.</p>
<p>Por ejemplo:</p>
<pre><code>_obj.BroadcastToObjects(&quot;DoExplossion&quot;, [-20], &quot;Enemy&quot;);</code></pre>
<p>function <strong>IsRunning</strong> () : bool</p>
<p>Permite saber si un objeto está en marcha. O sea, si se ha realizado un Start.</p>
<p>function <strong>Start</strong> ()</p>
<p>Permite activar un objeto y ponerlo en marcha. Antes de activarse guarda su estado para poder restaurarlo tras un Stop.</p>
<p>function <strong>Stop</strong> ()</p>
<p>Desactiva un objeto que está en marcha y restaura su estado previo al Start.</p>
<p>function <strong>Pause</strong> ()</p>
<p>Detiene la ejecución de un objeto que esté en marcha, y la de sus hijos.</p>
<p>function <strong>PauseObjects</strong> ()</p>
<p>Detiene la ejecución de los hijos.</p>
<p>function <strong>Resume</strong> ()</p>
<p>Activa de nuevo la ejecución de un objeto y la de sus hijos.</p>
<p>function <strong>ResumeObjects</strong> ()</p>
<p>Activa la ejecución de los hijos.</p>
<p>function <strong>SaveState</strong> () : list</p>
<p>Devuelve una lista con pares nombre/valor de todas las propiedades del objeto. Esta lista contiene el estado actual del objeto.</p>
<p>function <strong>LoadState</strong> (st)</p>
<p>Permite cargar el estado guardado en &lt;st&gt; en el objeto.</p>
<p>function <strong>GetBehaviourClassScript</strong> () : string</p>
<p>Devuelve una cadena de texto con el script completo asociado al comportamiento del objeto. Este incluye el interfaz y el código.</p>
<p>function <strong>SetScriptInterface</strong> (name)</p>
<p>Establece el nombre del interfaz de script a utilizar.</p>
<p>function <strong>GetScriptInterface</strong> () : string</p>
<p>Devuelve el nombre del interfaz de script asociado.</p>
<p>function <strong>SetScript</strong> (code)</p>
<p>Define la cadena de texto con script &lt;code&gt; a utilizar como código.</p>
<p>function <strong>GetScript</strong> () : string</p>
<p>Retorna la cadena de texto que hace referencia al script de código.</p>
<p>function <strong>GetClass</strong> () : pointer</p>
<p>Devuelve el objeto que hace referencia al script asociado al comportamiento.</p>
<h2 id="gl_stage">GL_Stage</h2>
<p>Una escena es un tipo de objeto GL que representa a un conjunto de objetos que podrán representarse visualmente o no. La escena tiene la capacidad de gestionar la visualización de todos sus objetos hijos, además de coordinar su activación y desactivación, entre otras funcionalidades.</p>
<p>Una escena dispone de un VIEWPORT o área de representación. Es como se establece la forma y el aspecto con los que queremos representar los objetos visibles en pantalla. El área de representación muestra lo que está viendo la cámara en ese momento. La cámara puede modificarse para poder gestionar dónde y cuánto representar.</p>
<p><img src="media/1ddf3a61520c38a37b957a9920c008f7.png" /></p>
<p>El área de CLIPPING de la cámara (zona amarilla) es el área en el que los objetos se activan o desactivan.</p>
<p>El área de VIEWPORT (zona verde) es lo que visualizamos en pantalla.</p>
<p>Existe otra área llamada SCISSOR (tijeras) que permite visualizar solo el subrectángulo que queramos del área de VIEWPORT. Por defecto, esta área es igual al VIEWPORT.</p>
<p>Solo una escena puede activarse al mismo tiempo. Para poder tener varias escenas activas, estas han de ser GLOBALES. Una escena global siempre está activa.</p>
<p>Los objetos visibles en una escena podrán ser todos aquellos que heredan de GL_Sprite. En este caso: GL_Sprite, GL_Mapper y GL_Text.</p>
<p>Una escena también puede ser principal (MAIN STAGE). Eso quiere decir que cuando se inicia VR-GL (GL_Program::Start), la escena que se lanza en primer lugar es esta.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>LoadTexture</strong> (path) : pointer</p>
<p>Carga y devuelve una textura de una ruta.</p>
<p>function <strong>DeleteTexture</strong> (tex)</p>
<p>Borra una textura previamente cargada.</p>
<p>function <strong>SetActive</strong> ()</p>
<p>Activa la escena.</p>
<p>function <strong>GetActive</strong> () : bool</p>
<p>Indica si la escena está activa.</p>
<p>function <strong>SetViewport</strong> (x, y, w, h)</p>
<p>Establece el área de visión para la escena. Por defecto será el tamaño de la pantalla, pero se puede establecer un offset (x, y) de origen y un tamaño (w, h) distintos.</p>
<p>function <strong>GetViewport</strong> () : list</p>
<p>Devuelve una lista con cuatro componentes: [x, y, w, h].</p>
<p>function <strong>SetViewportX</strong> (x)</p>
<p>Establece el origen horizontal del área de visión de la escena.</p>
<p>function <strong>GetViewportX</strong> () : int</p>
<p>Obtiene el origen horizontal del área de visión de la escena. Por defecto cero.</p>
<p>function <strong>SetViewportY</strong> (y)</p>
<p>Establece el origen vertical del área de visión de la escena.</p>
<p>function <strong>GetViewportY</strong> () : int</p>
<p>Obtiene el origen vertical del área de visión de la escena. Por defecto cero.</p>
<p>function <strong>SetViewportW</strong> (w)</p>
<p>Establece el ancho del área de visión de la escena.</p>
<p>function <strong>GetViewportW</strong> () : int</p>
<p>Obtiene el ancho del área de visión de la escena. Por defecto el ancho del escritorio.</p>
<p>function <strong>SetViewportH</strong> (h)</p>
<p>Establece el alto del área de visión de la escena.</p>
<p>function <strong>GetViewportH</strong> () : int</p>
<p>Obtiene el alto del área de visión de la escena. Por defecto el alto del escritorio.</p>
<p>function <strong>SetViewScale</strong> (scale)</p>
<p>Establece un factor de escala en la vista. Por defecto este valor es 1, que representa que la vista se muestra a su escala original.</p>
<p>function <strong>GetViewScale</strong> () : float</p>
<p>Obtiene el factor de escala asociado a la vista.</p>
<p>function <strong>SetCameraClipX</strong> (x)</p>
<p>Establece el offset relativo a la posición de la cámara en el que considerar la zona de CLIPPING por la izquierda.</p>
<p>function <strong>GetCameraClipX</strong> () : int</p>
<p>Obtiene el offset relativo a la posición de la cámara del área de CLIPPING por la izquierda.</p>
<p>function <strong>SetCameraClipY</strong> (y)</p>
<p>Establece el offset relativo a la posición de la cámara en el que considerar la zona de CLIPPING por arriba.</p>
<p>function <strong>GetCameraClipY</strong> () : int</p>
<p>Obtiene el offset relativo a la posición de la cámara del área de CLIPPING por arriba.</p>
<p>function <strong>SetCameraClipW</strong> (w)</p>
<p>Establece el ancho de la zona del área de CLIPPING.</p>
<p>function <strong>GetCameraClipW</strong> () : int</p>
<p>Obtiene el ancho de la zona del área de CLIPPING.</p>
<p>function <strong>SetCameraClipH</strong> (h)</p>
<p>Establece el alto de la zona del área de CLIPPING.</p>
<p>function <strong>GetCameraClipH</strong> () : int</p>
<p>Obtiene el alto de la zona del área de CLIPPING.</p>
<p>function <strong>SetCameraX</strong> (x)</p>
<p>Asigna la posición horizontal de la cámara.</p>
<p>function <strong>GetCameraX</strong> () : float</p>
<p>Obtiene la posición horizontal de la cámara.</p>
<p>function <strong>SetCameraY</strong> (y)</p>
<p>Asigna la posición vertical de la cámara.</p>
<p>function <strong>GetCameraY</strong> () : float</p>
<p>Obtiene la posición vertical de la cámara.</p>
<p>function <strong>SetCameraPos</strong> (x, y)</p>
<p>Asigna la posición vertical y horizontal de la cámara.</p>
<p>function <strong>IncCameraPos</strong> (x, y)</p>
<p>Incrementa la posición vertical y horizontal de la cámara.</p>
<p>function <strong>SetCameraZoom</strong> (z)</p>
<p>Asigna el escalado del área de cámara. El parámetro &lt;z&gt; por defecto vale 1.</p>
<p>function <strong>GetCameraZoom</strong> () : float</p>
<p>Obtiene el escalado del área de cámara.</p>
<p>function <strong>SetScissorEnabled</strong> (v)</p>
<p>Permite activar el recorte de dibujado en la zona de VIEWPORT.</p>
<p>function <strong>GetScissorEnabled</strong> () : bool</p>
<p>Indica si el recorte de dibujado está activo o no.</p>
<p>function <strong>SetScissorX</strong> (x)</p>
<p>Asigna la posición superior horizontal del rectángulo de recorte.</p>
<p>function <strong>GetScissorX</strong> () : int</p>
<p>Obtiene la posición superior horizontal del rectángulo de recorte.</p>
<p>function <strong>SetScissorY</strong> (y)</p>
<p>Asigna la posición superior vertical del rectángulo de recorte.</p>
<p>function <strong>GetScissorY</strong> () : int</p>
<p>Obtiene la posición superior vertical del rectángulo de recorte.</p>
<p>function <strong>SetScissorW</strong> (w)</p>
<p>Establece el ancho del rectángulo de recorte.</p>
<p>function <strong>GetScissorW</strong> () : int</p>
<p>Obtiene el ancho del rectángulo de recorte.</p>
<p>function <strong>SetScissorH</strong> (h)</p>
<p>Establece el alto del rectángulo de recorte.</p>
<p>function <strong>GetScissorH</strong> () : int</p>
<p>Obtiene el alto del rectángulo de recorte.</p>
<p>function <strong>SetGlobal</strong> (v)</p>
<p>Establece la escena como global. En ese caso, siempre estará activa.</p>
<p>function <strong>GetGlobal</strong> () : bool</p>
<p>Indica si la escena es global.</p>
<p>function <strong>SetPhysicsScale</strong> (scale)</p>
<p>Permite establecer la escala para simulación de físicas. En función de la escala, las físicas son más o menos pesadas en cuando a fluidez y velocidad de movimientos, no en cuanto a rendimiento. La escala determina el tamaño de las unidades utilizadas en los parámetros físicos, permitiendo trabajar en metros, centímetros, etc.</p>
<p>function <strong>GetPhysicsScale</strong> () : float</p>
<p>Obtiene el escalado usado para la simulación de físicas.</p>
<p>function <strong>SetPhysicsGravityX</strong> (gx)</p>
<p>Establece la aceleración de gravedad para las físicas en la componente X.</p>
<p>function <strong>GetPhysicsGravityX</strong> () : float</p>
<p>Obtiene la aceleración de la gravedad para las físicas en la componente X.</p>
<p>function <strong>SetPhysicsGravityY</strong> (gy)</p>
<p>Establece la aceleración de gravedad para las físicas en la componente Y. Esta unidad se indica en m/s2, por ejemplo 9,8.</p>
<p>function <strong>GetPhysicsGravityY</strong> () : float</p>
<p>Obtiene la aceleración de la gravedad para las físicas en la componente Y.</p>
<p>function <strong>CheckCollision</strong> (x, y, w, h) : list</p>
<p>Devuelve una lista con objetos que tengan colisión con el área con posición (x, y) y tamaño (w, h). Para que un objeto colisione debe heredar de GL_Sprite y tener la detección de colisiones activada.</p>
<p>function <strong>GetMain</strong> () : bool</p>
<p>Indica si esta escena es una escena principal.</p>
<p>function <strong>EnableDraw</strong> (v)</p>
<p>Permite indicar si queremos que la escena se visualice o no. Si se desactiva, incluso una escena visible no se representará.</p>
<p>function <strong>LinkCamera</strong> (obj, offx = 0, offy = 0)</p>
<p>Permite que la cámara de la escena siga a un objeto &lt;obj&gt; y lo haga en base a su posición con un desplazamiento (offx, offy).</p>
<h2 id="gl_sprite">GL_Sprite</h2>
<p>Un Sprite es una o varias texturas (imágenes) que pueden combinarse en forma de animación y que permite gestionar propiedades de visibilidad, físicas y colisión.</p>
<p>Conceptos:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Fotograma (Frame)</th>
<th>Textura asociada al Sprite. Un Sprite puede tener ninguna, una o varias.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Animación</td>
<td>Conjunto continuo de fotogramas que, representado a una velocidad, permite establecer una secuencia animada.</td>
</tr>
<tr class="even">
<td>Colisión</td>
<td>Los Sprites puede gestionar colisiones entre ellos, o sea, definir zonas de contacto que luego el sistema puede detectar.</td>
</tr>
<tr class="odd">
<td>Posición</td>
<td>Los Sprites se posicionan en unas coordenadas (x, y) dentro de un escenario. Estas coordenadas hacen referencia a la esquina superior/arriba del rectángulo que ocupan.</td>
</tr>
</tbody>
</table>
<p>Los métodos disponibles son:</p>
<p>function <strong>AddFrame</strong> (path, w = -1, h = -1, x = 0, y = 0, uvx = 0, uvy = 0, uvw = 1, uvh = 1)</p>
<p>Añade una textura como fotograma al Sprite. Indicaremos la ruta a la textura con &lt;path&gt;. El resto de parámetros son opcionales y tienen la siguiente funcionalidad:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>w</th>
<th>Ancho con el que representaremos el fotograma. Si indicamos -1 usaremos el ancho existente en la imagen.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h</td>
<td>Alto con el que representaremos el fotograma. Si indicamos -1 usaremos el alto existente en la imagen.</td>
</tr>
<tr class="even">
<td>x</td>
<td>Desplazamiento horizontal con respecto a la posición del Sprite cuando se representa este fotograma.</td>
</tr>
<tr class="odd">
<td>y</td>
<td>Desplazamiento vertical con respecto a la posición del Sprite cuando se representa este fotograma.</td>
</tr>
<tr class="even">
<td>uvx,uvy,uvw,uvh</td>
<td>Coordenadas normalizadas de textura. Es posible indicar si el fotograma a considerarse es un subrectángulo dentro de la textura. Por defecto es la totalidad de la textura (0, 0, 1, 1).</td>
</tr>
</tbody>
</table>
<p>function <strong>AddEmptyFrame</strong> (_w = -1, _h = -1)</p>
<p>Añade un fotograma sin textura al Sprite. Este fotograma usará el color asociado al Sprite por defecto (véase <em>SetColor</em>). Los parámetros opcionales &lt;w&gt; y &lt;h&gt; definirán el tamaño del fotograma en pixeles. Si no definimos alguno, se usará <em>GetWidth</em> o <em>GetHeight</em> en cada caso.</p>
<p>function <strong>GetFrameTexture</strong> (ix) : pointer</p>
<p>Devolverá la textura asociada a un fotograma. En caso de indicar un &lt;ix&gt; fuera de rango, la función devolverá NULL.</p>
<p>function <strong>GetNumFrames</strong> () : int</p>
<p>Retorna el número de fotogramas que tiene el Sprite.</p>
<p>function <strong>GetFrameInfo</strong> (ix) : list</p>
<p>Dado un índice a fotograma entre 0 y <em>GetNumFrames-</em>1, nos permite obtener la información asociada al mismo. La lista devuelta contendrá: [tex, uvx, uvy, uvw, uvh, addru, addrv, filter, x, y, w, h, cx, cy, cw, ch].</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>tex</th>
<th>Textura asociada.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>uvx, uvy, uvw, uvh</td>
<td>Coordenadas de textura.</td>
</tr>
<tr class="even">
<td>addru, addrv</td>
<td>Mapeado de textura. Por defecto es CLAMP, pero se puede utilizar WRAP para simular repeticiones. Esto se puede hacer para la dirección horizontal como para la vertical independientemente.</td>
</tr>
<tr class="odd">
<td>filter</td>
<td>Indica si se usa filtro bilinear o por aproximación.</td>
</tr>
<tr class="even">
<td>cx, cy, cw, ch</td>
<td>Indica la zona de colisión dentro de la textura.</td>
</tr>
</tbody>
</table>
<p>function <strong>RemoveAnimations</strong> ()</p>
<p>Elmina todas las animaciones asociadas. Esto implicará el borrado de todos los fotogramas asociados.</p>
<p>function <strong>RemoveAnimation</strong> (ani)</p>
<p>Elimina una animación &lt;ani&gt; pasada como parámetro. Esto implica eliminar los fotogramas asociados a dicha animación.</p>
<p>function <strong>RemoveFrames</strong> ()</p>
<p>Elimina todos los fotogramas asociados y, por tanto, todas las animaciones.</p>
<p>function <strong>AddAnimation</strong> (name, start, end, loop, speed) : pointer</p>
<p>Crea y añade una animación con nombre &lt;name&gt;, con fotograma inicial &lt;start&gt; hasta el fotograma final &lt;end&gt;. El número de fotograma será un entero que irá desde 0 hasta GetNumFrames-1 y el fotograma inicial ha de ser menor o igual al final. Indicaremos también el índice al fotograma al cual saltar para hacer un bucle &lt;loop&gt; o podemos usar -1 para indicar que es un bucle infinito &lt;start&gt; - &lt;end&gt; o usar -2 para indicar que queremos detenernos en el final. Por último, indicar la velocidad de transición entre fotogramas &lt;speed&gt;.</p>
<p>function <strong>AddAnimationWithSheet</strong> (name, path, start, end, ox, oy, sheetW, sheetH, w = -1, h = -1, loop = -1, speed = 0.25f, framestep = 1)</p>
<p>Añade una animación con nombre &lt;name&gt; en el Sprite. La fuente de la animación será una textura accesible en la ruta &lt;path&gt; y de esta textura se extraerán los fotogramas desde &lt;start&gt; inicio hasta &lt;end&gt; final. La forma de extraer los fotogramas es subdividiendo la textura en fragmentos de tamaño (sheetW, sheetH) a partir del offset en pixeles (ox, oy). Al aplicar esta cuadrícula, de arriba abajo y de izquierda a derecha tenemos los fotogramas del 0 al (TEXW/SHEETW * TEXH/SHEETH)-1.</p>
<p>El resto de parámetros son el tamaño (alto y ancho) a utilizar visualmente en esos fotogramas, el fotograma inicial del ciclo, la velocidad de animación y si queremos evitar fotogramas.</p>
<p>function <strong>AddAnimationWithGrid</strong> (name, path, gw, gh, list = [], w = -1, h = -1, loop = -1, speed = 0.25f, framestep = 1)</p>
<p>Añade una animación con nombre &lt;name&gt; en el Sprite. La fuente de la animación será una textura accesible en la ruta &lt;path&gt;. De esta textura se extraerán los fotogramas que vamos a tener en cuenta en la animación. Esta forma de crear la animación es similar a <em>AddAnimationWithSheet</em> salvo que aquí, en vez de ser subrectángulos homogéneos, utilizaremos los proporcionados dentro de la lista &lt;list&gt;.</p>
<p>function <strong>AddAnimationWithList</strong> (name, list, w = -1, h = -1, loop = -1, speed = 0.25f, frameStep = 1)</p>
<p>Añade una animación con nombre &lt;name&gt; en el Sprite. Los diferentes fotogramas se obtendrán de una lista de rutas de archivos a texturas. El resto de parámetros funciona igual que en <em>AddAnimationWithSheet</em>.</p>
<p>function <strong>AddAnimationWithPrefix</strong> (name, prefix, start, end, w = -1, h = -1, loop = -1, speed = 0.25f, frameStep = 1)</p>
<p>Añade una animación con nombre &lt;name&gt; en el Sprite. Los diferentes fotogramas se obtienen de aplicar una sustitución utilizando la cadena &lt;prefix&gt; para los valores que van de &lt;start&gt; a &lt;end&gt;. El resto de parámetros funciona igual que en <em>AddAnimationWithSheet</em>.</p>
<p>function <strong>AddAnimationWithPrefixList</strong> (name, prefix, list, w = -1, h = -1, loop = -1, speed = 0.25f, frameStep = 1)</p>
<p>Añade una animación con nombre &lt;name&gt; en el Sprite. Los diferentes fotogramas se obtienen de aplicar una sustitución utilizando la cadena &lt;prefix&gt; para los valores enteros que se encuentra en la lista &lt;list&gt;. El resto de parámetros funciona igual que en <em>AddAnimationWithSheet</em>.</p>
<p>function <strong>SetAnimation</strong> (ani, reset = false)</p>
<p>Permite establecer la animación en curso del Sprite. En este caso podemos indicar en &lt;ani&gt; o en un nombre de animación o bien un puntero a un objeto animación. Si la animación en curso es la que queremos asignar, no se cortará su ejecución ni se reiniciará su estado; sin embargo, si queremos que esto ocurra, habremos de usar &lt;reset&gt; a verdadero.</p>
<p>function <strong>GetNumAnimations</strong> () : int</p>
<p>Devuelve el número de animaciones creadas y disponibles en el Sprite.</p>
<p>function <strong>FindAnimation</strong> (name) : pointer</p>
<p>Busca y retorna una animación en el Sprite con nombre &lt;name&gt;.</p>
<p>function <strong>GetAnimation</strong> (ix = -1) : pointer</p>
<p>Retorna la animación con índice &lt;ix&gt;. Este índice irá de 0 hasta <em>GetNumAnimations</em>-1. En el caso de indicar -1, se devolverá la animación en curso.</p>
<p>function <strong>GetCurAnimation</strong> () : string</p>
<p>Devolverá el nombre de la animación en curso.</p>
<p>function <strong>SetCurAnimation</strong> (name)</p>
<p>Establece la animación en curso de un Sprite especificando el nombre en &lt;name&gt;.</p>
<p>function <strong>ResetAnimation</strong> ()</p>
<p>Reinicia la animación en curso.</p>
<p>function <strong>EndFixAnimation</strong> ()</p>
<p>Deja en su último fotograma la animación en curso.</p>
<p>function <strong>SetAnimationSpeedFactor</strong> (f)</p>
<p>Permite aplicar un factor de velocidad a la animación en curso. Si &lt;f&gt; es cero, la animación se detendrá; si &lt;f&gt; es 1, irá a la velocidad normal que tenga la animación; y si &lt;f&gt; es 2, todo irá al doble de la velocidad.</p>
<p>function <strong>SetType</strong> (flags)</p>
<p>Establece los flags de tipo. Eso permite identificar los Sprites y categorizarlos.</p>
<p>function <strong>GetType</strong> () : int</p>
<p>Obtiene las flags de tipo asociados al Sprite.</p>
<p>function <strong>SetScalePivot</strong> (x, y)</p>
<p>Establece el pivote para el escalado del Sprite. Por defecto es (0, 0), y esto quiere decir que los escalados se aplican a partir de la esquina superior izquierda.</p>
<p>function <strong>SetPivot</strong> (x, y)</p>
<p>Establece el pivote utilizado para la rotación del Sprite. Por defecto es (0, 0), y eso quiere decir que el Sprite rota siempre desde su centro.</p>
<p>function <strong>SetPivotX</strong> (x)</p>
<p>Permite establecer el pivote de rotación en X.</p>
<p>function <strong>GetPivotX</strong> () : float</p>
<p>Obtiene el pivote de rotación en X.</p>
<p>function <strong>SetPivotY</strong> (y)</p>
<p>Permite establece el pivote de rotación en Y.</p>
<p>function <strong>GetPivotY</strong> () : float</p>
<p>Obtiene el pivote de rotación en Y.</p>
<p>function <strong>IncPos</strong> (x, y, updateCamera = false, checkMapper = null)</p>
<p>Desplaza la posición del Sprite en un incremento (x, y). Se puede indicar si queremos actualizar la cámara de la escena donde está el Sprite mediante &lt;updateCamera&gt; y validar colisiones con un objeto Mapper existente &lt;checkMapper&gt;.</p>
<p>function <strong>IncScale</strong> (x, y)</p>
<p>Incrementa la escala en x e y. Equivale a <em>SetScale(GetScaleX()+x, GetScaleY()+y).</em></p>
<p>function <strong>AlignToParent</strong> (flags, offset = 0)</p>
<p>Alinea la posición del Sprite con su padre. Si no tiene Sprite padre, se tendrá en cuenta la resolución de pantalla establecida. Los flags podrán ser una combinación de estos:</p>
<table>
<thead>
<tr class="header">
<th>GL_Sprite.ALIGN_LEFT</th>
<th>Alineación a la izquierda.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GL_Sprite.ALIGN_RIGHT</td>
<td>Alineación a la derecha.</td>
</tr>
<tr class="even">
<td>GL_Sprite.ALIGN_CENTER</td>
<td>Alineación centrada en horizontal.</td>
</tr>
<tr class="odd">
<td>GL_Sprite.ALIGN_VCENTER</td>
<td>Alineación centrada en vertical.</td>
</tr>
<tr class="even">
<td>GL_Sprite.ALIGN_BOTTOM</td>
<td>Alineación en la parte inferior.</td>
</tr>
<tr class="odd">
<td>GL_Sprite.ALIGN_TOP</td>
<td>Alineación en la parte superior.</td>
</tr>
</tbody>
</table>
<p>function <strong>SetPos</strong> (x, y)</p>
<p>Establece la posición origen del Sprite.</p>
<p>function <strong>SetSize</strong> (w, h, resize = false)</p>
<p>Establece el tamaño del Sprite. Hay que tener en cuenta que por defecto &lt;resize&gt; está a falso y no se modifican los tamaños asignados a los fotogramas. Si se quiere que el tamaño pasado como parámetro afecte a todo el Sprite, se ha de usar &lt;resize&gt; a verdadero.</p>
<p>function <strong>SetRect</strong> (x, y, w, h, resize = false)</p>
<p>Establece con una sola llamada tanto posición como tamaño.</p>
<p>function <strong>SetX</strong> (x)</p>
<p>Asigna la posición origen en X.</p>
<p>function <strong>SetY</strong> (y)</p>
<p>Asigna la posición origen en Y.</p>
<p>function <strong>GetX</strong> () : float</p>
<p>Obtiene la posición origen X del Sprite.</p>
<p>function <strong>GetY</strong> () : float</p>
<p>Obtiene la posición origen Y del Sprite.</p>
<p>function <strong>GetXF</strong> () : float</p>
<p>Obtiene la posición origen X final del Sprite. La posición final hace referencia a la que resulta de aplicar todas las transformaciones de padre a hijos.</p>
<p>function <strong>GetYF</strong> () : float</p>
<p>Obtiene la posición origen Y final del Sprite. La posición final hace referencia a la que resulta de aplicar todas las transformaciones de padre a hijos.</p>
<p>function <strong>GetWF</strong> () : float</p>
<p>Obtiene el ancho final del Sprite. La posición final hace referencia a la que resulta de aplicar todas las transformaciones de padre a hijos.</p>
<p>function <strong>GetHF</strong> () : float</p>
<p>Obtiene el alto final del Sprite. La posición final hace referencia a la que resulta de aplicar todas las transformaciones de padre a hijos.</p>
<p>function <strong>GetRF</strong> () : float</p>
<p>Devuelve la coordenada del lado derecho del Sprite. Valor <em>GetXF() + GetWF() - 1.</em></p>
<p>function <strong>GetBF</strong> () : float</p>
<p>Devuelve la coordenada del lado inferior del Sprite. Valor <em>GetYF + GetHF() - 1.</em></p>
<p>function <strong>GetWidth</strong> () : int</p>
<p>Devuelve el ancho del Sprite.</p>
<p>function <strong>SetWidth</strong> (w, resize=0)</p>
<p>Establece el ancho del Sprite y permite indicar si queremos redimensionar el contenido asociado con &lt;resize&gt; a 1 (para hacerlo proporcionalmente en fotogramas, físicas y colisiones) o a 2 (si queremos establecer el nuevo tamaño solo a los fotogramas).</p>
<p>function <strong>GetHeight</strong> () : int</p>
<p>Devuelve el alto del Sprite.</p>
<p>function <strong>SetHeight</strong> (h, resize=0)</p>
<p>Establece el alto del Sprite y permite indicar si queremos redimensionar el contenido asociado con &lt;resize&gt; a 1 (para hacerlo proporcionalmente en fotogramas, físicas y colisiones) o a 2 (si queremos establecer el nuevo tamaño solo a los fotogramas).</p>
<p>function <strong>SetUVX</strong> (x)</p>
<p>Aplica un nuevo origen de coordenada X normalizada a todos los fotogramas.</p>
<p>function <strong>GetUVX</strong> () : float</p>
<p>Obtiene el origen de coordenada X normalizado del primer fotograma. Si no tiene fotogramas devolverá 0.</p>
<p>function <strong>SetUVY</strong> (y)</p>
<p>Aplica un nuevo origen de coordenada Y normalizada a todos los fotogramas.</p>
<p>function <strong>GetUVY</strong> () : float</p>
<p>Obtiene el origen de coordenada Y normalizado del primer fotograma. Si no tiene fotogramas devolverá 0.</p>
<p>function <strong>SetUVW</strong> (w)</p>
<p>Establece un nuevo ancho normalizado a todos los fotogramas.</p>
<p>function <strong>GetUVW</strong> () : float</p>
<p>Obtiene el ancho normalizado del primer fotograma. Si no tiene fotogramas devolverá 0.</p>
<p>function <strong>SetUVH</strong> (h)</p>
<p>Establece un nuevo alto normalizado a todos los fotogramas.</p>
<p>function <strong>GetUVH</strong> () : float</p>
<p>Obtiene el alto normalizado del primer fotograma. Si no tiene fotogramas devolverá 0.</p>
<p>function <strong>SetUV</strong> (u, v, uw, vh)</p>
<p>Establece con una única función todas las coordenadas de textura normalizadas.</p>
<p>function <strong>SetHFlip</strong> (v)</p>
<p>Aplica el efecto de volteo horizontal sobre los fotogramas del Sprite.</p>
<p>function <strong>GetHFlip</strong> () : bool</p>
<p>Indica si está activado el efecto de volteo horizontal.</p>
<p>function <strong>SetVFlip</strong> (v)</p>
<p>Aplica el efecto de volteo vertical sobre los fotogramas del Sprite.</p>
<p>function <strong>GetVFlip</strong> () : bool</p>
<p>Indica si está activado el efecto de volteo vertical.</p>
<p>function <strong>SetScale</strong> (s)</p>
<p>Aplica un factor de escala tanto en vertical como horizontal al Sprite. Por defecto el factor de escala es 1.</p>
<p>function <strong>GetScale</strong> () : float</p>
<p>Obtiene el factor de escala del Sprite.</p>
<p>function <strong>SetScaleX</strong> (s)</p>
<p>Establece un factor de escala en horizontal para el Sprite.</p>
<p>function <strong>GetScaleX</strong> () : float</p>
<p>Obtiene el factor de escala horizontal aplicado al Sprite.</p>
<p>function <strong>SetScaleY</strong> (s)</p>
<p>Establece un factor de escala en vertical para el Sprite.</p>
<p>function <strong>GetScaleY</strong> () : float</p>
<p>Obtiene el factor de escala en vertical aplicado al Sprite.</p>
<p>function <strong>SetCollision</strong> (v)</p>
<p>Permite indicar si queremos que el Sprite forme parte del sistema de detección de colisiones.</p>
<p>function <strong>GetCollision</strong> () : bool</p>
<p>Obtiene verdadero si el Sprite comprueba colisiones.</p>
<p>function <strong>RemoveColliders</strong> ()</p>
<p>Elimina todos los objetos colisionadores asociados al Sprite.</p>
<p>function <strong>AddColliderRect</strong> (x, y, w, h) : pointer</p>
<p>Añade un rectángulo de colisión (colisionador) al Sprite. Mediante estos colisionadores podemos definir áreas de colisión relativas a la posición del Sprite.</p>
<p>function <strong>RemoveColliderByIndex</strong> (ix)</p>
<p>Elimina el colisionador con índice &lt;ix&gt;, que será un entero en el rango 0 a <em>GetNumColliders</em>-1.</p>
<p>function <strong>GetNumColliders</strong> () : int</p>
<p>Obtiene el total de colisionadores que se han creado en el Sprite.</p>
<p>function <strong>GetCX</strong> () : int</p>
<p>Obtiene la coordenada horizontal relativa al rectángulo definido para colisión.</p>
<p>function <strong>GetCY</strong> () : int</p>
<p>Obtiene la coordenada vertical relativa al rectángulo definido para colisión.</p>
<p>function <strong>GetCW</strong> () : int</p>
<p>Obtiene el ancho del rectángulo definido para colisión.</p>
<p>function <strong>GetCH</strong> () : int</p>
<p>Obtiene el alto del rectángulo definido para colisión.</p>
<p>function <strong>GetCXF</strong> () : int</p>
<p>Obtiene la coordenada horizontal final (con transformaciones padre a hijos aplicadas) relativa al rectángulo definido para colisión.</p>
<p>function <strong>GetCYF</strong> () : int</p>
<p>Obtiene la coordenada vertical final (con transformaciones padre a hijos aplicadas) relativa al rectángulo definido para colisión.</p>
<p>function <strong>GetCWF</strong> () : int</p>
<p>Obtiene el ancho final (con transformaciones padre a hijos aplicadas) del rectángulo definido para colisión.</p>
<p>function <strong>GetCHF</strong> () : int</p>
<p>Obtiene el alto final (con transformaciones padre a hijos aplicadas) del rectángulo definido para colisión.</p>
<p>function <strong>SetFrame</strong> (f)</p>
<p>Establece un fotograma fijo al Sprite si no existe animación en curso. En caso de que exista animación en curso, se aplicará el fotograma relativo a dicha animación. En cualquiera de los casos, no existirá animación de fotogramas y se verá de forma estática el fotograma establecido.</p>
<p>function <strong>GetFrame</strong> () : int</p>
<p>Obtiene el índice del fotograma asignado: este será un entero que irá de 0 hasta <em>GetNumFrames</em>-1. Si hay una animación en curso, devolverá el índice relativo al fotograma inicial de la animación.</p>
<p>function <strong>SetFlags</strong> (f)</p>
<p>Establece unos nuevos flags de usuario.</p>
<p>function <strong>GetFlags</strong> () : int</p>
<p>Obtiene los flags de usuario.</p>
<p>function <strong>AddFlags</strong> (f)</p>
<p>Agrega flags de usuario a los existentes.</p>
<p>function <strong>RemoveFlags</strong> (f)</p>
<p>Elimina flags de usuario de los existentes.</p>
<p>function <strong>CheckFlags</strong> (f) : bool</p>
<p>Verifica si existe alguno de los flags &lt;f&gt;.</p>
<p>function <strong>SetColor</strong> (c)</p>
<p>Establece una mezcla o suma de color con el fotograma visible del Sprite. Por defecto es una mezcla, pero si usamos el efecto de suma de color, será una suma directa entre el color de la textura con el establecido en &lt;c&gt;.</p>
<p>function <strong>GetColor</strong> () : int</p>
<p>Obtiene el color que se mezcla o se suma. Por defecto es RGB(255,255,255), el blanco.</p>
<p>function <strong>SetColorAdd</strong> (v)</p>
<p>Activa o desactiva el modo de suma de color.</p>
<p>function <strong>GetColorAdd</strong> (v) : bool</p>
<p>Indica si está activo el modo de suma de color.</p>
<p>function <strong>SetAlpha</strong> (alpha)</p>
<p>Establece la transparencia del Sprite. Si &lt;alpha&gt; es 0, será totalmente transparente, mientras que si es 255 será totalmente opaco.</p>
<p>function <strong>GetAlpha</strong> () : int</p>
<p>Determina la transparencia del Sprite.</p>
<p>function <strong>IncAlpha</strong> (speed)</p>
<p>Incrementa progresivamente la transparencia del Sprite con el parámetro &lt;speed&gt;. Equivale a <em>SetAlpha(GetAlpha() + speed).</em></p>
<p>function <strong>SetUserMove</strong> (ctx = null, function = “Move”)</p>
<p>Permite enganchar una llamada que se invocará en cada actualización de la lógica del Sprite.</p>
<p>function <strong>SetUserDraw</strong> (ctx = null, function = “Draw”)</p>
<p>Permite enganchar una llamada que se invocará cuando se represente el Sprite en pantalla. Esto nos permitirá poder tratar el modo en el que representamos el Sprite.</p>
<p>function <strong>SetAngle</strong> (ang)</p>
<p>Establece el ángulo de rotación con el que se representan los fotogramas. El parámetro &lt;ang&gt; se pasa en radianes. Téngase en cuenta la función <em>SetPivot</em>.</p>
<p>function <strong>GetAngle</strong> () : float</p>
<p>Obtiene el ángulo de rotación en radianes.</p>
<p>function <strong>GetClassName</strong> () : string</p>
<p>Obtiene una cadena de texto con el nombre de la clase del Sprite. Salvo que sea una clase de usuario, esta cadena será “GL_Sprite”.</p>
<p>function <strong>GetParent</strong> () : pointer</p>
<p>Obtiene el padre asociado a un Sprite. En caso de no tener ninguno, devolverá NULL.</p>
<p>function <strong>SetPriority</strong> (p)</p>
<p>Establece la prioridad del Sprite. A menor prioridad se pintan primero, y a mayor prioridad se pintan por encima.</p>
<p>function <strong>GetPriority</strong> () : int</p>
<p>Retorna la prioridad del Sprite.</p>
<p>function <strong>AddChild</strong> (spr)</p>
<p>Añade un Sprite como hijo.</p>
<p>function <strong>RemoveChild</strong> (spr)</p>
<p>Elimina un Sprite como hijo. Esto no borra el objeto Sprite &lt;spr&gt;, simplemente deja de ser hijo.</p>
<p>function <strong>SetTextureMask</strong> (mask)</p>
<p>Establece una textura de máscara que se aplica sobre los fotogramas. A la hora de dibujar un fotograma del Sprite, si la máscara está activada, el fotograma se dibujará utilizando la máscara y eso hará que las zonas de color negro de la máscara no se vean mientras que sí lo harán las que están en blanco. El parámetro &lt;mask&gt; podrá ser o bien una ruta a la textura a cargar o bien directamente un objeto textura.</p>
<p>function <strong>GetTextureMask</strong> () : pointer</p>
<p>Si tiene asociada una textura de máscara retornará el objeto textura; en caso contrario, devolverá NULL.</p>
<p>function <strong>GetAnimationLoops</strong>() : int</p>
<p>Indica el número de veces que se ha repetido la reproducción de la animación en curso.</p>
<p>function <strong>IsClipped</strong> () : bool</p>
<p>Indica si el Sprite está visible o no en pantalla.</p>
<p>function <strong>SetClipping</strong> (v)</p>
<p>Activa o desactiva la detección de visibilidad de un Sprite cuando entra o sale de la zona de CLIPPING de cámara. Si &lt;v&gt; es falso, no se tendrá en cuenta esto y el Sprite siempre estará activo aunque esté fuera de cámara.</p>
<p>function <strong>GetClipping</strong> () : bool</p>
<p>Indica si se tiene en cuenta la zona de CLIPPING de cámara para este Sprite.</p>
<p>function <strong>InViewport</strong> () : bool</p>
<p>Indica si el Sprite se encuentra visible en la zona de VIEWPORT de la cámara.</p>
<p>function <strong>CheckCollisionWithSprite</strong> (spr) : bool</p>
<p>Indica si el área de colisión del Sprite colisiona con la de otro Sprite &lt;spr&gt;. Esta función tiene en cuenta también la rotación y escalado aplicados.</p>
<p>function <strong>SetPhysics</strong> (v)</p>
<p>Activa o desactiva la gestión de físicas realistas para el Sprite.</p>
<p>function <strong>GetPhysics</strong> () : bool</p>
<p>Indica si las físicas realistas están activas.</p>
<p>function <strong>SetPhysicsBody</strong> (type)</p>
<p>Establece el tipo de cuerpo físico que se quiere asociar al Sprite. Este podrá ser:</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>SPRITE_PHYSICS_BODY_STATIC</th>
<th>Estático. No se mueve. Las colisiones se tienen en cuenta, pero no reacciona a las mismas.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SPRITE_PHYSICS_BODY_DYNAMIC</td>
<td>Dinámico. Se mueve y reacciona a las colisiones con los demás objetos.</td>
</tr>
<tr class="even">
<td>SPRITE_PHYSICS_BODY_KINEMATIC</td>
<td>Es una mezcla entre el estático y el dinámico. Puede moverse pero no le afectan las colisiones.</td>
</tr>
</tbody>
</table>
<p>function <strong>GetPhysicsBody</strong>() : int</p>
<p>Devuelve el tipo de cuerpo físico asociado.</p>
<p>function <strong>ClearPhysicsShapes</strong> ()</p>
<p>Elimina todas las figuras físicas asociadas al Sprite.</p>
<p>function <strong>AddPhysicsShapeRect</strong> (x, y, w, h) : pointer</p>
<p>Agrega una figura física de tipo rectangular con posición relativa (x, y) y tamaño (w, h).</p>
<p>function <strong>AddPhysicsShapeCircle</strong> (x, y, r) : pointer</p>
<p>Agrega una figura física de tipo circular con posición relativa (x, y) y radio &lt;r&gt;.</p>
<p>function <strong>GetNumPhysicsShapes</strong> () : int</p>
<p>Retorna el número de figuras físicas asociadas al Sprite.</p>
<p>function <strong>RemovePhysicsShapeByIndex</strong> (ix)</p>
<p>Elimina la figura física asociada con índice &lt;ix&gt;. Este índice irá de 0 a <em>GetNumPhysicsShapes</em>-1.</p>
<p>function <strong>SetPhysicsFixedRotation</strong> (v)</p>
<p>Permite indicar si queremos que la rotación de la figura física se vea afectada o si queremos que permanezca estática. Para que se vea afectada la rotación, el parámetro &lt;v&gt; ha de ser verdadero.</p>
<p>function <strong>GetPhysicsFixedRotation</strong> () : bool</p>
<p>Indica si la rotación de la figura física se ve afectada o permanece estática.</p>
<p>function <strong>SetPhysicsMass</strong> (v)</p>
<p>Establece un valor de masa al cuerpo físico. Solo sirve en cuerpos físicos de tipo dinámico.</p>
<p>function <strong>GetPhysicsMass</strong> () : float</p>
<p>Obtiene el valor de masa del cuerpo físico.</p>
<p>function <strong>SetPhysicsDensity</strong> (v)</p>
<p>Establece una densidad al cuerpo físico. También usada para simular la masa del cuerpo y se mide en kg/m2. A más densidad, cuerpos más pesados. Este valor no puede ser negativo.</p>
<p>function <strong>GetPhysicsDensity</strong> () : float</p>
<p>Obtiene la densidad establecida al cuerpo físico.</p>
<p>function <strong>SetPhysicsRestitution</strong> (v)</p>
<p>Establece el factor de restitución del cuerpo físico. Se utiliza principalmente para indicar cómo reacciona el cuerpo frente a la colisión con otros cuerpos (el factor de rebote). El valor de &lt;v&gt; ha de ser, generalmente, un valor entre 0 y 1.</p>
<p>function <strong>GetPhysicsRestitution</strong> () : float</p>
<p>Obtiene el factor de restitución del cuerpo físico.</p>
<p>function <strong>SetPhysicsFriction</strong> (v)</p>
<p>Establece el factor de fricción del cuerpo físico. Se utiliza principalmente para indicar cómo resbala un cuerpo frente a la colisión con otros cuerpos. El valor de &lt;v&gt; ha de ser, generalmente, un valor entre 0 y 1.</p>
<p>function <strong>GetPhysicsFriction</strong> () : float</p>
<p>Obtiene el factor de fricción del cuerpo físico.</p>
<p>function <strong>SetPhysicsGravityScale</strong> (v)</p>
<p>Establece el factor de compensación gravitatorio del cuerpo físico. Sirve para trucar cómo afecta la gravedad general con respecto a este cuerpo. Por defecto es 1.</p>
<p>function <strong>GetPhysicsGravityScale</strong> () : float</p>
<p>Obtiene el factor de compensación gravitatorio del cuerpo físico.</p>
<p>function <strong>SetPhysicsAngularDamping</strong> (v)</p>
<p>Establece el factor con el que se reduce la velocidad angular del cuerpo físico. El valor de &lt;v&gt; generalmente estará entre 0 y 1.</p>
<p>function <strong>GetPhysicsAngularDamping</strong> () : float</p>
<p>Obtiene el factor de reducción de velocidad angular.</p>
<p>function <strong>SetPhysicsLinearDamping</strong> (v)</p>
<p>Establece el factor de reducción de la velocidad lineal. El valor de &lt;v&gt; generalmente estará entre 0 y 1.</p>
<p>function <strong>GetPhysicsLinearDamping</strong> () : float</p>
<p>Obtiene el factor de reducción de velocidad linear.</p>
<p>function <strong>ApplyTorque</strong> (x)</p>
<p>Aplica un efecto de giro / fuerza de torsión. El valor de &lt;x&gt; se expresa en Newtons Metros (Nm). Esta fuerza afecta a la velocidad angular sin hacerlo a la velocidad lineal de centro de masas. La función despierta al cuerpo si está dormido.</p>
<p>function <strong>ApplyForce</strong> (x, y, px, py)</p>
<p>Aplica una fuerza a un punto del mundo. Si la fuerza no se aplica al centro de masas, generará un efecto de giro y afectará a la velocidad angular. Esta función despierta al cuerpo si está dormido. El vector (x, y) de fuerza se mide en Newtons y la posición del punto en el mundo será (px, py).</p>
<p>function <strong>ApplyForceToCenter</strong> (x, y)</p>
<p>Aplica una fuerza directamente al centro de masas del cuerpo. Esta función despierta al cuerpo si está dormido. El vector de fuerza (x, y) se mide en Newtons.</p>
<p>function <strong>ApplyLinearImpulse</strong> (sx, sy, x, y)</p>
<p>Aplica un impulso (sx, sy) a un punto (x, y). Esto modificará de inmediato la velocidad. También modificará la velocidad angular si el punto al que se aplica no es el centro de masas. Esta función despierta al cuerpo si está dormido. El impulso se mide en Newton-Seconds.</p>
<p>function <strong>GetPhysicsVelocity</strong> () : list</p>
<p>Retorna una lista de dos componentes que representan la velocidad lineal del objeto en metros/segundo.</p>
<p>function <strong>BuildPhysics</strong> ()</p>
<p>Una vez inicializadas las figuras físicas y propiedades del cuerpo físico, mediante esta función se preparan y crean todas las estructuras necesarias para la simulación.</p>
<p>function <strong>CreateController</strong> () : pointer</p>
<p>Crea un objeto GL_Controller y lo asocia al Sprite. El objeto controlador permite gestionar el movimiento de un Sprite de diferentes modos.</p>
<p>function <strong>DestroyController</strong> ()</p>
<p>Elimina el objeto controlador asociado al Sprite.</p>
<p>function <strong>GetController</strong> () : pointer</p>
<p>Obtiene el puntero al objeto controlador asociado. Si no se ha creado ninguno, devolverá NULL.</p>
<p>function <strong>CreateFX</strong> (name) : pointer</p>
<p>Permite crear un efecto visual sobre el Sprite. El tipo de efecto se determina con el parámetro &lt;name&gt; que será una cadena de texto. Para activar el efecto es necesario inicializarlo mediante la llamada Start.</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 43%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Name</strong></th>
<th><strong>Funcionalidad</strong></th>
<th><strong>Parámetros de Start</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BLINK</td>
<td>Efecto de parpadeo durante un número de veces.</td>
<td>Milisegundos de cada parpadeo, veces que parpadea.</td>
</tr>
<tr class="even">
<td>TINT</td>
<td>Efecto de suma de color por un tiempo.</td>
<td>Duración del efecto, color con el que tintar.</td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<pre><code>_fx = _sprite.CreateFX(&quot;blink&quot;);
_fx.Start(100, 15);</code></pre>
<p>function <strong>DestroyAllFX</strong> ()</p>
<p>Elimina todos los efectos visuales creados en el Sprite.</p>
<p>function <strong>CreateCollider</strong> () : pointer</p>
<p>Crea y asocia al Sprite un objeto de tipo GL_Collider. Este tipo de objeto permite controlar colisiones.</p>
<p>function <strong>DestroyCollider</strong> ()</p>
<p>Elimina el objeto Collider asociado al Sprite, si existe.</p>
<p>function <strong>GetCollider</strong> () : pointer</p>
<p>Obtiene el objeto Collider asociado al Sprite. En caso de no haberse creado, devolverá NULL.</p>
<p>function <strong>MoveTo</strong> (x, y, speed = 0.01f)</p>
<p>Mueve un Sprite hasta una posición absoluta (x, y) a una velocidad de &lt;speed&gt;. Esta función ya tiene en cuenta el <em>GetFTime</em> en los incrementos.</p>
<p>function <strong>SetChroma</strong> (v)</p>
<p>Activa o desactiva la capacidad de filtrar un color de chroma en la carga de texturas. Si el chroma está activado, cuando se carga una textura, el color establecido se convertirá en totalmente transparente. Para establecer el color de chroma se debe usar <em>SetChromaColor</em>.</p>
<p>function <strong>SetChromaColor</strong> (color)</p>
<p>Establece el color de chroma a utilizar. Véase <em>SetChroma</em>.</p>
<h2 id="gl_mapper">GL_Mapper</h2>
<p>Un Mapper es una o varias rejillas de celdas (capas) donde podemos asignar a cada una de ellas un gráfico desde un TILESET, además de indicar información adicional.</p>
<p><img src="media/3dd75783b2b5f9ad4fd07ad29cb793b1.png" /></p>
<p>El TILESET es una imagen donde tenemos pequeñas porciones de gráficos que miden lo mismo en horizontal y vertical.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>AddLayer</strong> (w, h) : pointer</p>
<p>Agrega una capa con &lt;w&gt; celdas en horizontal y &lt;h&gt; celdas en vertical. La función devuelve un objeto Layer.</p>
<p>function <strong>GetNumLayers</strong> () : int</p>
<p>Devuelve el número de capas creadas.</p>
<p>function <strong>GetLayer</strong> (ix) : pointer</p>
<p>Obtiene la capa con índice &lt;ix&gt;. El parámetro es un entero entre 0 y <em>GetNumLayers-</em>1.</p>
<p>function <strong>RemoveLayer</strong> (layer)</p>
<p>Elimina una capa de la lista. El parámetro &lt;layer&gt; es un puntero al objeto.</p>
<p>function <strong>ClearLayers</strong> ()</p>
<p>Elimina todas las capas existentes.</p>
<p>function <strong>AddTileSet</strong> (path, tw, th, sw = 0, sh = 0, texw = 0, texh = 0) : pointer</p>
<p>Crea y añade un TILESET. El parámetro &lt;path&gt; es la ruta a la textura con los gráficos, &lt;tw&gt; es el tamaño horizontal de cada TILE o porción gráfica, &lt;th&gt; es el tamaño vertical de cada TILE, &lt;sw&gt; y &lt;sh&gt; indican qué separación existe entre tiles dentro de la textura en horizontal y vertical. &lt;texw&gt; y &lt;texh&gt; hacen referencia al tamaño a considerar en vertical y horizontal de la textura; en el caso de ser 0, se usará el tamaño original de la misma.</p>
<p>function <strong>GetNumTilesets</strong> () : int</p>
<p>Obtiene el número de TILESETs existentes.</p>
<p>function <strong>GetTileset</strong> (ix) : pointer</p>
<p>Obtiene el TILESET con índice &lt;ix&gt;. El parámetro &lt;ix&gt; un entero entre 0 y <em>GetNumTilesets-</em>1.</p>
<p>function <strong>FindTileset</strong> (path) : pointer</p>
<p>Busca un TILESET por nombre de ruta. Si existe devolverá un puntero al objeto, si no existe devolverá NULL.</p>
<p>function <strong>RemoveTileSet</strong> (ts)</p>
<p>Elimina el TILESET a partir del parámetro &lt;ts&gt; que será el puntero al objeto.</p>
<p>function <strong>ClearTilesets</strong> ()</p>
<p>Elimina todos los TILESETs creados.</p>
<p>function <strong>SetTileW</strong> (w)</p>
<p>Establece el tamaño de tile horizontal por defecto.</p>
<p>function <strong>GetTileW</strong> () : int</p>
<p>Obtiene el tamaño de tile horizontal por defecto.</p>
<p>function <strong>SetTileH</strong> (h)</p>
<p>Establece el tamaño de tile vertical por defecto.</p>
<p>function <strong>GetTileH</strong> () : int</p>
<p>Obtiene el tamaño de tile vertical por defecto.</p>
<p>function <strong>SetWidth</strong> (w)</p>
<p>Cambia el número de rejillas en horizontal para todas las capas.</p>
<p>function <strong>GetWidth</strong> () : int</p>
<p>Devuelve el número de rejillas horizontal para todas las capas.</p>
<p>function <strong>SetHeight</strong> (h)</p>
<p>Cambia el número de rejillas en vertical para todas las capas.</p>
<p>function <strong>GetHeight</strong> () : int</p>
<p>Devuelve el número de rejillas en vertical para todas las capas.</p>
<p>function <strong>GetCellFromPos</strong> (x, y) : list</p>
<p>Dada una posición (x, y), devolverá la celda que haya en esa posición. El valor retornado será una lista de dos componentes: [celdaX, celdaY]. En caso de que la posición esté fuera del rango del mapeado, se retornará lista vacía.</p>
<p>function <strong>GetInfoFromPos</strong> (x, y) : list</p>
<p>Data una posición (x, y), devolverá la información de la celda que haya en esa posición. El valor retornado será una lista de tres componentes: [tilesetObject, tilesetIndex, flags].</p>
<p>El &lt;tilesetObject&gt; es el puntero al objeto TILESET que hace referencia esa celda. El &lt;tilesetIndex&gt; hace referencia al TILE dentro de ese TILESET, es un número entero. Los &lt;flags&gt; indican información de usuario.</p>
<p>function <strong>SetOffset</strong> (x, y)</p>
<p>En la visualización del mapeado, el offset indica a partir de qué pixel se comienza a representar el mismo.</p>
<p>function <strong>SetOffsetX</strong> (x)</p>
<p>Establece el pixel horizontal a partir del cual representar el mapeado de celdas.</p>
<p>function <strong>SetOffsetY</strong> (y)</p>
<p>Establece el pixel vertical a partir del cual representar el mapeado de celdas.</p>
<p>function <strong>GetOffsetX</strong> () : int</p>
<p>Obtiene el pixel horizontal a partir del cual representar el mapeado de celdas.</p>
<p>function <strong>GetOffsetY</strong> () : int</p>
<p>Obtiene el pixel vertical a partir del cual representar el mapeado de celdas.</p>
<p>function <strong>DrawTile</strong> (ts, index, x, y, scale, color)</p>
<p>Dibuja un TILE &lt;index&gt; de un TILESET &lt;ts&gt; en una posición de pantalla (x, y) con una escala &lt;scale&gt; y una mezcla de color &lt;color&gt;. Esta función se ha de usar desde una llamada dentro del dibujado de fotograma.</p>
<p><strong>Interfaz para Layers</strong></p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Set</strong> (i, j, ts, index, flags = 0)</th>
<th>Asigna en la celda (i, j) el objeto tileset &lt;ts&gt; usando el índice al tile &lt;index&gt; y con datos de usuario &lt;flags&gt;.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Get</strong> (i, j) : list</td>
<td>Obtiene una lista con [tileset, tileindex, flags].</td>
</tr>
<tr class="even">
<td><strong>FillTS</strong> (ts, i, j, w, h)</td>
<td>Rellena un área desde (i, j) con tamaño (w, h) con un puntero al tileset &lt;ts&gt;.</td>
</tr>
<tr class="odd">
<td><strong>Fill</strong> (index, i, j, w, h)</td>
<td>Rellena un área desde (i, j) con tamaño (w, h) con el valor de tile con índice &lt;index&gt;.</td>
</tr>
<tr class="even">
<td><strong>GetWidth</strong> () : int</td>
<td>Número de celdas en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>GetHeight</strong> () : int</td>
<td>Número de celdas en vertical.</td>
</tr>
<tr class="even">
<td><strong>SetWidth</strong> (w)</td>
<td>Establece el número de celdas en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>SetHeight</strong> (h)</td>
<td>Establece el número de celdas en vertical.</td>
</tr>
<tr class="even">
<td><strong>SetSize</strong> (w, h)</td>
<td>Establece un nuevo tamaño (w, h).</td>
</tr>
<tr class="odd">
<td><strong>Clear</strong> ()</td>
<td>Pone a cero todo el contenido de celdas.</td>
</tr>
<tr class="even">
<td><strong>AddSprite</strong> (spr)</td>
<td>Agrega un Sprite a la capa.</td>
</tr>
<tr class="odd">
<td><strong>RemoveSprite</strong> (spr)</td>
<td>Elimina un Sprite de la capa.</td>
</tr>
</tbody>
</table>
<p><strong>Interfaz para Tilesets</strong></p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>GetTexture</strong> () : pointer</th>
<th>Obtiene el puntero a la textura.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GetName</strong> () : string</td>
<td>Obtiene la ruta a la textura.</td>
</tr>
<tr class="even">
<td><strong>GetTileW</strong> () : int</td>
<td>Indica el tamaño del tile en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>GetTileH</strong> () : int</td>
<td>Indica el tamaño del tile en vertical.</td>
</tr>
<tr class="even">
<td><strong>GetNumTilesW</strong> () : int</td>
<td>Indica el número de tiles en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>GetNumTilesH</strong> () : int</td>
<td>Indica el número de tiles en vertical.</td>
</tr>
<tr class="even">
<td><strong>GetTexW</strong> () : int</td>
<td>Obtiene el tamaño de textura en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>GetTexH</strong> () : int</td>
<td>Obtiene el tamaño de textura en vertical.</td>
</tr>
<tr class="even">
<td><strong>SetTileW</strong> (w)</td>
<td>Establece el tamaño de tile en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>SetTileH</strong> (h)</td>
<td>Establece el tamaño de tile en vertical.</td>
</tr>
<tr class="even">
<td><strong>SetSepW</strong> (w)</td>
<td>Establece la separación entre tiles en horizontal dentro de la textura.</td>
</tr>
<tr class="odd">
<td><strong>SetSepH</strong> (h)</td>
<td>Establece la separación entre tiles en vertical dentro de la textura.</td>
</tr>
<tr class="even">
<td><strong>GetSepW</strong> () : int</td>
<td>Obtiene la separación entre tiles en horizontal.</td>
</tr>
<tr class="odd">
<td><strong>GetSepH</strong> () : int</td>
<td>Obtiene la separación entre tiles en vertical.</td>
</tr>
</tbody>
</table>
<h2 id="gl_music-y-gl_sound">GL_Music y GL_Sound</h2>
<p>Estos dos tipos de objetos permiten trabajar con archivos de audio. Aunque el interfaz es común entre ambos, la diferencia está en la gestión de la reproducción del audio que tiene cada uno. En el caso de GL_Music, el audio se reproduce en streaming, o sea, el archivo no se carga en memoria al completo, se va leyendo poco a poco. Esto permite trabajar con archivos de audio muy grandes y suele ser utilizado para reproducir música. Por el contrario, GL_Sound carga por completo el archivo de audio en memoria. La idea es poder lanzar los audios lo más rápido que sea posible.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>Load</strong> (path)</p>
<p>Carga un archivo de audio y lo prepara para su reproducción. El archivo se encontrará accesible a través de la ruta absoluta o relativa &lt;path&gt;.</p>
<p>Tipos de archivo: WAV, OGG, MP3.</p>
<p>function <strong>Play</strong> ()</p>
<p>Comienza con la reproducción del archivo de audio.</p>
<p>function <strong>Stop</strong> ()</p>
<p>Detiene la reproducción del archivo de audio.</p>
<p>function <strong>SetLoop</strong> (loop)</p>
<p>Establece si se quiere reproducir infinitamente el archivo de audio o no. El parámetro &lt;loop&gt; es un valor que podrá ser verdadero o falso.</p>
<p>function <strong>GetLoop</strong> () : bool</p>
<p>Indica si la reproducción infinita está activa o no.</p>
<p>function <strong>SetVolume</strong> (vol)</p>
<p>Establece el nivel de volumen para el audio. El parámetro &lt;vol&gt; será un entero en el rango 0 a 255.</p>
<p>function <strong>GetVolume</strong> () : int</p>
<p>Obtiene el nivel de volumen para el audio.</p>
<p>function <strong>SetPitch</strong> (pitch)</p>
<p>Establece una modificación sobre la frecuencia/tono del audio asociado. Por defecto es cero. El parámetro &lt;pitch&gt; podrá ver un número entero positivo o negativo.</p>
<p>function <strong>GetPitch</strong> () : int</p>
<p>Obtiene la modificación sobre la frecuencia/tono base del audio.</p>
<p>function <strong>SetPanning</strong> (pan)</p>
<p>Establece el nivel de balance izquierda/derecha del audio. El parámetro &lt;pan&gt; será un entero en el rango 0 a 255. Por defecto es 127 que equivaldría a un equilibro entre izquierda y derecha.</p>
<p>function <strong>GetPanning</strong> () : int</p>
<p>Obtiene el nivel de balance configurado para el audio.</p>
<p>function <strong>SetOnStop</strong> (ctx, function)</p>
<p>Permite enganchar una llamada que avisa cuando el audio ha terminado de reproducirse o se ha detenido su reproducción.</p>
<p>function <strong>IsPlaying</strong> () : bool</p>
<p>Indica si la música está siendo reproducida o no.</p>
<h2 id="gl_route">GL_Route</h2>
<p>Una ruta es un tipo de objeto que tiene una serie de nodos que representan posiciones 2D o 3D. Las rutas sirven principalmente para crear recorridos cíclicos o no.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>AddNode</strong> (x, y, z = 0) : pointer</p>
<p>Agrega un nodo con posición (x, y, z).</p>
<p>function <strong>InsertNode</strong> (x, y, node) : pointer</p>
<p>Inserta un nodo (x, y) delante de otro &lt;node&gt;. Si &lt;node&gt; es NULL o no existe, el nuevo nodo se insertará al final de la lista.</p>
<p>function <strong>InsertNode</strong> (x, y, z, node) : pointer</p>
<p>Inserta un nodo (x, y, z) delante de otro &lt;node&gt;. Si &lt;node&gt; es NULL o no existe, el nuevo nodo se insertará al final de la lista.</p>
<p>function <strong>FindNode</strong> (x, y, z, eps = 0.0f) : pointer</p>
<p>Busca en la lista de nodos el punto (x, y, z) más cercano al radio de búsqueda &lt;eps&gt;.</p>
<p>function <strong>RemoveNode</strong> (x, y, z, eps = 0.0f)</p>
<p>Elimina el primer nodo que haya en la lista que sea más cercano al (x, y, z) en el radio de búsqueda &lt;eps&gt;.</p>
<p>function <strong>RemoveNode</strong> (ix)</p>
<p>Elimina el nodo de la lista con índice &lt;ix&gt;.</p>
<p>function <strong>ClearNodes</strong> ()</p>
<p>Borra todos los nodos.</p>
<p>function <strong>GetNumNodes</strong> () : int</p>
<p>Devuelve el número total de nodos en la lista.</p>
<p>function <strong>FindSegment</strong> (x, y, z, eps = 0.0f) : list</p>
<p>Busca el segmento (dos nodos) más próximo en el radio de búsqueda &lt;eps&gt; al punto (x, y, z). La lista retornada tendrá dos punteros a objetos nodo.</p>
<p>function <strong>FindStart</strong> (speed, mode) : pointer</p>
<p>Comienza una ruta por la lista de nodos. El avance por la ruta se hará a velocidad &lt;speed&gt; y se podrá realizar en los siguientes modos &lt;mode&gt;:</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="header">
<th>GL_Route.MODE_ENDFIX</th>
<th>La ruta, una vez llega al último punto, se queda allí.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GL_Route.MODE_LOOP</td>
<td>La ruta una vez llega al último punto vuelve a comenzar desde el primero.</td>
</tr>
<tr class="even">
<td>GL_Route.MODE_PINGPONG</td>
<td>La ruta, una vez llega al último punto, vuelve hacia atrás hasta el primer punto y va de nuevo al último, y así indefinidamente.</td>
</tr>
<tr class="odd">
<td>GL_Route.MODE_ENDFIX_AND_DESTROY</td>
<td>Una vez la ruta llega al último punto, la destruye y finaliza.</td>
</tr>
</tbody>
</table>
<p>function <strong>FindNext</strong> (pf) : bool</p>
<p>Avanza un paso en el recorrido de la ruta. En &lt;pf&gt; indicaremos la ruta creada previamente con <em>FindStart</em>. Mientras el recorrido no llegue a su fin, la función retornará verdadero. Una vez llegue a su fin, la función retornará falso.</p>
<p>function <strong>FindEnd</strong> (pf)</p>
<p>Finaliza una ruta y libera recursos de memoria.</p>
<p>function <strong>IncPos</strong> (x, y, z = 0)</p>
<p>Incrementa en (x, y, z) el valor de las coordenadas de todos los nodos insertados.</p>
<p>function <strong>AddCircle</strong> (cx, cy, rad, step = 0.1f)</p>
<p>Agrega tantos nodos como sean necesarios para crear un círculo de centro (cx, cy) y radio &lt;rad&gt;. La densidad de nodos se medirá con el parámetro &lt;step&gt;.</p>
<p>function <strong>AddRect</strong> (x, y, w, h, loop = true)</p>
<p>Agrega tantos nodos como sean necesarios para crear un rectángulo de posición (x, y) y tamaño (w, h). Por defecto el rectángulo se crea para ser cerrado y conseguir una ruta infinita, sin embargo podemos dejarlo abierto si usamos &lt;loop&gt; a falso.</p>
<h2 id="gl_text">GL_Text</h2>
<p>Este control permite la representación de textos dentro de un área delimitada. El control hereda de GL_Sprite, por lo que implementa o reimplementa su funcionalidad.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>GetTextWidth</strong> () : int</p>
<p>Indica el ancho en pixeles que ocupa el texto en pantalla.</p>
<p>function <strong>GetTextHeight</strong> () : int</p>
<p>Indica el alto en pixeles que ocupa el texto en pantalla.</p>
<p>function <strong>GetText</strong> () : string</p>
<p>Obtiene la cadena de texto asociada al control.</p>
<p>function <strong>SetText</strong> (text)</p>
<p>Establece la cadena de texto asociada al control y que se visualiza en pantalla.</p>
<p>function <strong>SetColor</strong> (color)</p>
<p>Establece el color del texto.</p>
<p>function <strong>SetFontName</strong> (path)</p>
<p>Indica el nombre de la fuente de letra que queremos usar. El nombre de la fuente puede ser una ruta absoluta o relativa. Los formatos de archivo compatibles son: PNG, TTF, OTF.</p>
<p>function <strong>GetFontName</strong> () : string</p>
<p>Obtiene el nombre de la fuente de letra.</p>
<p>function <strong>SetFontSize</strong> (size)</p>
<p>Establece el tamaño de la fuente una vez se representa en pantalla.</p>
<p>function <strong>GetFontSize</strong> () : int</p>
<p>Retorna el tamaño de la fuente usado.</p>
<p>function <strong>SetFont</strong> (path, size)</p>
<p>Equivale a aplicar un <em>SetFontName</em> y un <em>SetFontSize</em> al mismo tiempo.</p>
<p>function <strong>SetAlign</strong> (align)</p>
<p>Establece el tipo de alineación que queremos para el texto dentro del área de dibujado. La alineación podrá ser una combinación de los flags: DT_LEFT, DT_RIGHT, DT_TOP, DT_BOTTOM, DT_CENTER, DT_VCENTER.</p>
<p>function <strong>GetAlign</strong> () : int</p>
<p>Obtiene la alineación utilizada para el texto.</p>
<p>function <strong>SetFontSpacing</strong> (hSpace, vSpace)</p>
<p>Establece un espaciado adicional entre letras en horizontal y vertical. Con esta función podemos ajustar el estilo por defecto de separación de letras que usa la fuente utilizada.</p>
<p>function <strong>SetFontBitmapProperties</strong> (numX, numY, charStart)</p>
<p>En el caso de usar una fuente bitmap (PNG), previa carga de la textura, hay que indicar el número de caracteres que hay en horizontal &lt;numX&gt; y el número que hay en vertical &lt;numY&gt;. También hay que especificar cuál es el carácter inicial &lt;charStart&gt;.</p>
<h2 id="gl_timer">GL_Timer</h2>
<p>Un temporizador permite ejecutar código script cada cierto tiempo.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>SetFrequency</strong> (ms)</p>
<p>Establece la frecuencia en milisegundos &lt;ms&gt; en la que se invoca la llamada de usuario.</p>
<p>function <strong>GetFrequency</strong> () : int</p>
<p>Obtiene el número de milisegundos configurados para invocar la llamada de usuario.</p>
<p>function <strong>SetUserCallback</strong> (ctx, function)</p>
<p>Establece la llamada de usuario en el contexto &lt;ctx&gt; y la función con nombre &lt;function&gt;.</p>
<h2 id="gl_collider">GL_Collider</h2>
<p>Un colisionador gestiona colisiones entre sprites.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>GetCollisionSides</strong> (spr) : int</p>
<p>Comprueba las colisiones del Sprite &lt;spr&gt; con el colisionador. En caso de haber colisión, devolverá una serie de flags que nos indicarán qué lados del rectángulo se han visto afectados:</p>
<p>function <strong>SetCheckerObj</strong> (spr)</p>
<p>Permite especificar un Sprite como área de chequeo.</p>
<p>function <strong>GetCheckerObj</strong> () : pointer</p>
<p>Obtiene el Sprite que sirve como área de chequeo. Si no hay ninguno asignado devolverá NULL.</p>
<p>function <strong>SetCheckerRect</strong> (x, y, w, h)</p>
<p>Permite especificar un área fija rectangular como área de chequeo en la posición (x, y) y con tamaño (w, h).</p>
<p>function <strong>GetCheckerRect</strong> () : list</p>
<p>Obtiene el área estática de chequeo. Si existe, devolverá una lista con cuatro componentes: [x, y, w, h]. En caso contrario, una lista vacía.</p>
<p>function <strong>SetCheckType</strong> (type)</p>
<p>Permite establecer el tipo de Sprite sobre el que se quiere detectar colisiones. Véase función <em>GL_Sprite::SetType.</em></p>
<p>function <strong>SetMaxCollisions</strong> (num)</p>
<p>Indica el máximo de colisiones permitidas a la vez. Cuando se produce una colisión, se llama a la función de usuario. Si limitamos el número, solo se gestionará esta cantidad de llamadas.</p>
<p>function <strong>SetOnCollision</strong> (ctx, function)</p>
<p>Establece la llamada a usuario provocada cada vez que ocurre una colisión. En la función indicamos el contexto &lt;ctx&gt; y el nombre de la función &lt;function&gt;.</p>
<h2 id="gl_controller">GL_Controller</h2>
<p>Un controlador permite dotar de movimiento a Sprites en diferentes modos.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>SetTarget</strong> (target)</p>
<p>Establece el Sprite en el cual el controlador gestionará su movimiento.</p>
<p>function <strong>GetTarget</strong> () : pointer</p>
<p>Obtiene el Sprite que se está controlando.</p>
<p>function <strong>SetSpeed</strong> (speedX, speedY)</p>
<p>Establece la velocidad horizontal y vertical, por separado, a aplicar al movimiento del Sprite.</p>
<p>function <strong>SetSpeed</strong> (speed)</p>
<p>Establece la velocidad horizontal y vertical, al mismo tiempo, a aplicar al movimiento del Sprite.</p>
<p>function <strong>SetSpeedX</strong> (speed)</p>
<p>Establece la velocidad horizontal a aplicar al movimiento del Sprite.</p>
<p>function <strong>SetSpeedY</strong> (speed)</p>
<p>Establece la velocidad vertical a aplicar al movimiento del Sprite.</p>
<p>function <strong>GetSpeedX</strong> () : float</p>
<p>Obtiene la velocidad horizontal.</p>
<p>function <strong>GetSpeedY</strong> () : float</p>
<p>Obtiene la velocidad vertical.</p>
<p>function <strong>GetDirX</strong> () : float</p>
<p>Obtiene la dirección y velocidad de movimiento horizontal actual. Este valor puede ser positivo o negativo, por lo que sabremos si indica dirección izquierda o derecha.</p>
<p>function <strong>GetDirY</strong> () : float</p>
<p>Obtiene la dirección y velocidad de movimiento vertical actual. Este valor puede ser positivo o negativo, por lo que sabremos si indica dirección arriba o abajo.</p>
<p>function <strong>SetRoute</strong> (route, mode)</p>
<p>Establece un objeto ruta &lt;route&gt; y un modo &lt;mode&gt; (véase <em>GL_Route::FindStart</em>) como sistema de movimiento a aplicar al Sprite objetivo. Esta llamada desactiva SetPad y SetCustom.</p>
<p>function <strong>SetOnEndRoute</strong> (ctx, function)</p>
<p>Engancha una llamada a la función con nombre &lt;function&gt; del contexto &lt;ctx&gt; cuando finaliza el recorrido de la ruta.</p>
<p>function <strong>SetPad</strong> (pad)</p>
<p>Establece un mando virtual (GL_Pad) como mecanismo de gestión de movimiento para el Sprite. Esta llamada desactiva SetRoute y SetCustom.</p>
<p>function <strong>SetCustom</strong> (ctx, function)</p>
<p>Establece como mecanismo de gestión de movimiento, una función de usuario. Esta se invocará fotograma a fotograma, y desde ella se podrá acceder al Sprite para aplicar el movimiento que corresponda. Esta llamada desactiva SetRoute y SetPad.</p>
<p>function <strong>GetX</strong> () : float</p>
<p>Obtiene la posición X del controlador de movimiento.</p>
<p>function <strong>GetY</strong> () : float</p>
<p>Obtiene la posición Y del controlador de movimiento.</p>
<p>function <strong>SetUpdateCallback</strong> (ctx, function)</p>
<p>Establece una llamada posterior a la gestión de movimiento que hayamos configurado. La función ha de tener el prototipo:</p>
<pre><code>function OnUpdateCallback (_controller);</code></pre>
<p>function <strong>Undo</strong> ()</p>
<p>Deshace la última actualización de movimiento que hayamos realizado.</p>
<p>function <strong>EnableLimits</strong> (x, y, w, h)</p>
<p>Establece los límites de movimiento. Esto obligará a que nunca se pueda salir del rectángulo creado con posición (x, y) y tamaño (w, h).</p>
<p>function <strong>DisableLimits</strong> ()</p>
<p>Desactiva el área de limitación de movimiento.</p>
<h2 id="gl_pad">GL_Pad</h2>
<p>Un pad representa un mando virtual con el que capturar las acciones de los dispositivos de entrada y procesarlos en nuestra aplicación a través de una interfaz común.</p>
<p>Los métodos disponibles son:</p>
<p>function <strong>SetButton</strong> (butID, channel, mode, value)</p>
<p>Configura el botón &lt;butID&gt; en su canal &lt;channel&gt;. Existe un máximo de 3 canales.</p>
<p>Los ID de botón disponibles son:</p>
<table>
<thead>
<tr class="header">
<th>PAD_BUTTON_LEFT</th>
<th>Botón izquierdo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PAD_BUTTON_RIGHT</td>
<td>Botón derecho</td>
</tr>
<tr class="even">
<td>PAD_BUTTON_UP</td>
<td>Botón arriba</td>
</tr>
<tr class="odd">
<td>PAD_BUTTON_DOWN</td>
<td>Botón abajo</td>
</tr>
<tr class="even">
<td>PAD_BUTTON_INSIDE</td>
<td>Botón adentro</td>
</tr>
<tr class="odd">
<td>PAD_BUTTON_OUTSIDE</td>
<td>Botón afuera</td>
</tr>
<tr class="even">
<td>PAD_BUTTON_1 hasta PAD_BUTTON_16</td>
<td>Botones genéricos</td>
</tr>
</tbody>
</table>
<p>Los modos disponibles son:</p>
<table>
<thead>
<tr class="header">
<th>PAD_BUTTON_KEYBOARD</th>
<th>Mapear teclado</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PAD_BUTTON_MOUSE</td>
<td>Mapear ratón</td>
</tr>
<tr class="even">
<td>PAD_BUTTON_JOYSTICK1 hasta PAD_BUTTON_JOYSTICK4</td>
<td>Mapear un joystick</td>
</tr>
</tbody>
</table>
<p>El parámetro &lt;value&gt; dependerá del modo que se utilice. En el caso del teclado, se podrá indicar la tecla que se quiere mapear, por ejemplo: KEY_A (véase apéndice Constantes de Teclado)</p>
<p>En el caso del ratón, se puede indicar: MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE, MOUSE_DBL_LEFT, MOUSE_DBL_RIGHT.</p>
<p>En el caso del joystick, se indicará un número entero que identificará el botón según el fabricante. El número generalmente comienza en cero.</p>
<p>function <strong>GetButtonMode</strong> (butID, channel) : int</p>
<p>Dado el ID de botón &lt;butID&gt; y el canal &lt;channel&gt; obtendremos el modo asignado.</p>
<p>function <strong>GetButtonValue</strong> (butID, channel) : int</p>
<p>Dado el ID de botón &lt;butID&gt; y el canal &lt;channel&gt; obtendremos el valor asignado.</p>
<p>function <strong>IsButton</strong> (butID) : bool</p>
<p>Permite saber si un botón se encuentra presionado o no.</p>
<h1 id="uso-de-vr-script-para-generar-código-asm">Uso de VR-SCRIPT para generar código ASM</h1>
<p>Para convertir VR-SCRIPT a código nativo de una CPU, por ejemplo, un Z80/R800 o un MOS, se utiliza la herramienta “AS”. Puedes ver información sobre el uso de esta herramienta en los comandos VR-DOS.</p>
<p>La forma de escribir código VR-SCRIPT para usar esta herramienta es un tanto más restrictiva que lo visto hasta ahora. Es necesario establecer los tipos de las variables, constantes, funciones y parámetros, además de tener que dar acceso a los prototipos de las funciones externas (otros módulos) que se quieran utilizar. En ese sentido, se trataría de trabajar igual que haríamos con un compilador C/C++ convencional.</p>
<p>Conceptos:</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>ENTORNO</th>
<th>Hace referencia a si el programa a crear es para MSX o SPECTRUM o COMMODORE o para una ROM MSX con mapper KonamiSCC o un programa MSX-DOS para MSX, etc. Un entorno no solo hace referencia a un sistema con su CPU y hardware dedicado, sino también a los distintos sistemas operativos o aplicaciones donde vaya a ejecutarse.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CRT</td>
<td>Sería el código utilizado como arranque de nuestra aplicación. Es el punto de entrada (según el tipo de entorno) y desde aquí se inicializa todo lo necesario para poder ejecutar lo que sería nuestro “main” (el punto de entrada del programa).</td>
</tr>
<tr class="even">
<td>LIBRERIA</td>
<td>Conjunto de funciones, genéricas o no, que sirven para ayudar a la creación y gestión de nuestro programa.</td>
</tr>
<tr class="odd">
<td>CPU DESTINO</td>
<td>Hace referencia a la CPU para la cual queremos convertir el código script. En la conversión del código script se generará código ASM nativo que requerirá de un compilado y finalmente de un enlazado para generar un binario final entendible por esta CPU.</td>
</tr>
<tr class="even">
<td>BANCOS</td>
<td>El concepto de banco hace referencia a un bloque de código, generalmente de 8192 bytes (8 Kb), aunque puede tener otro tamaño, que permite la distribución del código y/o datos fuera del área de direccionamiento de la CPU destino.</td>
</tr>
</tbody>
</table>
<p>El proceso de generación del binario final sería:</p>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 10%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>0</th>
<th>ARCHIVOS FUENTES</th>
<th>Serían archivos .ASM, .PI, .LIB. Todos ellos conforman el código que usaremos para crear nuestro programa. Entre ellos tendremos uno que será el CRT.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>PREPROCESAMIENTO</td>
<td>En el caso de los archivos script (.PI) será necesario convertirlos a archivos .ASM de la CPU destino.</td>
</tr>
<tr class="even">
<td>2</td>
<td>COMPILADO</td>
<td>Una vez tenemos todos los archivos fuente generados (todos serán archivos .ASM), se compilarán para generar un archivo objeto (.O).</td>
</tr>
<tr class="odd">
<td>3</td>
<td>ENLAZADO</td>
<td>Los archivos objetos se enlazarán, resolviendo direcciones y etiquetas, para generar un binario resultante final.</td>
</tr>
</tbody>
</table>
<p>Ejemplo de CRT:</p>
<pre><code>class MSX_CRT_ROM_ASCII8
{
    externals:
        function Init () : void;

    function _main() : void
    {
        native
        {
            .romheader

            // ASCII 8 MAPPER
            ld a, 0
            ld (0x6000), a          
            ld a, 1
            ld (0x6800), a          
            ld a, 2
            ld (0x7000), a          
            ld a, 3
            ld (0x7800), a          
            //clear RAM (first 4kb only)    
            ld  bc, 1024*4
            ld  hl, 0xc000
            ld  de, 0xc001
            ld  (hl),0
            ldir
            di
            im  1
            ld  sp, 0xF380
            ei
            call Init
        }
    }
}</code></pre>
<p>En el ejemplo de antes especificamos que la función Init tiene un prototipo concreto y que se encuentra fuera de ese script. En nuestro caso, <strong>Init</strong> sería el punto de entrada de nuestro programa.</p>
<p>Si en vez de Init queremos usar otro nombre, no habría ningún problema en hacerlo.</p>
<p>En este caso, en este CRT, se crean 16 bytes que conforman la cabecera de una ROM MSX. Eso se hace con la palabra reservada <strong>.romheader</strong>. Por tanto, los primeros 16 bytes de nuestro binario serán la cabecera que contiene los valores:</p>
<pre><code>41 42 10 40 00 00 00 00 00 00 00 00 00 00 00 00</code></pre>
<p>El 0x41 y 0x42 es una marca para que la BIOS del MSX reconozca que hay un cartucho ahí. Los siguientes 16 bits son la dirección de comienzo, en este caso 0x4010. Aquí decir, que en este caso es 0x4010 (hexadecimal) porque al enlazador le vamos a decir que use como dirección inicial para el código la 0x4000 y para RAM (variables) la 0xC000. Si al enlazador le dijésemos que queremos ubicar el código en otra dirección, <strong>.romheader</strong> lo tendría en cuenta.</p>
<p>Cada CRT ha de inicializar lo necesario para crear y ajustarse al entorno requerido.</p>
<p>Teniendo el CRT necesario, necesitaremos las funciones para que nuestro programa haga lo pertinente. Lo normal es que tengamos funciones que sean comunes entre diferentes programas: estas funciones las podemos tener en una librería. Lo bueno de una librería es que no es necesario tener que recompilarla cada vez. De todos modos, no es obligatorio tener una librería: podemos tener todos los fuentes que sean necesarios y compilarlos cada vez que queramos generar el binario final.</p>
<p>Un ejemplo de llamada de la herramienta para generar un binario sería:</p>
<pre><code>as /CODE 0x4000 /DATA 0xC000 /SIZE 256K /OUT game.rom msx_crt.pi msxlib.pi wyz_psg_version_2.asm game.pi</code></pre>
<p>Podemos agregar tantos PI como ASM como LIB requiramos. Lo importante es tener en cuenta el orden, ya que es como se van a ir distribuyendo en el espacio de direccionamiento: por eso es importante que el primero en ese orden sea el CRT.</p>
<p>De hecho, podríamos tener todo en un único archivo. Veamos este ejemplo:</p>
<pre><code>.CPU MOS6510
.ORG 0x0801
;header
.db 0x0C, 0x08, 0x0A, 0x00, 0x9E, 0x20
.db 0x34, 0x30, 0x39, 0x36, 0x00, 0x00
.db 0x00
; Start in 0x1000
.ds (0x1000 - $), 0xFF
start:
    lda #17             
    sta 53272; POKE 53272,23 :REM LOWER/UPPER CASE MODE
    ldx #0x00                   
loop: 
    lda message,x                   
    jsr 0xFFD2
    inx                     
    cpx #0x0c                       bne loop                            rts
message:
    .petsciiz &quot;Hello World!&quot;</code></pre>
<p>Este programa ASM sirve para la CPU de los Commodore 64, el MOS6510. El programa es un sencillo “Hello World” y el entorno es un programa BASIC de C64. Los programas BASIC de C64 se ubican en la dirección 0x801. También requieren de una cabecera.</p>
<p>En este caso, desde la consola VR-DOS haríamos:</p>
<pre><code>as /OUT hello.prg hello.asm</code></pre>
<p>Incluir cabeceras de módulos externos</p>
<p>Podemos hacer uso o referencia a funciones que se encuentran en otros archivos de script. Veamos un ejemplo:</p>
<pre><code>class Game partial Game_H, Player_H, Title_H, Outro_H
{
}</code></pre>
<p>En el script Game.pi, hacemos uso de funciones existentes en otros scripts como Player.pi, Title.pi y Outro.pi.</p>
<p>Mediante partial, lo que hacemos es incluir el código existente en los archivos Game_H.pi, Player_H.pi, Title_H.pi y Outro_H.pi. Veamos que hay en Player_H.pi por ejemplo:</p>
<pre><code>class Player_H
{
    defines:
        MAX_PLAYER_SPEED : int = 2;
        DEF_PLAYER_SPEED : int = 4;
        MAX_PLAYER_LIVES : int = 3;
        DEF_PLAYER_LIVES : int = 3;
        MAX_STAGE : int = 5;
    externals:
        g_playerSpeed : ubyte;
        g_playerPower : ubyte;
        g_playerScore : uint;
        g_playerHiScore : uint;
        g_playerNextLife : uint;
        g_playerStage : ubyte;
        g_playerLives : ubyte;
    #metadata _BANK_CODE
    function Player_Init (_mai : pointer(MapActorInfo)) : pointer(GameActor);
    function Player_AddScore(_sc : uint) : void;
    function Player_NextStage() : void;
    #metadata
}</code></pre>
<p>En este caso, Player_H.pi incluye los prototipos públicos que definimos en Player.pi, además de constantes y referencias a variables.</p>
<p>La directiva <strong>#metadata</strong> en este caso permite ofrecer información al transcompilador que convierte script a ensamblador. En este caso, al hacer _BANK_CODE está indicando que los prototipos declarados en esa sección se guardan en una zona especial para ser accedida mediante un mecanismo de cambio de banco.</p>
<p>Librerías matemáticas obligatorias</p>
<p>El transcompilador que convierte el código script a ensamblador asume que existirán para el enlazador una serie de funciones como estas:</p>
<pre><code>function _mul_u8_u8 () : ushort
function _mul_s8_s8 () : short
function _mul_u16_u8 () : ushort
function _mul_s16_s8 () : short
function _mul_u16_u16 () : ulong
function _mul_s16_s16 () : long
function _div_u8_u8 () : ubyte
function _div_s8_s8 () : ushort
function _div_u16_u8 () : ushort
function _div_s16_s8 () : ushort
function _div_u16_u16 () : ushort
function _div_s16_s16 () : ushort
function _div_u32_u8 () : ulong
function _div_s32_s8 () : ulong
function _div_u32_u16 () : ushort
function _add_u32_u32 (_a : long, _b : long) : long</code></pre>
<p>Además de estas, habrá otras relacionadas con números flotantes y combinaciones de bits y signo para abordar operaciones complejas que no soporte directamente la CPU de destino.</p>
<p>Estas funciones generalmente se encontrarán junto a la librería de cada entorno de programación.</p>
<p>Especificar tipos</p>
<p>Es absolutamente necesario especificar tipos en:</p>
<ul>
<li><p>Constantes</p></li>
<li><p>Variables</p></li>
<li><p>Valores de retorno en función</p></li>
<li><p>Parámetros de las funciones</p></li>
</ul>
<p>También debe especificar en cualquier referencia a un tipo de dato.</p>
<p>Referencia a archivos de datos externos</p>
<p>Podemos incluir directamente datos embebidos de archivos externos del siguiente modo:</p>
<pre><code>class Resources
{
  #metadata _BANK_DATA
  constants:
    rsc_bmp_stage_1 : list(ubyte) = @&quot;dat/rsc_bmp_stage_1.dat&quot;@];
    rsc_bmp_stage_2 : list(n) = @&quot;dat/rsc_bmp_stage_2.dat&quot;@]; 
  #metadata
}</code></pre>
<p>De esta forma, podemos acceder a esos datos posteriormente. Por ejemplo:</p>
<pre><code>Bitmap_Load (_bank(rsc_bmp_stage_2), rsc_bmp_stage2, 0, VDP_LOAD_ALLBANKS); </code></pre>
<p>La palabra reservada <strong>_bank</strong> permite saber el banco donde se ha guardado determinada variable.</p>
<p>La etiqueta de la variable indicará la dirección donde se encuentra accediendo con instrucciones de la CPU destino.</p>
<p>Ensamblador inline</p>
<p>Podemos integrar ensamblador directamente en el código script usando la palabra reservada <strong>native</strong>. Ejemplos:</p>
<pre><code>function BIOS_SetVBlankHook (_f : pointer) : void
{
    native
    {
        LD  A, 0xC3
        LD  L, 4(ix)
        LD  H, 5(ix)
        DI
        LD  (0xFD9F), A
        LD  (0xFDA0), HL
        EI
    }
}</code></pre>
<pre><code>function BIOS_GetCharSet() : ubyte
{
    native
    {
        ld hl, 0x002B
        ld a, (hl)
        and a, 0x0F
        ld l, a
    }
    #pragma errorifnoreturntype=off
    return;
    #pragma errorifnoreturntype=on
} </code></pre>
<p>Mediante el #pragma anterior evitamos que no haya errores por salir de la función sin devolver un valor; realmente se retorna en el registro L, pero el transcompilador no detecta esto y por eso hay que indicar esta excepción.</p>
<p>Acceso a los parámetros desde lenguaje nativo con Z80/R800</p>
<p>El acceso a los parámetros se hace usando el registro de indexación IX. A partir del offset 4 se accede a los distintos parámetros. La pila se encuentra así al entrar a una función con parámetros:</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>…</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>4(ix)</td>
<td>A partir de aquí, accedemos a los parámetros de la función (si existen)</td>
</tr>
<tr class="even">
<td>3(ix)</td>
<td>IX High</td>
</tr>
<tr class="odd">
<td>2(ix)</td>
<td>IX Low (copia de seguridad de IX, para recuperarlo una vez se sale de la función)</td>
</tr>
<tr class="even">
<td>1(ix)</td>
<td>PC high</td>
</tr>
<tr class="odd">
<td>0(ix)</td>
<td>PC low (dirección de retorno una vez salimos de la función)</td>
</tr>
<tr class="even">
<td>-1(ix)</td>
<td>A partir de aquí, reservado para las variables locales (si existen)</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>Retorno de valores en función desde lenguaje nativo con Z80/R800</p>
<table>
<thead>
<tr class="header">
<th><strong>Tamaño de dato</strong></th>
<th><strong>Registro</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8</td>
<td>L</td>
</tr>
<tr class="even">
<td>16</td>
<td>HL</td>
</tr>
<tr class="odd">
<td>32</td>
<td>DE:HL</td>
</tr>
</tbody>
</table>
<h1 id="programación-del-v9968">Programación del V9968</h1>
<p>El V9968 hace referencia a un hipotético chip, no existente como hardware real, pero que se ha sintetizado por software para permitir una evolución “razonable” de la versión del chip de vídeo utilizado en los modelos más avanzados de la familia MSX. El V9968 es compatible con el V9958 y añade las siguientes mejoras:</p>
<ul>
<li><p>Hasta 16Mb de VRAM (24 bits de direccionamiento).</p></li>
<li><p>Hasta 256 páginas SCREEN 8/10/12/13.</p></li>
<li><p>Se han extendido los registros #35, #39, #43 para soportar 16 bits.</p></li>
<li><p>ID VDP Chip = 3 (Status Register #1 - Bits 1-5).</p></li>
<li><p>Paleta de colores de 24 bits, RGB888.</p></li>
<li><p>Nuevo registro #48 para completar con 24 bits la dirección PNT.</p></li>
<li><p>Nuevo modo de pantalla de texto multicolor 80x24.</p></li>
<li><p>Nuevo modo de pantalla bitmap 256x212 paleta de 256 colores de 16M.</p></li>
</ul>
<h1 id="programación-del-r8000">Programación del R8000</h1>
<p>El R8000 hace referencia a un hipotético chip, no existente como hardware real, que se ha sintetizado por software para ofrecer compatibilidad Z80/R800 además de nuevas funcionalidades:</p>
<ul>
<li>Nueva instrucción TRAP. Codificación: ED FD nn nn. Tamaño: 4 bytes.</li>
</ul>
<p>La función TRAP permite hacer llamadas dentro y fuera del entorno de la máquina virtual con la intención de acceder a características especiales del sistema MSXVR. Según el valor de 16 bits especificado en la instrucción y del valor de ciertos registros del Z80/R800, podemos disponer de las siguientes funcionalidades:</p>
<table>
<thead>
<tr class="header">
<th>0000</th>
<th>Aplicar un Breakpoint.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0001</td>
<td>Detectar si es un MSXVR o no.</td>
</tr>
<tr class="even">
<td>0002</td>
<td>Cambiar el comportamiento del Slot de MSX a modo MSXVR o viceversa.</td>
</tr>
<tr class="odd">
<td>0003</td>
<td>Invocar una función de VR-SCRIPT nativa.</td>
</tr>
<tr class="even">
<td>0004</td>
<td>Manipulación del puerto DB37.</td>
</tr>
<tr class="odd">
<td>0005</td>
<td>Encender/Apagar LEDS.</td>
</tr>
<tr class="even">
<td>0006</td>
<td>Activar/Desactivar Control Remoto.</td>
</tr>
</tbody>
</table>
<p><strong>0000</strong> - Aplicar un breakpoint</p>
<p>Detiene la ejecución de la máquina virtual y lanza el depurador.</p>
<p>Ejemplo:</p>
<pre><code>trap 0x0000</code></pre>
<p><strong>0001</strong> - Detectar si es un MSXVR o no.</p>
<p>Permite saber si estamos o no en un MSXVR mirando el flag Z. Finalizada la instrucción, si Z está activo es que estamos en un MSXVR.</p>
<p>Ejemplo:</p>
<pre><code>trap 0x0001
call z, OnMSXVRMode             </code></pre>
<p><strong>0002</strong> - Cambiar el comportamiento del Slot de MSX a modo MSXVR o viceversa</p>
<p>Asignar el <strong>modo de SLOT</strong>, MSX o MSXVR. Usaremos los cuatro bits bajos del registro A para determinarlo. Si el registro A=0, usaremos modo MSX, y si A&lt;&gt;0, modo MSXVR. Finalizada la instrucción, si Z está activo es que se ha puesto el modo de slot MSXVR.</p>
<p>Ejemplo donde configuramos el slot en modo MSXVR:</p>
<pre><code>ld a, 1
trap 0x0002 </code></pre>
<p><strong>0003</strong> - Invocar una función de VR-SCRIPT nativa</p>
<p>Llamada a una función de un contexto VR-SCRIPT. En nuestra máquina virtual, hemos de haber establecido tanto el contexto como la función a invocar. Tras el retorno de esta función, cualquier flag o registro podría haberse modificado.</p>
<p>Véase <em>VirtualMachineController::SetCPUNativeCallback.</em></p>
<p>Ejemplo de uso de la función Nativa:</p>
<pre><code>class Example implements DOS_Program
{
    virtual Start()
    {
        _msx = GetEngine().CreateVirtualMachine(&quot;msx1&quot;);
        _msx.InsertCartridge(0, &quot;skyjaguar2/game.rom&quot;, &quot;dvg1&quot;);
        _msx.SetCPUNativeCallback(this, &quot;OnNativeCB&quot;);
    }
    function OnNativeCB()
    {
        GetEngine().LogVerbose(&quot;NATIVE CALL!!&quot;);
    }
}</code></pre>
<p>Cuando en el código de game.rom invoquemos a “trap 0x0003” se llamará a la función OnNativeCB.</p>
<p><strong>0004</strong> - Manipulación del puerto DB37</p>
<p>Engloba todas las operaciones relacionadas con este puerto.</p>
<p>A = código de función</p>
<p>A = 0, Dirección de los 32 bits (0=salida, 1=entrada)</p>
<p>A = 1, Pull-ups de los 32 bits (0=no, 1=sí)</p>
<p>A = 2, Lectura de 32 bits</p>
<p>A = 3, Escritura de 32 bits</p>
<p>HL = 16 bits bajos</p>
<p>DE = 16 bits altos</p>
<p><strong>0005</strong> - Encender/Apagar LEDS</p>
<p>Permite encender y apagar los LEDs de usuario. Para ello usaremos cada bit del registro A. Si el bit es 0 se apagará y si el bit es 1 se encenderá. El orden de los bits corresponde con el orden de izquierda a derecha de los LEDs.</p>
<p>Ejemplo donde encendemos todos los leds:</p>
<pre><code>ld a, 255
trap 0x0005</code></pre>
<p><strong>0006</strong> - Activar/Desactivar Control Remoto</p>
<p>Activa o desactiva el control remoto (REM) mirando el valor del registro A. Si el registro es 0, apagará el control remoto, y si es distinto de 0, lo encenderá.</p>
<p>Ejemplo donde apagamos el control remoto:</p>
<pre><code>ld a, 0
trap 0x0006</code></pre>
<p><strong>0007</strong> - Obtener el idioma</p>
<p>Permite obtener el código del idioma seleccionado en el sistema. El valor se obtiene en el registro HL. Los códigos de idioma son:</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>Español ES</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Inglés GB</td>
</tr>
</tbody>
</table>
<h1 id="funciones-del-api-nativo">Funciones del API Nativo</h1>
<p>El VR-SCRIPT hace uso de funciones creadas para desempeñar todo tipo de acciones. Estas cubren un amplio espectro de posibilidades y permiten tratar diferentes tipos de datos, estructuras y objetos.</p>
<p>Estas funciones pueden o no devolver un valor. La forma de invocarlas es:</p>
<p>_valor = &lt;nombre_funcion&gt;(argumentos);</p>
<p>O bien:</p>
<p>&lt;nombre_funcion&gt;(argumentos)</p>
<p>Los argumentos son una serie de expresiones o valores separados por comas. También es posible que la función no requiera argumentos; en ese caso, no se le pasaría ninguno:</p>
<p>&lt;nombre_funcion&gt;()</p>
<p>Ejemplos:</p>
<pre><code>_a = &quot;5&quot;;
_a = int(_a);
_str = &quot;El dinosaurio es un ser prehistorico&quot;;
_ix = String_Find(_str, &quot;ser&quot;);</code></pre>
<p>A continuación se enumerarán y detallarán las diferentes funciones existentes en el API Nativo. Salvo que sea estrictamente necesario, se recomienda siempre el uso de los objetos y clases a nivel de VR-ENGINE para trabajar con texturas, archivos, bases de datos, etc. en vez de sus funciones API nativas. La interfaz que se crea a nivel VR-ENGINE es siempre la más apropiada y utiliza el API Nativo de forma óptima y segura. El equivalente podría ser la BIOS de los MSX. En los MSX se recomienda usar la BIOS para acceder el VDP, PSG, etc. ya que saltarse la BIOS y acceder directamente al hardware (en nuestro caso el API Nativo), podría incurrir en incompatibilidades con otras máquinas.</p>
<h2 id="casting">Casting</h2>
<p>Funciones relacionadas con la conversión de tipos de datos.</p>
<p>function <strong>bool</strong> (x) : bool</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a bool.</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>TIPO de &lt;x&gt;</th>
<th>RESULTADO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>Cuando &lt;x&gt; sea “true” el resultado será verdadero, y cuando &lt;x&gt; sea “false” el resultado será falso. En cualquier otro caso, se convertirá la cadena a un entero, y si el valor es distinto de cero se considerará verdadero, y si es cero, falso.</td>
</tr>
<tr class="even">
<td>Numérico, Puntero u Objeto</td>
<td>Cuando &lt;x&gt; sea distinto de cero, el resultado será verdadero, y en caso contrario el resultado será falso.</td>
</tr>
<tr class="odd">
<td>Lista</td>
<td>El resultado será siempre falso.</td>
</tr>
</tbody>
</table>
<p>function <strong>byte</strong> (x) : byte</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a byte.</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>TIPO de &lt;x&gt;</th>
<th>RESULTADO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>Siempre que el valor de &lt;x&gt; contenga una cadena de caracteres que represente un número, se devolverá ese valor en formato byte. Esto implica convertir la cadena a número y quedarse con los 8 bits menos significativos. Si la cadena no es un número, devolverá 0.</td>
</tr>
<tr class="even">
<td>Numérico, Puntero u Objeto</td>
<td>Se ajustará el valor de &lt;x&gt; al tipo byte quedándose siempre con los 8 bits menos significativos.</td>
</tr>
<tr class="odd">
<td>Lista</td>
<td>El resultado será siempre 0.</td>
</tr>
</tbody>
</table>
<p>function <strong>ubyte</strong> (x) : ubyte</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a unsigned byte.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “unsigned byte”.</p>
<p>function <strong>short</strong> (x) : short</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a short.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “short”, que permite representar números de 16 bits con signo.</p>
<p>function <strong>ushort</strong> (x) : ushort</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a unsigned short.</p>
<p>El funcionamiento es idéntico al de la función <em>byte</em>, pero dando como resultado el tipo “unsigned short”, que permite representar números de 16 bits sin signo.</p>
<p>function <strong>int</strong> (x) : int</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a int.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “int”, que permite representar números de 32 bits con signo.</p>
<p>function <strong>uint</strong> (x) : uint</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a unsigned int.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “unsigned int”, que permite representar números de 32 bits sin signo.</p>
<p>function <strong>long</strong> (x) : long</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a long.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “long”, que permite representar números de 64 bits con signo.</p>
<p>function <strong>ulong</strong> (x) : ulong</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a unsigned long.</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “unsigned long”, que permite representar números de 64 bits sin signo.</p>
<p>function <strong>float</strong> (x) : float</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a float (número decimal simple).</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “float”, que permite representar números de 32 bits de coma flotante.</p>
<p>function <strong>double</strong> (x) : double</p>
<p>Convierte el tipo del valor pasado en &lt;x&gt; a double (número decimal doble).</p>
<p>El funcionamiento es idéntico al de la función <em>byte,</em> pero dando como resultado el tipo “double”, que permite representar números de 64 bits de coma flotante.</p>
<p>function <strong>string</strong> (x) : string</p>
<p>Convierte el valor pasado en &lt;x&gt; al tipo string (cadena de caracteres).</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>TIPO de &lt;x&gt;</th>
<th>RESULTADO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Numérico, Puntero u Objeto</td>
<td>Convierte el valor en su representación dígito a dígito en cadena de caracteres ASCII.</td>
</tr>
<tr class="even">
<td>Lista</td>
<td>Convierte la lista en una versión ASCII de todo su contenido.</td>
</tr>
<tr class="odd">
<td>Bool</td>
<td>Si es verdadero devolverá “true” y si es falso devolverá “false”.</td>
</tr>
</tbody>
</table>
<p>Ejemplos:</p>
<pre><code>_str = string(5);</code></pre>
<p>_str valdrá “5”.</p>
<pre><code>_str = string([5, 6, &quot;hola&quot;, -5.5]);</code></pre>
<p>_str valdrá “[5, 6, "hola", -5.5]”.</p>
<pre><code>_str = string(true);</code></pre>
<p>_str valdrá “true”.</p>
<h2 id="matemáticas-1">Matemáticas</h2>
<p>Funciones relacionadas con el ámbito matemático.</p>
<p>function <strong>abs</strong> (x) : float</p>
<p>Valor absoluto de &lt;x&gt;.</p>
<p>function <strong>acos</strong> (x) : float</p>
<p>Arcocoseno de &lt;x&gt; en radianes.</p>
<p>function <strong>asin</strong> (x) : float</p>
<p>Arcoseno de &lt;x&gt; en radianes.</p>
<p>function <strong>atan</strong> (x) : float</p>
<p>Arcotangente de &lt;x&gt; en radianes.</p>
<p>function <strong>atan2</strong> (y, x) : float</p>
<p>Arcotangente de dos parámetros. Devuelve, expresado en radianes, el ángulo formado entre el eje X positivo y la recta que conecta el origen con un punto de coordenadas (x,y) ≠ (0,0) del plano euclidiano.</p>
<p>function <strong>ceil</strong> (x) : float</p>
<p>Redondea por arriba, al entero más cercano, el número &lt;x&gt;.</p>
<p>function <strong>floor</strong> (x) : float</p>
<p>Redondea por abajo, al entero más cercano, el número &lt;x&gt;.</p>
<p>function <strong>clamp</strong> (x, min, max) : float</p>
<p>Ajusta el valor de &lt;x&gt;, si es necesario, para asegurar que su valor siempre esté entre el mínimo &lt;min&gt; y el máximo &lt;max&gt;. Si el valor de &lt;x&gt; es menor que &lt;min&gt; se devolverá &lt;min&gt;, y si el valor de &lt;x&gt; es mayor que &lt;max&gt; se devolverá &lt;max&gt;.</p>
<p>function <strong>cos</strong> (x) : float</p>
<p>Coseno de &lt;x&gt; en radianes.</p>
<p>function <strong>degtorad</strong> (x) : float</p>
<p>Convierte el valor expresado en grados de &lt;x&gt; a radianes.</p>
<p>function <strong>radtodeg</strong> (x) : float</p>
<p>Convierte el valor expresado en radianes de &lt;x&gt; a grados.</p>
<p>function <strong>dim</strong> (x, y = 0) : list</p>
<p>Redimensiona una lista. Permite crear listas de listas según las dimensiones establecidas en el argumento &lt;x&gt;. Esta lista se inicializa con el valor especificado en &lt;y&gt;. Si no se especifica valor, se considerará cero.</p>
<p>Ejemplo:</p>
<pre><code>_ret = dim([5, 3], 8);</code></pre>
<p>Eso haría que &lt;_ret&gt; fuese una lista de dos dimensiones. Sería similar a hacer en C algo como: int _ret[5][3] = {8};</p>
<p>function <strong>exp</strong> (x) : float</p>
<p>Exponencial del número &lt;x&gt;.</p>
<p>function <strong>frand</strong> (x, y) : float</p>
<p>Número aleatorio generado entre &lt;x&gt; e &lt;y&gt;. El tipo del valor devuelto es &lt;float&gt;.</p>
<p>function <strong>rand</strong> (arg0, arg1) : int</p>
<p>Número aleatorio generado entre &lt;x&gt; e &lt;y&gt;. El tipo del valor devuelto es &lt;int&gt;.</p>
<p>function <strong>isnan</strong> (x) : bool</p>
<p>Indica si el número es válido o se trata de una indefinición matemática.</p>
<p>function <strong>log</strong> (x) : float</p>
<p>Logaritmo natural (en base e) del número &lt;x&gt;.</p>
<p>function <strong>log10</strong> (x) : float</p>
<p>Logaritmo en base 10 del número &lt;x&gt;.</p>
<p>function <strong>range</strong> (x, y, step = 1) : list</p>
<p>Obtiene una lista que contiene los números entre &lt;x&gt; e &lt;y&gt; con paso especificado en el argumento &lt;step&gt;.</p>
<p>Ejemplo:</p>
<pre><code>_ret = range(3, 8, 2);</code></pre>
<p>Haría que &lt;_ret&gt; valiese: [3, 5, 7]</p>
<p>function <strong>pow</strong> (x, y) : float</p>
<p>Calcula la potencia de la base &lt;x&gt; elevada al exponente &lt;y&gt;.</p>
<p>function <strong>round</strong> (x) : int</p>
<p>Redondea por arriba un número entero &lt;x&gt;. Equivalente a la función <em>ceil</em>.</p>
<p>function <strong>sign</strong> (x) : float</p>
<p>Devuelve el signo de un número &lt;x&gt;. Si es positivo devolverá 1 y si es negativo devolverá -1. En caso de que &lt;x&gt; sea 0, devolverá también 0.</p>
<p>function <strong>sin</strong> (x) : float</p>
<p>Seno de &lt;x&gt; en radianes.</p>
<p>function <strong>slerp</strong> (min, max, t) : float</p>
<p>Devuelve un valor entre &lt;min&gt; y &lt;max&gt; en función del factor &lt;t&gt;. El factor &lt;t&gt; será un valor entre 0 y 1. Por tanto, si &lt;t&gt; = 0, devolverá &lt;min&gt;, y si &lt;t&gt; = 1, devolverá &lt;max&gt;.</p>
<p>function <strong>sqrt</strong> (x) : float</p>
<p>Raíz cuadrada de &lt;x&gt;.</p>
<p>function <strong>srand</strong> (x)</p>
<p>Semilla para la generación de números aleatorios. En función de este valor &lt;x&gt;, las llamadas a <em>rand</em> y <em>frand</em> se verán afectadas.</p>
<p>function <strong>tan</strong> (x) : float</p>
<p>Tangente de &lt;x&gt; en radianes.</p>
<h2 id="matemáticas-avanzadas-2d-y-3d">Matemáticas Avanzadas 2D y 3D</h2>
<p>Conjunto de funciones de ámbito matemático, con un carácter más avanzado y que sirven de ayuda en la computación gráfica tanto bidimensional como tridimensional.</p>
<p>function <strong>AngleSlerp</strong> (from, to, delta) : float</p>
<p>Obtiene el ángulo en radianes, interpolado entre &lt;from&gt; y &lt;to&gt; según &lt;delta&gt;, que podrá ser un valor entre 0 y 1. Si &lt;delta&gt; es cero, devolverá el valor de &lt;from&gt; y si &lt;delta&gt; es uno, devolverá el valor de &lt;to&gt;. Si &lt;delta&gt; es 0.5, devolverá (&lt;to&gt;‑&lt;from&gt;)/2.</p>
<p>function <strong>AngleXBetweenLines</strong> (x1, y1, z1, x2, y2, z2) : float</p>
<p>Determina el componente X del ángulo entre dos vectores (x1,y1,z1) y (x2,y2,z2).</p>
<p>function <strong>AngleYBetweenLines</strong> (x1, y1, z1, x2, y2, z2) : float</p>
<p>Determina el componente Y del ángulo entre dos vectores (x1,y1,z1) y (x2,y2,z2).</p>
<p>function <strong>AngleZBetweenLines</strong> (x1, y1, z1, x2, y2, z2) : float</p>
<p>Determina el componente Z del ángulo entre dos vectores (x1,y1,z1) y (x2,y2,z2).</p>
<p>function <strong>GetNearestPointOnCircle</strong> (x1, y1, x2, y2, cx, cy, cr) : list</p>
<p>Dado un segmento (x1,y1)-(x2,y2) y un círculo (cx, cy) con radio &lt;cr&gt;, se devolverá el punto del segmento más cercano al círculo, indicando también si el segmento corta el círculo. La lista devuelta tendrá los siguientes componentes: [¿hay colisión?, px, py].</p>
<p>function <strong>GetNearestPointOnCurve</strong> (ax, ay, bx, by, cx, cy, dx, dy, px, py) : list</p>
<p>Dada una curva cúbica de Bezier definida con los puntos de control (ax, ay), (bx, by), (cx, cy) y (dx, dy), determina el punto de esa curva más cercano al dado en (px, py). La lista devuelta por la función es: [x, y].</p>
<p>function <strong>GetNearestPointOnLine</strong> (x1, y1, z1, x2, y2, z2, px, py, pz) : list</p>
<p>Dado un segmento definido por (x1,y1,z1) - (x2,y2,z2), busca el punto de dicho segmento más cercano al punto dado en (px,py,pz). El valor devuelto por la función es una lista: [¿en rango?, x, y]. El valor ¿en rango? es un booleano que indica si el punto más cercano está más allá de los extremos del segmento. Téngase en cuenta que (x, y) nunca podrá ser un punto fuera del segmento.</p>
<p>function <strong>GetNearestPointOnTriangle</strong> (x1, y1, z1, x2, y2, z2, x3, y3, z3, px, py, pz) : list</p>
<p>Dado un triángulo con sus tres vértices (x1,y1,z1)-(x2,y2,z2)-(x3,y3,z3), nos permite averiguar el punto de dicho triángulo más cercano a un punto dado (px,py,pz). El valor devuelto por la función es la lista: [¿en rango?, x, y, z]. El valor ¿en rango? hace referencia a si el punto encontrado está dentro de la zona delimitada por los lados del triángulo. (x,y,z) será el punto hallado como más cercano y siempre será un punto contenido en alguno de los tres segmentos del triángulo.</p>
<p>function <strong>GetPerpendicularVector</strong> (x, y, z) : list</p>
<p>A partir de un vector definido como (x,y,z), devuelve el vector perpendicular en formato lista: [x, y, z].</p>
<p>function <strong>GetPlaneFromTriangle</strong> (x1, y1, z1, x2, y2, z2, x3, y3, z3) : list</p>
<p>Dado un triángulo formado por tres vértices (x1,y1,z1) - (x2,y2,z2) - (x3,y3,z3), devolverá la ecuación del plano Ax + By + Cz + D en formato lista: [A, B, C, D].</p>
<p>function <strong>GetRayVector</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Dados dos puntos (x1,y1,z1) y (x2,y2,z2), devolverá el vector con origen (x1,y1,z1) y dirección hacia (x2,y2,z2). El resultado vendrá en la lista: [vx,vy,vz].</p>
<p>function <strong>IncreaseAngle</strong> (now, to, step) : float</p>
<p>Dado un ángulo &lt;now&gt; expresado en radianes, avanzará el paso &lt;step&gt; hasta alcanzar el valor &lt;to&gt;. Véase también <em>IncreaseAngleWithInertia</em>. El paso &lt;step&gt; siempre ha de ser un valor positivo.</p>
<p>Ejemplo:</p>
<pre><code>cur = IncreaseAngle (cur, NUM_PI / 2, GetFTime() * 0.1f);</code></pre>
<p>function <strong>IncreaseAngleWithInertia</strong> (now, to, step) : float</p>
<p>Dado un ángulo &lt;now&gt; expresado en radianes, avanzará el paso &lt;step&gt; hasta alcanzar el valor &lt;to&gt;. La diferencia con la función <em>IncreaseAngle</em> es que se aplica una inercia, o sea, cuanta más distancia haya entre &lt;now&gt; y &lt;to&gt; más deprisa se avanzará, mientras que a medida que nos acercamos al destino, esta velocidad se irá reduciendo.</p>
<p>function <strong>IncreaseValue</strong> (now, to, step) : float</p>
<p>Dado un valor &lt;now&gt;, nos permite avanzar un paso &lt;step&gt; hasta llega al valor &lt;to&gt;. La función tiene en cuenta si ha de sumar o restar el paso; por tanto &lt;step&gt; siempre ha de ser un valor positivo. Véase también <em>IncreaseValueWithInertia</em>.</p>
<p>function <strong>IncreaseValueWithInertia</strong> (now, to, step) : float</p>
<p>Dado un valor &lt;now&gt;, nos permite avanzar un paso &lt;step&gt; hasta llega al valor &lt;to&gt;. La función tiene en cuenta si ha de sumar o restar el paso; por tanto &lt;step&gt; siempre ha de ser un valor positivo. La diferencia con la función <em>IncreaseAngle</em> es que se aplica una inercia, o sea, cuanta más distancia haya entre &lt;now&gt; y &lt;to&gt; más deprisa se avanzará, mientras que a medida que nos acercamos al destino, esta velocidad irá reduciendo.</p>
<p>function <strong>IntersectBoxWithBox</strong> (x1, y1, z1, sx1, sy1, sz1, qx1, qy1, qz1, qw1, x2, y2, z2, sx2, sy2, sz2, qx2, qy2, qz2, qw2) : list</p>
<p>Obtiene la intersección entre dos cajas B1 y B2. Cada caja está representada por la posición de su centro (x,y,z), un tamaño (sx,sy,sz) y una orientación determinada por el cuaternión (qx,qy,qz,qw). El resultado es una lista, donde el primer y único componente indica si las cajas se tocan o no.</p>
<p>function <strong>IntersectLine2DWithCircle</strong> (x1, y1, x2, y2, cx, cy, rad) : list</p>
<p>Dado un segmento (x1,y1)-(x2,y2), permite averiguar si intersecciona/toca un círculo con centro (cx,cy) y radio &lt;rad&gt;. El resultado es una lista [¿hay intersección?, px, py], donde se indica si ha habido intersección y, en tal caso, el punto de corte (px,py).</p>
<dl>
<dt>function <strong>IntersectLine2DWithLine2D</strong> (ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)</dt>
<dd>list
</dd>
</dl>
<p>Dados dos segmentos (ax1,ay1)-(ax2,ay2) y (bx1,by1)-(bx2,by2) la función determina si ambos se cortan en algún punto. El resultado es una lista [¿hay intersección?, px, py] donde se indica si ha habido intersección y, en tal caso, el punto de corte (px, py).</p>
<p>function <strong>IntersectLineWithLine</strong> (ax1, ay1, az1, ax2, ay2, az2, bx1, by1, bz1, bx2, by2, bz2) : list</p>
<p>Dados dos segmentos (ax1,ay1,az1)-(ax2,ay2,az2) y (bx1,by1,bz1)-(bx2,by2,bz2), devolverá si ha habido intersección entre ellos, así como el segmento más corto entre ambos. El resultado es una lista: [¿hay intersección?, ax, ay, az, bx, by, bz].</p>
<p>function <strong>IntersectORectWithORect</strong> (x1, y1, w1, h1, a1, px1, py1, x2, y2, w2, h2, a2, px2, py2) : list</p>
<p>Esta función recibe dos rectángulos orientados R1 y R2 y devuelve información sobre la existencia o no de intersección entre ambos. Un rectángulo orientado está formado por (x,y), que es el punto origen y hace referencia a la esquina superior, su tamaño (w,h), el ángulo de rotación en radianes &lt;a&gt; y el pivote con respecto al cual se rota (px,py), que cuando es (0,0) hace referencia al centro del rectángulo. El resultado es una lista donde el primer y único componente indica si ha habido intersección o los rectángulos se han tocado.</p>
<p>function <strong>IntersectPointWithBox</strong> (x, y, z, bx, by, bz, bsx, bsy, bsz, bqx, bqy, bqz, bqw) : list</p>
<p>Dado un punto (x,y,z), nos permite averiguar si se encuentra dentro de una caja con centro en (bx,by,bz), tamaño (bsx,bsy,bsz) y orientada con el cuaternión (qx,qy,qz,qw). El resultado es una lista donde el primer componente indica si el punto se encuentra dentro o no de la caja.</p>
<p>function <strong>IntersectRayWithPlane</strong> (x, y, z, dx, dy, dz, px, py, pz, pvx, pvy, pvz) : list</p>
<p>Dado un rayo con origen (x,y,z) y dirección (dx,dy,dz), nos permite averiguar si intersecciona con el plano definido por el punto (px,py,pz) y su normal (pvx,pvy,pvz). La función retorna una lista con los valores [¿hay intersección?, D, cx, cy, cz], donde se indica si hubo intersección, la componente D del plano y el punto de corte (cx,cy,cz).</p>
<p>function <strong>IntersectRayWithSphere</strong> (x, y, z, dx, dy, dz, sx, sy, sz, srad) : list</p>
<p>Permite averiguar si hay intersección entre un rayo con origen (x,y,z) y dirección (dx,dy,dz) y una esfera con centro (sx,sy,sz) y radio &lt;srad&gt;. La función devolverá una lista con los elementos [¿hay intersección?, distancia de la esfera al punto de corte, px, py, pz], donde (px, py, pz) es el punto de corte.</p>
<dl>
<dt>function <strong>IntersectRectWithRect</strong> (x1, y1, w1, h1, x2, y2, w2, h2)</dt>
<dd><p>list</p>
</dd>
</dl>
<p>Dados dos rectángulos R1(x1,y1,w1,h1) y R2(x2,y2,w2,h2), nos permite conocer el resultado de la intersección de ambos. El resultado vendrá en una lista [¿hay intersección?, rx, ry, rw, rh], donde se indica si hay intersección y el rectángulo resultado de la misma.</p>
<p>function <strong>UnionRectWithRect</strong> (x1, y1, w1, h1, x2, y2, w2, h2) : list</p>
<p>Dados dos rectángulos R1(x1,y1,w1,h1) y R2(x2,y2,w2,h2), nos permite conocer el resultado de la unión de ambos. Este resultado vendrá en una lista [rx, ry, rw, rh], donde se define el rectángulo que contiene a R1 y R2.</p>
<p>function <strong>IntersectSphereWithSphere</strong> (sx1, sy1, sz1, srad1, sx2, sy2, sz2, srad2) : list</p>
<p>Dadas dos esferas S1 y S2, donde para cada esfera se indica su centro y su radio, la función permite averiguar si ambas se tocan. El resultado es una lista [¿se tocan?, distancia] donde se indica si ambas esferas se tocan y la distancia entre los centros de ambas esferas.</p>
<p>function <strong>PointAdd</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Dados dos puntos (x1,y1,z1) y (x2,y2,z2), devuelve una lista con el punto resultado de sumar sus componentes: [x1+x2, y1+y2, z2+z2].</p>
<p>function <strong>PointCross</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Dados dos vectores (x1,y1,z1) y (x2,y2,z2), devuelve una lista con el punto resultado de realizar el producto vectorial: [(y1 * z2) - (z1 * p2), (z1 * p2) - (x1 * p2), (x1 * p2) - (y1 * p2)].</p>
<p>function <strong>PointDistance</strong> (x1, y1, z1, x2, y2, z2) : float</p>
<p>A partir de dos puntos (x1,y1,z1) y (x2,y2,z2) se obtiene la distancia entre ambos puntos, también denominada longitud del vector (x2-x1,y2-y1,z2-z1).</p>
<p>function <strong>PointDistance2D</strong> (x1, y1, x2, y2) : float</p>
<p>A partir de dos puntos 2D (x1,y1) y (x2,y2) se obtiene la distancia entre ambos puntos, también denominada longitud del vector (x2-x1,y2-1).</p>
<p>function <strong>PointDiv</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Dados dos puntos (x1,y1,z1) y (x2,y2,z2), se obtiene como resultado una lista donde cada elemento corresponde a la división entre componentes: [x1/x2,y1/y2,z1/z2].</p>
<p>function <strong>PointDot</strong> (x1, y1, z1, x2, y2, z2) : float</p>
<p>Calcula el producto escalar entre dos vectores (x1,y1,z1) y (x2,y2,z2). El producto escalar es el coseno del ángulo formado por estos dos vectores.</p>
<p>function <strong>PointInORect</strong> (x, y, rx, ry, rw, rh, ra, rpx, rpy) : bool</p>
<p>Determina si un punto (x,y) se encuentra contenido dentro de un rectángulo (rx,ry,rw,rh) con orientación definida por el ángulo &lt;ra&gt; y el pivote (rpx,pry).</p>
<p>function <strong>PointInRect</strong> (x, y, rx, ry, rw, rh) : bool</p>
<p>Determina si un punto (x,y) se encuentra dentro de un rectángulo (rx,ry,rw,rh).</p>
<p>function <strong>PointInTriangle</strong> (x, y, z, x1, y1, z1, x2, y2, z2, x3, y3, z3) : bool</p>
<p>Indica si un punto (x,y,z) está contenido dentro de un triángulo con vértices (x1,y1,z1)-(x2,y2,z2)-(x3,y3,z3). En esta comprobación, si el punto está en uno de los segmentos que definen el triángulo también devolverá verdadero.</p>
<p>function <strong>PointInTriangle2D</strong> (x, y, x1, y1, x2, y2, x3, y3) : bool</p>
<p>Indica si un punto (x,y) está contenido dentro de un triángulo con vértices (x1,y1)-(x2,y2)-(x3,y3). En esta comprobación, si el punto está en uno de los segmentos que definen el triángulo también devolverá verdadero.</p>
<p>function <strong>PointLength</strong> (x, y, z) : float</p>
<p>Dado un vector (x,y,z), devolverá la longitud del mismo. Véanse también <em>Point_Distance</em> y <em>Point_Distance2D</em>.</p>
<p>function <strong>PointMul</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Dados dos puntos (x1,y1,z1) y (x2,y2,z2), obtiene como resultado la multiplicación entre componentes de ambos puntos: [x1*x2, y1*y2, z1*z2].</p>
<p>function <strong>PointNormalize</strong> (x, y, z) : list</p>
<p>Dado un vector (x,y,z) se obtiene el vector normalizado, esto es, un vector donde sus componentes están definidas entre los valores (-1, 1).</p>
<p>function <strong>PointRotate2D</strong> (x, y, angle) : list</p>
<p>Aplica la rotación de un punto (x,y) un ángulo en radianes &lt;angle&gt; considerando el (0,0) como pivote. El valor devuelto es una lista de dos elementos [rx, ry] con el punto resultante.</p>
<p>function <strong>PointScale</strong> (x, y, z, scale) : list</p>
<p>Aplica una escala &lt;scale&gt; al punto (x,y,z). El valor devuelto es una lista con el punto resultante: [x*scale, y*scale, z*scale].</p>
<p>function <strong>PointSub</strong> (x1, y1, z1, x2, y2, z2) : list</p>
<p>Resta dos puntos (x1,y1,z1) y (x2,y2,z2). El resultado es una lista con la resta componente a componente de ambos puntos: [x1-x2,y1-y2,z1-z2].</p>
<p>function <strong>ProjectPointOnToPlane</strong> (x, y, z, a, b, c, d) : list</p>
<p>Dado un punto (x,y,z), permite proyectar dicho punto sobre un plano (a,b,c,d). Las componentes del plano hacen referencia a la ecuación del plano: a*x+b*y+c*z+d. El valor devuelto es el punto proyectado: [px,py,pz].</p>
<p>function <strong>AngleAxisToQRotation</strong> (x, y, z, angle) : list</p>
<p>Dado un eje definido por un vector (x,y,z) y una rotación &lt;angle&gt; en radianes, obtiene el cuaternión que define esta orientación. El resultado es una lista con el cuaternión [qx,qy,qz,qw]. Véase también <em>QRotationToAngleAxis</em>.</p>
<p>function <strong>QRotationDiff</strong> (qx1, qy1, qz1, qw1, qx2, qy2, qz2, qw2) : list</p>
<p>Dados dos cuaterniones Q1(qx1,qy1,qz1,qw1) y Q2(qx2,qy2,qz2,qw2) aplicaríamos la diferencia entre los dos. El resultado será el cuaternión [qx,qy,qz,qw]. La diferencia es la inversa de Q1 multiplicada por Q2.</p>
<p>function <strong>QRotationToAngleAxis</strong> (x, y, z, w) : list</p>
<p>Dado un cuaternión (x,y,z,w) se devolverá una lista con [ax,ay,az,angle] donde (ax,ay,az) hace referencia al vector/eje y &lt;angle&gt; al ángulo de rotación en radianes de dicho eje. Véase también <em>AngleAxisToQRotation</em>.</p>
<p>function <strong>QRotationToYawPitchRoll</strong> (x, y, z, w) : list</p>
<p>Dado un cuaternión (x,y,z,w) se devolverá una lista con [yaw, pitch, roll]. Véase también <em>YawPitchRollToQRotation</em>.</p>
<p>function <strong>RotatePointWithQRotation</strong> (x, y, z, qx, qy, qz, qw) : list</p>
<p>Esta función permite rotar un punto (x,y,z) alrededor del eje orientado definido por el cuaternión (qx,qy,qz,qw). El resultado es el punto rotado: [rx, ry, rz].</p>
<p>function <strong>RotateVectorAxis</strong> (x, y, z, u, v, w, ang) : list</p>
<p>Permite rotar un punto (x,y,z) alrededor de un eje definido por el vector (u,v,w) un ángulo &lt;ang&gt; expresado en radianes. El resultado es una lista con el punto rotado: [rx, ry, rz].</p>
<p>function <strong>RotateVectorX</strong> (x, y, z, ang) : list</p>
<p>Obtiene la rotación alrededor del eje X del punto (x,y,z) un ángulo &lt;ang&gt; expresado en radianes. El resultado es una lista con el punto rotado: [rx, ry, rz].</p>
<p>function <strong>RotateVectorY</strong> (x, y, z, ang) : list</p>
<p>Obtiene la rotación alrededor del eje Y del punto (x,y,z) un ángulo &lt;ang&gt; expresado en radianes. El resultado es una lista con el punto rotado: [rx, ry, rz].</p>
<p>function <strong>RotateVectorZ</strong> (x, y, z, ang) : list</p>
<p>Obtiene la rotación alrededor del eje Z del punto (x,y,z) un ángulo &lt;ang&gt; expresado en radianes. El resultado es una lista con el punto rotado: [rx, ry, rz].</p>
<dl>
<dt>function <strong>TangentPlaneNormalOfEllipsoid</strong> (x, y, z, ex, ey, ez, erx, ery, erz)</dt>
<dd>list
</dd>
</dl>
<p>Dados un punto (x,y,z) y un elipsoide con centro (ex,ey,ez) y radios (erx,ery,erz) obtendremos como resultado una lista con el vector unitario, normal al plano tangente de la elipsoide en el punto definido (x,y,z).</p>
<p>function <strong>YawPitchRollToMatrix</strong> (yaw, pitch, roll) : list</p>
<p>Obtiene la matriz de rotación 4x4 a partir de la orientación definida por los ángulos en radianes &lt;yaw&gt;, &lt;pitch&gt; y &lt;roll&gt;. El resultado es una lista que representa una matriz de 16 elementos (4x4): [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33].</p>
<p>function <strong>YawPitchRollToQRotation</strong> (yaw, pitch, roll) : list</p>
<p>Obtiene el cuaternión a partir de la orientación definida por los ángulos en radianes &lt;yaw&gt;, &lt;pitch&gt;, &lt;roll&gt;. El valor devuelto por la función es una lista [qx, qy, qz, qw] donde los elementos son las diferentes componentes del cuaternión.</p>
<h2 id="buffer">Buffer</h2>
<p>Funciones que permiten la creación, destrucción y manipulación de Buffers de datos. Un Buffer es una zona de memoria con un tamaño de bytes y que podrá contener cualquier tipo de información.</p>
<p>function <strong>Buffer_New</strong> (len = 0) : pointer</p>
<p>Crea un objeto tipo buffer de tamaño especificado en &lt;len&gt;. Si no se especifica, lo crea de tamaño 0 bytes. El parámetro &lt;len&gt; también puede ser una lista, en cuyo caso se inicializará el buffer con el tamaño de todos los elementos de dicha lista y también copiará los valores de estos elementos dentro del buffer. La lista ha de contener elementos iguales o combinados de tipo BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, FLOAT, DOUBLE, BOOL y/o STRING. El parámetro &lt;len&gt; también puede ser de tipo cadena de caracteres, en cuyo caso se creará el buffer con el tamaño de la cadena y también lo inicializará con el contenido de la misma.</p>
<p>function <strong>Buffer_ReSize</strong> (buffer, len)</p>
<p>Dado un objeto &lt;buffer&gt; lo redimensiona al nuevo tamaño &lt;len&gt; sin perder el contenido de sus datos, siempre que &lt;len&gt; sea mayor que el tamaño en curso. En el caso de que &lt;len&gt; sea más pequeño que el tamaño actual del &lt;buffer&gt;, se perderán datos.</p>
<p>function <strong>Buffer_Delete</strong> (buffer)</p>
<p>Elimina de memoria un objeto buffer. Este puede haber sido creado con <em>Buffer_New</em> u otras funciones que creen objetos del mismo tipo.</p>
<p>function <strong>Buffer_Len</strong> (buffer) : int</p>
<p>Obtiene el tamaño en bytes de un objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_Compare</strong> (buff1, off1, buff2, off2, len) : int</p>
<p>Permite comparar el contenido de dos buffers. Se especifican los dos buffers en &lt;buff1&gt; y &lt;buff2&gt; indicando también desde qué posición inicial para cada uno &lt;off1&gt; y &lt;off2&gt;. Usando el argumento &lt;len&gt; se indicará la cantidad de bytes a comparar. El resultado será:</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>0</th>
<th>Si ambos contenidos son iguales.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt; 0</td>
<td>El primer byte que no coincide tiene un valor menor en &lt;buff1&gt; que en &lt;buff2&gt;. Valores comparados como unsigned bytes.</td>
</tr>
<tr class="even">
<td>&gt; 0</td>
<td>El primer byte que no coindice tiene un valor mayor en &lt;buff1&gt; que en &lt;buff2&gt;. Valores comparados como unsigned bytes.</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>function <strong>Buffer_Compress</strong> (buffer, method) : pointer</p>
<p>Devuelve un objeto buffer que contiene el contenido comprimido de &lt;buffer&gt;, según lo especificado en &lt;method&gt;. Estos valores pueden ser:</p>
<table>
<thead>
<tr class="header">
<th>COMPRESS_METHOD_ZIP</th>
<th>Usar compresión ZIP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMPRESS_METHOD_PLETTER</td>
<td>Usar compresión tipo Pletter</td>
</tr>
<tr class="even">
<td>COMPRESS_METHOD_BITBUSTER</td>
<td>Usar compresión tipo BitBuster</td>
</tr>
</tbody>
</table>
<p>Si usamos COMPRESS_METHOD_ZIP, podemos usar también los modificadores:</p>
<table>
<thead>
<tr class="header">
<th>COMPRESS_NONE</th>
<th>Sin compresión</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>COMPRESS_BESTSPEED</td>
<td>Compresión que beneficie a la velocidad</td>
</tr>
<tr class="even">
<td>COMPRESS_BESTSIZE</td>
<td>Compresión que beneficie al espacio</td>
</tr>
<tr class="odd">
<td>COMPRESS_DEFAULT</td>
<td>Compresión por defecto</td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>function <strong>Buffer_Copy</strong> (buff1, off1, buff2, off2, len)</p>
<p>Copia el contenido de &lt;buff2&gt; en &lt;buff1&gt;. Comenzará a copiar desde la posición &lt;off2&gt; de &lt;buff2&gt; y lo hará a partir de la posición &lt;off1&gt; de &lt;buff1&gt;. El número de bytes a copiar se indicará en el argumento &lt;len&gt;.</p>
<p>function <strong>Buffer_Fill</strong> (buffer, off, value, len)</p>
<p>Rellena un buffer con el valor especificado en &lt;value&gt;. Comenzará la escritura a partir de la posición &lt;off&gt; dentro de &lt;buffer&gt;. La escritura se hará durante la cantidad de bytes indicada en &lt;len&gt;.</p>
<p>function <strong>Buffer_Find</strong> (buffer, off, value) : int</p>
<p>Nos permite localizar la posición dentro de un &lt;buffer&gt; con desplazamiento &lt;off&gt; del valor indicado en &lt;value&gt;. Los tipos de &lt;value&gt; que se pueden buscar son: BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, FLOAT, DOUBLE y STRING. Según el tipo, se buscará teniendo en cuenta la cantidad de bytes requeridos y el formato del mismo.</p>
<p>function <strong>Buffer_FromBase64String</strong> (buffer, str)</p>
<p>Se rellena el objeto &lt;buffer&gt; con la cadena &lt;str&gt; codificada en BASE64.</p>
<p>function <strong>Buffer_FromHEXString</strong> (buffer, str)</p>
<p>Se rellena el objeto &lt;buffer&gt; con la cadena &lt;str&gt; codificada en hexadecimal.</p>
<p>function <strong>Buffer_FromURLString</strong> (buffer, str)</p>
<p>Se rellena el objeto &lt;buffer&gt; con la cadena &lt;str&gt; codificada en URL.</p>
<p>function <strong>Buffer_GetByte</strong> (buffer, off) : byte</p>
<p>Obtiene el byte (1 byte entero con signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetDouble</strong> (buffer, off) : double</p>
<p>Obtiene el double (8 bytes flotante doble) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetFloat</strong> (buffer, off) : float</p>
<p>Obtiene el float (4 bytes flotante) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetInt</strong> (buffer, off) : int</p>
<p>Obtiene el int (4 bytes entero con signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetLong</strong> (buffer, off) : long</p>
<p>Obtiene el long (8 bytes entero con signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetShort</strong> (buffer, off) : short</p>
<p>Obtiene el short (2 bytes entero con signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetString</strong> (buffer, off = 0, len = -1) : string</p>
<p>Obtiene la cadena de caracteres ASCII a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;. Devolverá la cadena con &lt;len&gt; número de caracteres. Si no se especifica &lt;len&gt; o tiene un valor negativo, se procederá a obtener la cadena hasta encontrar un carácter con valor 0 en el &lt;buffer&gt;. En caso de que no se encuentre y se alcance el final del tamaño del &lt;buffer&gt; se finalizará la operación.</p>
<p>function <strong>Buffer_GetUByte</strong> (buffer, off) : ubyte</p>
<p>Obtiene el unsigned byte (1 byte entero sin signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetUCString</strong> (buffer, off = 0) : string</p>
<p>Obtiene la cadena de caracteres UNICODE a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetUInt</strong> (buffer, off) : int</p>
<p>Obtiene el unsigned int (4 bytes entero sin signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetULong</strong> (buffer, off) : long</p>
<p>Obtiene el unsigned long (8 bytes entero sin signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetURLString</strong> (buffer, off = 0) : string</p>
<p>Obtiene la cadena de caracteres con codificación URL a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetUShort</strong> (buffer, off) : short</p>
<p>Obtiene el unsigned short (2 bytes entero sin signo) a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_GetUTF8String</strong> (buffer, off = 0, len = -1) : string</p>
<p>Obtener la cadena de caracteres con codificación UTF8 a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt;.</p>
<p>function <strong>Buffer_SetByte</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un byte (1 byte entero con signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a byte, se convertirá.</p>
<p>function <strong>Buffer_SetDouble</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un double (8 bytes flotante doble) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a double, se convertirá.</p>
<p>function <strong>Buffer_SetFloat</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un float (4 bytes flotante) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a float, se convertirá.</p>
<p>function <strong>Buffer_SetInt</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un int (4 bytes entero con signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a int, se convertirá.</p>
<p>function <strong>Buffer_SetLong</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un long (8 bytes entero con signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a long, se convertirá.</p>
<p>function <strong>Buffer_SetShort</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un short (2 bytes entero con signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a short, se convertirá.</p>
<p>function <strong>Buffer_SetString</strong> (buffer, off, str, asciiZ = true)</p>
<p>Escribe una cadena de caracteres &lt;str&gt; a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt; indicado. Según &lt;asciiz&gt; sea true o false, se copiará el carácter NULL (cero) final o no.</p>
<p>function <strong>Buffer_SetUByte</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un byte (1 byte entero sin signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a byte, se convertirá.</p>
<p>function <strong>Buffer_SetUInt</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un unsigned int (4 bytes entero sin signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a unsigned int, se convertirá.</p>
<p>function <strong>Buffer_SetULong</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un unsigned long (8 bytes entero sin signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a unsigned long, se convertirá.</p>
<p>function <strong>Buffer_SetUShort</strong> (buffer, off, value)</p>
<p>Siendo &lt;value&gt; un unsigned short (2 bytes entero sin signo) lo escribirá en la posición &lt;off&gt; del &lt;buffer&gt;. Si el tipo de &lt;value&gt; es distinto a unsigned short, se convertirá.</p>
<p>function <strong>Buffer_ToBase64String</strong> (buffer, off = 0) : string</p>
<p>Devuelve la cadena de caracteres en BASE64 obtenida a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt; indicado como argumento.</p>
<p>function <strong>Buffer_ToHEXString</strong> (buffer, off = 0) : string</p>
<p>Devuelve la cadena de caracteres en hexadecimal obtenida a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt; indicado como argumento.</p>
<p>function <strong>Buffer_ToURLString</strong> (buffer, off = 0) : string</p>
<p>Devuelve la cadena de caracteres con codificación URL obtenida a partir de la posición &lt;off&gt; del objeto &lt;buffer&gt; indicado como argumento.</p>
<p>function <strong>Buffer_UnCompress</strong> (buffer, len, method) : pointer</p>
<p>Dado un objeto &lt;buffer&gt; comprimido según el método espeficiado en &lt;method&gt;, obtendremos otro objeto buffer descomprimido con tamaño &lt;len&gt;. Por tanto, en &lt;len&gt; hemos de especificar el tamaño del buffer original (sin comprimir), como mínimo. Para ver los métodos disponibles, véase la función <em>Buffer_Compress</em>.</p>
<h2 id="string-1">String</h2>
<p>Conjunto de funciones que permiten manipular cadenas de caracteres.</p>
<p>function <strong>String_Compare</strong> (str1, str2) : int</p>
<p>Compara carácter a carácter el contenido de dos cadenas. Tiene en cuenta las mayúsculas y minúsculas. Devolverá 1 si &lt;str1&gt; es mayor que &lt;str2&gt;. Devolverá -1 si &lt;str1&gt; es menor que &lt;str2&gt;. Devolverá 0 si &lt;str1&gt; es igual a &lt;str2&gt;.</p>
<p>function <strong>String_CompareIgnoreCase</strong> (str1, str2) : int</p>
<p>Compara carácter a carácter el contenido de dos cadenas. No tiene en cuenta las mayúsculas y minúsculas, considera que son lo mismo. Devolverá 1 si &lt;str1&gt; es mayor que &lt;str2&gt;. Devolverá -1 si &lt;str1&gt; es menor que &lt;str2&gt;. Devolverá 0 si &lt;str1&gt; es igual a &lt;str2&gt;.</p>
<p>function <strong>String_Copy</strong> (str, len) : string</p>
<p>Crea una copia de los primeros &lt;len&gt; caracteres de la cadena &lt;str&gt;. Si &lt;len&gt; vale -1, la copia contendrá toda la cadena &lt;str&gt;.</p>
<p>function <strong>String_Count</strong> (str, pattern) : int</p>
<p>Cuenta el número de veces que &lt;pattern&gt; aparece en la cadena &lt;str&gt;. El argumento &lt;pattern&gt; puede ser un carácter o una cadena.</p>
<p>function <strong>String_Fill</strong> (str, num) : string</p>
<p>Crea una cadena que contiene a otra &lt;str&gt; repetida &lt;num&gt; veces.</p>
<p>function <strong>String_FindStr</strong> (str, pattern, cs = false, off = 0, whole = false) : int</p>
<p>Busca una cadena &lt;pattern&gt; dentro de otra &lt;str&gt;. Considera si la búsqueda ha de ser sensible a mayúsculas o minúsculas. También se puede indicar el índice &lt;off&gt; del carácter por el cual comenzar a buscar, además de si se quiere buscar la palabra de forma completa &lt;whole&gt; o no. Buscar una palabra de forma completa quiere decir que esta se encuentra aislada, separada entre espacios, tabuladores o cualquier otra cosa que no sean letras.</p>
<p>function <strong>String_FromHEX</strong> (str) : string</p>
<p>Dada una cadena de caracteres codificada en hexadecimal (pares de caracteres que representan un byte), devolverá a su salida una cadena con la longitud de &lt;str&gt; DIV 2, donde cada carácter corresponderá con los valores hexadecimales convertidos al byte correspondiente de la tabla ASCII.</p>
<p>Ejemplo:</p>
<pre><code>_ret = String_FromHEX(&quot;304123&quot;);</code></pre>
<p>Devolverá en &lt;_ret&gt; el valor “0A#”.</p>
<p>function <strong>String_FromBase64</strong> (str) : string</p>
<p>Dada una cadena de caracteres codificada en base 64, devolverá a su salida su decodificación en una cadena ASCIIZ.</p>
<p>function <strong>String_FromHTML</strong> (str) : string</p>
<p>Dada una cadena codificada en formato HTML, devuelve otra en formato ASCII o UNICODE donde se han reemplazado los símbolos y formatos propios del HTML.</p>
<p>function <strong>String_FromUNICODE</strong> (str) : string</p>
<p>A partir de una cadena de caracteres en formato UNICODE (16 bits por carácter), devuelve otra en formato ASCII. En el caso de que haya caracteres fuera del rango ASCII, estos perderán su precisión y pasarán de 16 bits a 8 bits.</p>
<p>function <strong>String_FromURL</strong> (str) : string</p>
<p>Dada una cadena de caracteres codificada en formato URL, devolverá otra en formato ASCII o UNICODE, dependiendo de si contiene o no caracteres fuera del rango de los 8 bits.</p>
<p>function <strong>String_FromUTF8</strong> (str) : string</p>
<p>A partir de una cadena en formato UTF8, devolverá otra en formato ASCII o UNICODE, según haya o no caracteres fuera del rango de los 8 bits.</p>
<p>function <strong>String_Format</strong> (…) : string</p>
<p>Crea una cadena con formato a partir de binomios pasados como argumentos a la función. Estos binomios están compuestos por una cadena &lt;fmt&gt; y un valor &lt;x&gt;. Según el formato establecido en &lt;fmt&gt; se generará la cadena de salida.</p>
<p>El formato de &lt;fmt&gt; estará compuesto por texto y la especificación del tipo de dato que queremos representar. El formato es el mismo que en las funciones <em>printf</em>, <em>sprintf</em> de C/C++:</p>
<p>%<a href="#width">flags</a>[.precision][length]specifier</p>
<p>Ejemplo:</p>
<pre><code>_ret = String_Format(&quot;%03d&quot;, 5);</code></pre>
<p>Esto devolverá en &lt;_ret&gt; el valor “005”.</p>
<p>Podemos agregar texto y otros binomios si queremos:</p>
<pre><code>_ret = String_Format(&quot;Prueba %s&quot;, &quot;hola&quot;, &quot;de print %02d valor&quot;, 10);</code></pre>
<p>A su salida &lt;_ret&gt; valdrá “Prueba hola de print 10 valor”.</p>
<p>function <strong>String_FuzzyMatch</strong> (pat, patlen, str, strlen) : list</p>
<p>Indica si la cadena patrón &lt;pat&gt; se encuentra en la cadena indicada en &lt;str&gt;. La función devuelve el número de concidencias y determina una puntuación. También ofrece los índices donde se encuentran las distintas coincidencias.</p>
<p>El retorno es una lista con tres elementos: [bool, int, list].</p>
<p>El primero indica si hay coincidencias, el segundo es una puntuación y el tercero es una lista con índices a las coincidencias encontradas en &lt;str&gt;.</p>
<p>function <strong>String_GetToken</strong> (str, pos, sep) : list</p>
<p>A partir de la posición &lt;pos&gt; dentro de la cadena de caracteres &lt;str&gt;, se obtendrá la subcadena hasta encontrar algún carácter de los existentes en la cadena determinada por &lt;sep&gt;. También se devolverá la nueva posición donde se ha detenido la búsqueda.</p>
<p>Por ejemplo:</p>
<pre><code>_ret = String_GetToken(&quot;Esto es una casa&quot;, 0, &quot;u&quot;);</code></pre>
<p>En &lt;_ret&gt; encontraremos [“Esto es”, 9].</p>
<p>function <strong>String_IsUnicode</strong> (str) : bool</p>
<p>Indica si la cadena de caracteres tiene el formato UNICODE, donde cada carácter usa 16 bits de información.</p>
<p>function <strong>String_Left</strong> (str, len) : string</p>
<p>Obtiene la cadena de caracteres desde el inicio de &lt;str&gt; hasta &lt;len&gt;, o sea, obtiene los primeros &lt;len&gt; caracteres de &lt;str&gt;.</p>
<p>function <strong>String_Load</strong> (path, line = 0) : string</p>
<p>Dada la ruta a un archivo &lt;path&gt;, se obtendrá la línea de texto correspondiente &lt;line&gt;. Si no se especifica, se devolverá la primera. En caso de que &lt;line&gt; esté fuera del rango del archivo, se devolverá cadena vacía como resultado. También se devolverá cadena vacía si el archivo no existe.</p>
<p>function <strong>String_LowerCase</strong> (str) : string</p>
<p>Obtiene como resultado una cadena de caracteres igual a &lt;str&gt; pero donde las mayúsculas se han convertido a minúsculas.</p>
<p>function <strong>String_LTrim</strong> (str) : string</p>
<p>Devuelve &lt;str&gt; pero eliminando los espacios existentes por la izquierda, o sea, desde la posición inicial de &lt;str&gt;.</p>
<p>function <strong>String_New</strong> (len, unicode = false) : string</p>
<p>Permite crear un objeto de tipo cadena de caracteres con una reserva de memoria preestablecida. Se puede indicar si queremos que use 8 o 16 bits para cada carácter. El tamaño establecido no indica el número de caracteres de la cadena, sino el espacio inicial que queremos reservar para guardar caracteres. En ciertos procesos de tratamiento de textos grandes o abundantes, es interesante reservar un tamaño de caracteres para conseguir mayores velocidades de proceso (menor coste de CPU). Para eliminar el objeto creado, y por tanto liberar memoria, se debe usar <em>String_Delete</em>.</p>
<p>function <strong>String_Replace</strong> (str, fstr, rstr, off = 0, whole = false) : string</p>
<p>Localiza dentro de la cadena &lt;str&gt; todas las ocurrencias de &lt;fstr&gt; y las sustituye por la cadena &lt;rstr&gt;. Esto comienza a hacerlo a partir de la posición &lt;off&gt; dentro de &lt;str&gt;. La búsqueda la puede hacer simplemente localizando cualquier texto igual a &lt;fstr&gt; o bien solo cuando el texto se encuentra aislado (separado por caracteres no alfanuméricos o numéricos): para ello, indicaremos &lt;whole&gt; como verdadero.</p>
<p>Ejemplo:</p>
<pre><code>_ret = String_Replace(&quot;La vida es así&quot;, &quot;es&quot;, &quot;no es&quot;, 0, false);</code></pre>
<p>En &lt;_ret&gt; encontraremos una cadena con el valor “La vida no es así”.</p>
<p>function <strong>String_Right</strong> (str, len) : string</p>
<p>Obtiene la cadena de los últimos &lt;len&gt; caracteres existentes en &lt;str&gt;, o sea, los &lt;len&gt; caracteres de la parte derecha de &lt;str&gt;.</p>
<p>function <strong>String_RTrim</strong> (str) : string</p>
<p>Devuelve &lt;str&gt; pero eliminando los espacios existentes por la derecha, o sea, desde el final de &lt;str&gt;.</p>
<p>function <strong>String_SubStr</strong> (str, off, len) : string</p>
<p>Devuelve la subcadena existente dentro de &lt;str&gt; desde la posición inicial &lt;off&gt; con un tamaño de &lt;len&gt; caracteres.</p>
<p>function <strong>String_ToArray</strong> (str, delim = “|,”, esc = "") : Array</p>
<p>Dada una cadena de caracteres, devuelve un objeto Array donde cada uno de los elementos es una subcadena. Estos elementos se obtienen al extraerse de &lt;str&gt; en función de los delimitadores establecidos &lt;delim&gt;. Podemos evitar aquellos delimitadores que se encuentren entre los caracteres que pasemos dentro de la cadena &lt;esc&gt;. Para usar los objetos Array se deben usar las funciones que comienzan por este prefijo, y para eliminar el objeto de memoria se debe usar <em>Array_Delete</em>.</p>
<p>function <strong>String_ToBase64</strong> (str) : string</p>
<p>Convierte una cadena en formato BASE64.</p>
<p>function <strong>String_ToBuffer</strong> (str, asciiz = true) : buffer</p>
<p>Convierte una cadena en un objeto Buffer incializado con los caracteres de &lt;str&gt; y teniendo en cuenta si el dato final es cero o no en función de si queremos una conversión ASCII o ASCIIZ. Los objetos Buffer se eliminan con <em>Buffer_Delete</em>.</p>
<p>function <strong>String_ToHEX</strong> (str) : string</p>
<p>Transforma una cadena &lt;str&gt; en otra con formato hexadecimal, o sea, cada byte de la cadena se convierte en dos bytes que representan su conversión hexadecimal.</p>
<p>function <strong>String_ToHTML</strong> (str) : string</p>
<p>Codifica la cadena &lt;str&gt; en formato HTML.</p>
<p>function <strong>String_ToList</strong> (str, delim = “|,”, esc = "") : list</p>
<p>Esta función es igual a <em>String_ToArray</em>, salvo que el resultado se devuelve en formato lista de cadenas.</p>
<p>function <strong>String_ToUNICODE</strong> (str) : string</p>
<p>Conviernte una cadena en formato UNICODE (16 bits por carácter). Si la cadena ya está en formato 16 bits no se aplica ninguna conversión.</p>
<p>function <strong>String_ToURL</strong> (str) : string</p>
<p>Codifica &lt;str&gt; en formato URL.</p>
<p>function <strong>String_ToUTF8</strong> (str) : string</p>
<p>Convierte &lt;str&gt; en formato UTF8.</p>
<p>function <strong>String_Trim</strong> (str) : string</p>
<p>Devuelve una cadena igual a &lt;str&gt; pero eliminando los espacios en blanco existentes.</p>
<p>function <strong>String_UpperCase</strong> (str) : string</p>
<p>Retorna una cadena igual a &lt;str&gt; donde se han sustituido los caracteres en minúsculas por sus correspondientes en mayúsculas.</p>
<p>function <strong>strlen</strong> (str) : int</p>
<p>Devuelve el número de caracteres de &lt;str&gt;.</p>
<p>function <strong>ascii</strong> (ch) : string</p>
<p>Si &lt;ch&gt; es un número, devolverá la cadena que representa el carácter ASCII correspondiente. Si &lt;ch&gt; es una cadena en formato UNICODE, devolverá la versión ASCII.</p>
<p>function <strong>unicode</strong> (ch) : string</p>
<p>Si &lt;ch&gt; es un número, devolverá la cadena que representa el carácter UNICODE correspondiente. Si &lt;ch&gt; es una cadena en formato ASCII, devolverá la versión UNICODE.</p>
<p>function <strong>bin</strong> (num) : string</p>
<p>Dado un número &lt;num&gt; devolveremos la cadena que representa su valor en binario. Los números siempre se interpretarán como enteros.</p>
<p>function <strong>bin2int</strong> (str) : int</p>
<p>Dada una cadena &lt;str&gt; que representa un número en binario, se devolverá el valor entero correspondiente.</p>
<p>function <strong>hex</strong> (num) : string</p>
<p>Dado un número &lt;num&gt; devolveremos la cadena que representa su valor en hexadecimal. Los números siempre se interpretarán como enteros.</p>
<p>function <strong>hex2int</strong> (str) : int</p>
<p>Dada una cadena &lt;str&gt; que representa un número en hexadecimal, se devolverá el número entero correspondiente.</p>
<p>function <strong>isalpha</strong> (ch) : bool</p>
<p>Dado un entero &lt;ch&gt; que representa un carácter, indica si dicho carácter es alfanumérico. En caso de que &lt;ch&gt; sea un string, se mirará carácter a carácter dicho string. Si &lt;ch&gt; es un Buffer, se mirará byte a byte. Si &lt;ch&gt; es una Lista, también se mirará elemento a elemento. Todos ellos tendrán que ser alfanuméricos para que se retorne verdadero.</p>
<p>function <strong>isdigit</strong> (ch) : bool</p>
<p>Dado un entero &lt;ch&gt; que representa un carácter, indica si dicho carácter es numérico. En caso de que &lt;ch&gt; sea un string, se mirará carácter a carácter dicho string. Si &lt;ch&gt; es un Buffer, se mirará byte a byte. Si &lt;ch&gt; es una Lista, también se mirará elemento a elemento. Todos ellos tendrán que ser numéricos para que se retorne verdadero.</p>
<p>function <strong>oct</strong> (num) : string</p>
<p>Dado un número &lt;num&gt; devolveremos la cadena que representa el valor en octal. Los números siempre se interpretarán como enteros.</p>
<p>function <strong>oct2int</strong> (str) : int</p>
<p>Dada una cadena &lt;str&gt; que representa un número en octal, se devolverá el valor entero correspondiente.</p>
<h2 id="color-2">Color</h2>
<p>Conjunto de funciones para manipulación de códigos de color en diferentes formatos.</p>
<p>function <strong>ARGB</strong> (a, r, g, b) : int</p>
<p>Devuelve un color en formato entero de 32 bits que representa un ARGB, donde &lt;a&gt; es el alpha (transparencia u opacidad), &lt;r&gt; el rojo, &lt;g&gt; el verde y &lt;b&gt; el azul. Los valores que se le pasan para los distintos componentes de color van en el rango del 0 al 255. En el caso del Alpha &lt;a&gt;, un cero representa total transparencia y un 255 representa opacidad total.</p>
<p>function <strong>Color_Bright</strong> (color, level) : int</p>
<p>Dado un color en formato entero &lt;color&gt;, se obtiene el mismo color pero aumentando su brillo en el nivel indicado por &lt;level&gt;. Este nivel será un valor que irá de 0 a 255. A valor más alto, más brillante.</p>
<p>function <strong>Color_Dark</strong> (color, level) : int</p>
<p>Dado un color en formato entero &lt;color&gt;, se obtiene el mismo color pero haciéndolo más oscuro según el nivel indicado por &lt;level&gt;. Este nivel será un valor que irá de 0 a 255. A valor más alto, más oscuro.</p>
<p>function <strong>Color_Distance</strong> (color1, color2) : int</p>
<p>Obtiene la distancia entre dos colores. Esto es, el número que indica lo parecidos o distintos que son dos colores &lt;color1&gt; y &lt;color2&gt; según sus componentes RGB.</p>
<p>function <strong>Color_DistanceAlpha</strong> (color1, color2) : int</p>
<p>Obtiene la distancia entre dos colores. Esto es, el número que indica lo parecidos o distintos que son dos colores &lt;color1&gt; y &lt;color2&gt; según sus componentes ARGB. En este caso, esta función es igual a <em>Color_Distance,</em> pero teniendo en cuenta el Alpha también.</p>
<p>function <strong>Color_FindPaletteIndex</strong> (color, palette) : int</p>
<p>Dado un color y una paleta de colores en formato lista, se buscará el color más parecido a &lt;color&gt; dentro de la paleta. En ese caso, devolverá el índice al color correspondiente en dicha paleta &lt;palette&gt;. La paleta será una lista de colores en formato numérico. En caso de ser una paleta vacía, el índice devuelto será -1,</p>
<p>function <strong>Color_GetA</strong> (color) : int</p>
<p>Dado un color en formato numérico, devuelve su componente Alpha en el rango 0 a 255.</p>
<p>function <strong>Color_GetB</strong> (color) : int</p>
<p>Dado un color en formato numérico, devuelve su componente Azul en el rango 0 a 255.</p>
<p>function <strong>Color_GetG</strong> (color) : int</p>
<p>Dado un color en formato numérico, devuelve su componente Verde en el rango 0 a 255.</p>
<p>function <strong>Color_GetR</strong> (color) : int</p>
<p>Dado un color en formato numérico, devuelve su componente Roja en el rango 0 a 255.</p>
<p>function <strong>Color_SetA</strong> (color, a) : int</p>
<p>Dado un color, nos permite obtener el mismo con su componente Alpha actualizada con el valor indicado en el argumento &lt;a&gt;. Este valor estará en el rango de 0 a 255.</p>
<p>function <strong>Color_SetB</strong> (color, b) : int</p>
<p>Dado un color, nos permite obtener el mismo con su componente Azul actualizada con el valor indicado en el argumento &lt;a&gt;. Este valor estará en el rango de 0 a 255.</p>
<p>function <strong>Color_SetG</strong> (color, g) : int</p>
<p>Dado un color, nos permite obtener el mismo con su componente Verde actualizada con el valor indicado en el argumento &lt;a&gt;. Este valor estará en el rango de 0 a 255.</p>
<p>function <strong>Color_SetR</strong> (color, r) : int</p>
<p>Dado un color, nos permite obtener el mismo con su componente Roja actualizada con el valor indicado en el argumento &lt;a&gt;. Este valor estará en el rango de 0 a 255.</p>
<p>function <strong>Color_Slerp</strong> (color1, color2, delta) : int</p>
<p>Dado un factor &lt;delta&gt; en el rango de 0 a 1, devolverá el color correspondiente a interpolar entre &lt;color1&gt; y &lt;color2&gt; en función de &lt;delta&gt;. Si &lt;delta&gt; es 0, el valor retornado será &lt;color1&gt;, y si es 1, el valor que devolverá será &lt;color2&gt;.</p>
<p>function <strong>RGB</strong> (r, g, b) : int</p>
<p>Devuelve el color en formato entero de 32 bits, representando un ARGB. En este caso, el componente Alpha, por omisión, valdrá 255, o sea, totalmente opaco.</p>
<p>function <strong>RGBToHSL</strong> (r, g, b) : list</p>
<p>Retorna las componentes H (Hue), S (Saturation), L (Lightness) correspondientes a los valores RGB indicados como argumento. Los componentes RGB se indicarán en el rango de 0 a 255. Los valores HSL devueltos están en valores dentro del rango 0 a 1.</p>
<p>function <strong>HSLToRGB</strong> (h, s, l) : int</p>
<p>Devolverá el color ARGB en formato entero 32 bits obtenido a partir de los componentes HSL indicados. Estos componentes estarán en el rango 0 a 1.</p>
<h2 id="container">Container</h2>
<p>Funciones relacionadas con la creación y manipulación de contenedores abstractos de datos.</p>
<p>function <strong>Container_New</strong> (path = "") : pointer</p>
<p>Permite crear una instancia de objeto contenedor a partir de un archivo script o bien sin ninguna propiedad.</p>
<p>function <strong>Container_Delete</strong> (cont)</p>
<p>Elimina de memoria el contenedor &lt;cont&gt;.</p>
<p>function <strong>Container_AddProperty</strong> (cont, name, v = 0) : bool</p>
<p>Permite crear una nueva propiedad en el objeto contenedor &lt;cont&gt;. El nombre de la propiedad se indica con la cadena &lt;name&gt; y se puede establecer un valor inicial a través del argumento &lt;v&gt;. La función retornará verdadero si se ha podido agregar la propiedad o falso en caso contrario.</p>
<p>function <strong>Container_Clone</strong> (cont) : pointer</p>
<p>Clona el objeto contenedor &lt;cont&gt;. Este nuevo contenedor será idéntico al original y ocupará su zona de memoria independiente; por tanto, para eliminarlo, también tendremos que llamara a <em>Container_Delete</em>. Los cambios en &lt;cont&gt; no afectarán a su copia, ni viceversa.</p>
<p>function <strong>Container_Copy</strong> (dst, src)</p>
<p>Realiza una copia exacta del contenedor &lt;src&gt; al contenedor &lt;dst&gt;. Las propiedades existentes en &lt;dst&gt; que no existan en &lt;src&gt; se eliminarán.</p>
<p>function <strong>Container_DelProperty</strong> (cont, name) : bool</p>
<p>Permite borrar una propiedad con nombre &lt;name&gt; del objeto contenedor &lt;cont&gt;. En caso de que la propiedad exista y se haya eliminado correctamente, la función retornará verdadero, y en caso contrario, falso.</p>
<p>function <strong>Container_FromBuffer</strong> (cont, buffer)</p>
<p>Dada una serialización del objeto contenedor dentro de un objeto &lt;buffer&gt;, podemos inicializar el contenedor &lt;cont&gt; con los datos almacenados en el buffer. Esta función se usa en combinación con <em>Container_ToBuffer</em>.</p>
<p>function <strong>Container_FromString</strong> (str) : pointer</p>
<p>Dada una serialización del objeto contenedor dentro de una cadena &lt;str&gt;, podemos inicializar el contenedor &lt;cont&gt; con los datos almacenados en esta cadena. Esta función se usa en combinación con <em>Container_ToString</em>.</p>
<p>function <strong>Container_FromXMLString</strong> (xmlStr) : pointer</p>
<p>Dada una serialización del objeto contenedor dentro de una cadena XML &lt;xmlStr&gt;, podemos inicializar el contenedor &lt;cont&gt; con los datos almacenados en esta cadena. Esta función se usa en combinación con <em>Container_ToString</em>.</p>
<p>function <strong>Container_GetNumProperties</strong> (cont) : uint</p>
<p>Obtiene el número de propiedades existentes en un objeto contenedor.</p>
<p>function <strong>Container_GetProperty</strong> (cont, name) : value</p>
<p>Devuelve el valor de una propiedad con nombre &lt;name&gt; dentro del objeto contenedor &lt;cont&gt;.</p>
<p>function <strong>Container_GetPropertyByIndex</strong> (cont, ix) : value</p>
<p>Devuelve el valor de una propiedad con índice &lt;ix&gt; dentro del objeto contenedor &lt;cont&gt;. El índice irá desde 0 hasta <em>Container_GetNumProperties</em> - 1.</p>
<p>function <strong>Container_GetPropertyNameByIndex</strong> (cont, ix) : string</p>
<p>Obtiene el nombre de la propiedad con índice &lt;ix&gt; del objeto contenedor &lt;cont&gt;.</p>
<p>function <strong>Container_HasProperty</strong> (cont, name) : bool</p>
<p>Retornará verdadero si el objeto contenedor &lt;cont&gt; tiene una propiedad con nombre &lt;name&gt;. En caso contrario, devolverá falso.</p>
<p>function <strong>Container_Load</strong> (path) : pointer</p>
<p>Permite cargar un script contenedor y devolver su instancia en memoria. Para posteriormente liberar esta memoria, se debe usar <em>Container_Delete</em>.</p>
<p>function <strong>Container_Merge</strong> (dst, src)</p>
<p>Copia y añade propiedades al objeto contenedor &lt;dst&gt; desde otro objeto contenedor &lt;src&gt;. Las propiedades con mismo nombre verán actualizado su valor y, aquellas propiedades de &lt;src&gt; no existentes en &lt;dst&gt; se crearán.</p>
<p>function <strong>Container_Save</strong> (cont, path) : bool</p>
<p>Almacena en disco el script contenedor que se obtiene del objeto &lt;cont&gt;. En caso de que no se haya podido guardar el contenido, se devolverá falso. Si todo ha ido correctamente, verdadero.</p>
<p>function <strong>Container_SizeOf</strong> (cont) : int</p>
<p>Dada un objeto contenedor &lt;cont&gt;, obtendremos el tamaño en bytes que necesitaríamos para almacenar la serialización de todo su contenido.</p>
<p>function <strong>Container_ToBuffer</strong> (cont, buffer) : uint</p>
<p>Permite serializar el objeto contenedor &lt;cont&gt; en un objeto &lt;buffer&gt;. La función retornará el tamaño en bytes que ocupará el &lt;buffer&gt; tras finalizar la serialización.</p>
<p>function <strong>Container_ToString</strong> (cont) : string</p>
<p>Serializa un objeto contenedor &lt;cont&gt; directamente a una cadena de caracteres. Esta cadena tendrá formato de script contenedor.</p>
<p>function <strong>Container_ToXMLString</strong> (cont) : string</p>
<p>Serializa un objeto contenedor &lt;cont&gt; directamente a una cadena de caracteres con formato XML.</p>
<h2 id="xml">XML</h2>
<p>Funciones para operar con archivos de formato XML (Lenguaje de marcado extensible).</p>
<p>Ejemplo de XML:</p>
<pre><code>&lt;menu id=&quot;file&quot; value=&quot;File&quot;&gt;
    &lt;popup&gt;
      &lt;menuitem value=&quot;New&quot; onclick=&quot;CreateNewDoc()&quot; /&gt;
      &lt;menuitem value=&quot;Open&quot; onclick=&quot;OpenDoc()&quot; /&gt;
      &lt;menuitem value=&quot;Close&quot; onclick=&quot;CloseDoc()&quot; /&gt;
      Popup text value
    &lt;/popup&gt;
&lt;/menu&gt;</code></pre>
<p>function <strong>XML_Open</strong> (path) : pointer</p>
<p>Obtiene un objeto XML a partir del archivo referenciado por &lt;path&gt;. En caso de que el archivo sea incorrecto o no exista, se devolverá NULL.</p>
<p>function <strong>XML_Close</strong> (xml)</p>
<p>Dado un objeto XML, se libera de memoria.</p>
<p>function <strong>XML_GetRootElement</strong> (xml) : pointer</p>
<p>Obtiene el elemento raíz de un XML. Los elementos o entidades son aquellas formadas por la sintaxis: &lt;element&gt; &lt;/element&gt;.</p>
<p>function <strong>XML_FirstElement</strong> (elem) : pointer</p>
<p>Obtiene el primer elemento dentro de otro elemento &lt;elem&gt;.</p>
<p>function <strong>XML_NextElement</strong> (elem) : pointer</p>
<p>Devuelve el elemento siguiente a un elemento &lt;elem&gt;.</p>
<p>function <strong>XML_GetElementValue</strong> (elem) : string</p>
<p>Obtiene el texto asociado a un elemento &lt;elem&gt;. Este texto es el encontraríamos entre los campos: &lt;elemento&gt; Texto &lt;/elemento&gt;.</p>
<p>function <strong>XML_GetElementName</strong> (elem) : string</p>
<p>Permite saber el nombre asociado a determinado elemento &lt;elem&gt;.</p>
<p>function <strong>XML_FirstAttribute</strong> (elem) : pointer</p>
<p>Obtiene el primer atributo dentro de un elemento &lt;elem&gt;. Los atributos son binomios clave-valor que se encuentran definidos en XML como:</p>
<pre><code>&lt;elemento atributo1=&quot;valor&quot; atributo2=&quot;valor&quot; … &gt;</code></pre>
<p>function <strong>XML_GetAttributeName</strong> (attr) : string</p>
<p>Dado un atributo &lt;attr&gt;, obtiene el nombre asociado.</p>
<p>function <strong>XML_GetAttributeValue</strong> (attr) : string</p>
<p>Dado un atributo &lt;attr&gt;, obtiene el valor asociado.</p>
<p>function <strong>XML_NextAttribute</strong> (attr) : pointer</p>
<p>A partir de un atributo &lt;attr&gt;, obtiene el siguiente atributo que podremos encontrar dentro del elemento.</p>
<p>function <strong>XML_GetKey</strong> (xml, elemName, attrName) : string</p>
<p>Dado un objeto XML, buscaremos de forma directa un elemento con nombre &lt;elemName&gt; y un atributo con nombre &lt;attrName&gt; para obtener el valor de dicho atributo.</p>
<h2 id="json">JSON</h2>
<p>Funciones para la manipulación de archivos con formato JSON. Este formato se creó con la intención de permitir el intercambio de datos mediante archivos de texto y de forma sencilla.</p>
<p>Ejemplo de JSON:</p>
<pre><code>{
  &quot;menu&quot;: 
  {
    &quot;id&quot;: &quot;file&quot;,
    &quot;value&quot;: &quot;File&quot;,
    &quot;popup&quot;: 
    {
      &quot;menuitem&quot;: 
      [
        {&quot;value&quot;:&quot;New&quot;,&quot;onclick&quot;:&quot;CreateNewDoc()&quot;},
        {&quot;value&quot;:&quot;Open&quot;,&quot;onclick&quot;:&quot;OpenDoc()&quot;},
        {&quot;value&quot;:&quot;Close&quot;,&quot;onclick&quot;:&quot;CloseDoc()&quot;}
      ]
    }
  }
}</code></pre>
<p>function <strong>JSON_Open</strong> (path) : pointer</p>
<p>Abre el archivo de texto con formato JSON en la ruta establecida en &lt;path&gt;. La función devolverá una instancia de objeto JSON.</p>
<p>function <strong>JSON_Close</strong> (json)</p>
<p>Libera los recursos utilizados por la instancia del objeto JSON.</p>
<p>function <strong>JSON_GetRootObject</strong> (json) : pointer</p>
<p>Dada una instancia &lt;json&gt;, permite obtener el objeto raíz desde el que extraer información de los datos almacenados.</p>
<p>function <strong>JSON_CountObjectItems</strong> (obj) : int</p>
<p>Devuelve el número de sub-objetos que contiene un objeto JSON.</p>
<p>function <strong>JSON_FindObjectItem</strong> (obj, name) : pointer</p>
<p>Dado un objeto JSON &lt;obj&gt; nos permite encontrar el sub-objeto contenido en él y que tiene por nombre &lt;name&gt;.</p>
<p>function <strong>JSON_GetObjectItem</strong> (obj, ix) : pointer</p>
<p>Dado un objeto JSON &lt;obj&gt; nos devuelve un sub-objeto referenciado por el índice &lt;ix&gt;. El valor del índice irá desde 0 hasta <em>JSON_CountObjectsItems()</em> - 1.</p>
<p>function <strong>JSON_GetObjectKey</strong> (obj, ix) : string</p>
<p>Permite obtener el nombre asociado al sub-objeto con índice &lt;ix&gt; contenido en el objeto JSON &lt;obj&gt;.</p>
<p>function <strong>JSON_InsertObjectItem</strong> (obj, name, value) : bool</p>
<p>Inserta un sub-objeto con nombre &lt;name&gt; y valor &lt;value&gt; en la lista de objetos determinada por el objeto JSON &lt;obj&gt;.</p>
<p>function <strong>JSON_IsObjectItem</strong> (obj, name) : bool</p>
<p>Averigua si existe un determinado sub-objeto con nombre &lt;name&gt; dentro de la lista del objeto JSON &lt;obj&gt;.</p>
<p>function <strong>JSON_NewObject</strong> (obj) : pointer</p>
<p>Crea un nuevo sub-objeto dentro del objeto JSON &lt;obj&gt;.</p>
<p>function <strong>JSON_ToString</strong> (json) : string</p>
<p>Obtiene la cadena de caracteres con formato JSON generada a partir de la instancia de objeto JSON pasada como argumento &lt;json&gt;.</p>
<h2 id="database">Database</h2>
<p>Funciones para la gestión de bases de datos. Actualmente la base de datos soportada es la SQLITE3.</p>
<p>function <strong>Database_Open</strong> (path) : pointer</p>
<p>Dada una cadena que contiene la ruta &lt;path&gt; a un archivo de base de datos, en caso de que se haya podido abrir correctamente, devolverá un objeto para controlar el acceso a dicha base de datos. En caso contrario, se devolverá NULL.</p>
<p>function <strong>Database_Close</strong> (db)</p>
<p>Libera los recursos utilizados por el controlador de base de datos &lt;db&gt;.</p>
<p>function <strong>Database_StartQuery</strong> (db, sql) : pointer</p>
<p>Devolverá un controlador de consulta asociado a la cadena &lt;sql&gt; con la sintaxis SQL que se desea realizar sobre el controlador de base de datos &lt;db&gt;. En caso de que la consulta haya sido exitosa, se devolverá el controlador de consulta. En caso contrario, se devolverá NULL y podremos consultar más información haciendo uso de la función <em>Database_GetLastError</em>.</p>
<p>function <strong>Database_NextQuery</strong> (query) : bool</p>
<p>Dado un controlador de consulta &lt;query&gt;, nos permite avanzar el cursor de la misma, o sea, obtener información sobre la siguiente fila que cumple los requisitos establecidos en <em>Database_StartQuery</em>.</p>
<p>function <strong>Database_EndQuery</strong> (query)</p>
<p>Finaliza y libera los recursos asociados al controlador de consulta &lt;query&gt;.</p>
<p>function <strong>Database_ResetQuery</strong> (query)</p>
<p>Reinicializa el cursor de la consulta &lt;query&gt; poniéndolo al comienzo de nuevo.</p>
<p>function <strong>Database_GetColName</strong> (query, col) : string</p>
<p>Dado un controlador de consulta &lt;query&gt; y un índice a una columna, obtenemos el nombre asociado a dicha columna.</p>
<p>El índice irá desde 0 hasta <em>Database_GetNumCols()</em> -1.</p>
<p>function <strong>Database_GetColValue</strong> (query, col) : value</p>
<p>Dado un controlador de consulta &lt;query&gt; y un índice a una columna, obtenemos el valor asociado a dicha columna para la fila apuntada por el cursor.</p>
<p>function <strong>Database_GetNumCols</strong> (query) : int</p>
<p>Devuelve el número de columnas accesibles en el controlador de consulta &lt;query&gt;.</p>
<p>function <strong>Database_GetRow</strong> (query) : list</p>
<p>Dado un controlador de consulta &lt;query&gt;, obtiene todas las columnas de la fila apuntada por el cursor en una lista. La lista tendrá <em>Database_GetNumCols</em> elementos.</p>
<p>function <strong>Database_Query</strong> (db, sql) : list</p>
<p>Mediante esta función, aplicamos la consulta SQL de forma completa sobre una base de datos &lt;db&gt;. Sería igual a hacer un Start, Next, End a través de todas las filas disponibles. El resultado se ofrecerá en forma de lista, donde cada elemento a su vez será una sublista con todas las columnas y para todas las filas.</p>
<p>function <strong>Database_GetLastError</strong> (query) : string</p>
<p>Da más información en el caso de que la llamada a una función de base de datos previa haya dado error.</p>
<h2 id="crypto">Crypto</h2>
<p>Funciones relacionadas con la criptografía.</p>
<p>function <strong>Crypto_CRC32</strong> (data) : uint</p>
<p>Obtiene el código CRC32 a partir de los datos establecidos en &lt;data&gt;, que puede ser una cadena de caracteres o un objeto Buffer.</p>
<p>function <strong>Crypto_HMAC_SHA1</strong> (key, data) : string</p>
<p>Dada una clave &lt;key&gt; en una cadena de caracteres y un &lt;data&gt; que puede también ser una cadena o bien un objeto Buffer, obtenemos la cadena que representa el código HMAC SHA1.</p>
<p>function <strong>Crypto_SHA1</strong> (data) : string</p>
<p>Siendo &lt;data&gt; una cadena de caracteres o un objeto buffer, obtenemos la cadena que representa el código SHA1 de todos esos datos.</p>
<p>function <strong>Crypto_SHA1_New</strong> () : pointer</p>
<p>Nos permite crear un objeto SHA1 con el que poder operar. Esta función está pensada para trabajar con archivos u objetos de gran tamaño que puedan requerir actualizaciones iterativas. Para eliminar el objeto y liberar memoria usaremos <em>SHA1_Delete</em>.</p>
<p>function <strong>Crypto_SHA1_Delete</strong> (sha1)</p>
<p>Eliminamos y liberamos memoria de un objeto creado previamente con <em>SHA1_New</em>.</p>
<p>function <strong>Crypto_SHA1_Get</strong> (sha1) : string</p>
<p>Obtiene la cadena con el código SHA1 obtenido de los datos procesados hasta el momento en el objeto.</p>
<p>function <strong>Crypto_SHA1_Update</strong> (sha1, data, len = -1)</p>
<p>Dado un objeto SHA1, actualiza su información mediante los datos &lt;data&gt; almacenados en un Buffer o cadena de caracteres. Podemos actualizar la cantidad de bytes que queramos: si no establecemos su valor se usará -1, que indica que vamos a actualizar todo el contenido. Posteriormente, podemos obtener la cadena con el código SHA1 usando la función <em>Crypto_SHA1_Get</em>.</p>
<h2 id="dictionary">Dictionary</h2>
<p>Conjunto de funciones para el manejo de objetos de tipo Diccionario. Un objeto Diccionario es una lista de elementos a los que se puede acceder por nombre, siendo el nombre una cadena de caracteres.</p>
<p>function <strong>Dictionary_New</strong> () : pointer</p>
<p>Crea una instancia de objeto tipo Dictionary.</p>
<p>function <strong>Dictionary_Delete</strong> (dict)</p>
<p>Elimina y libera los recursos usados por la instancia de objeto &lt;dict&gt;.</p>
<p>function <strong>Dictionary_Clear</strong> (dict)</p>
<p>Elimina todas las entradas existentes en el diccionario indicado por &lt;dict&gt;.</p>
<p>function <strong>Dictionary_DeleteItem</strong> (dict, key) : value</p>
<p>Dado un diccionario &lt;dict&gt; y una clave &lt;key&gt;, en caso de que exista algún elemento con dicha clave, se eliminará su referencia. El valor asociado a la clave será devuelto por la función. Si el valor es la instancia de algún objeto, este no será borrado o liberado sus recursos. Cabe señalar que si la clave &lt;key&gt; no existe en el diccionario, el valor devuelto será NULL.</p>
<p>function <strong>Dictionary_FindItemKey</strong> (dict, value) : string</p>
<p>Dado un diccionario &lt;dict&gt; y un valor &lt;value&gt;, se buscará la clave dentro del diccionario que hace referencia a dicho valor. En caso de encontrarse, se devolverá el nombre de dicha clave, y en caso contrario devolverá cadena vacía.</p>
<p>function <strong>Dictionary_Get</strong> (dict, key) : value</p>
<p>Permite obtener el valor asociado a una clave &lt;key&gt; existente dentro de un diccionario. En caso de que la clave no exista, devolverá NULL.</p>
<p>function <strong>Dictionary_GetItemCount</strong> (dict) : int</p>
<p>Dado un diccionario &lt;dict&gt;, nos devuelve el número total de entradas que tiene.</p>
<p>function <strong>Dictionary_GetItem</strong> (dict, index) : value</p>
<p>A partir del índice (empezando a contar desde 0) de una entrada de un diccionario &lt;dict&gt;, nos devolverá el valor asociado. En caso de que el índice no sea válido, el valor devuelto será NULL.</p>
<p>function <strong>Dictionary_GetItemIndex</strong> (dict, key) : int</p>
<p>Dados un diccionario &lt;dict&gt; y una clave &lt;key&gt;, obtenemos el índice (empezando a contar desde 0) asociado a la clave. En caso de que la clave no exista, devolverá -1.</p>
<p>function <strong>Dictionary_GetItemKey</strong> (dict, index) : string</p>
<p>Permite obtener la clave asociada a un índice &lt;index&gt; dentro del diccionario &lt;dict&gt;. Si el índice esta fuera del rango del diccionario, se devolverá cadena vacía.</p>
<p>function <strong>Dictionary_InsertItem</strong> (dict, key, value)</p>
<p>Dado un diccionario &lt;dict&gt;, permite agregar o modificar un valor &lt;value&gt; asociado a la clave &lt;key&gt;. Si la clave ya existe en el diccionario, reemplazaremos el valor que ya tuviese asociado por el nuevo. En caso de que la clave no exista, se agregará al diccionario.</p>
<p>function <strong>Dictionary_IsKey</strong> (dict, key) : bool</p>
<p>Permite averiguar si la clave &lt;key&gt; existe dentro del diccionario &lt;dict&gt;. En caso de que exista, devolverá verdadero. En caso contrario, devolverá falso.</p>
<p>function <strong>Dictionary_Set</strong> (dict, index, value)</p>
<p>Modifica el valor &lt;value&gt; asociado al índice (empezando a contar desde 0) &lt;index&gt; en el diccionario &lt;dict&gt;. Si el índice esta fuera de rango, no se modificará el valor.</p>
<p>function <strong>Dictionary_SetCaseSensitive</strong> (dict, cs)</p>
<p>Las claves de un diccionario, a la hora de acceder a ellas, pueden ser sensibles a mayúsculas y minúsculas o no serlo. Por defecto, un diccionario, tras su creación, tiene esta posibilidad desactivada. Si queremos activarla habrá que indicar &lt;cs&gt; como verdadero.</p>
<p>function <strong>Dictionary_SetItem</strong> (dict, key, value)</p>
<p>Permite modificar el valor asociado a la clave &lt;key&gt; sustituyéndolo por el indicado en &lt;value&gt; dentro del diccionario &lt;dict&gt;.</p>
<h2 id="netsocket">NetSocket</h2>
<p>Funciones para la creación de sockets y comunicación UDP/TCP/Bluetooth.</p>
<p>function <strong>NetSocket_New</strong> (context, type) : pointer</p>
<p>Permite crear una instancia de objeto NetSocket. El parámetro &lt;context&gt; indicará dónde invocar los eventos ocurridos durante la comunicación.</p>
<p>El tipo &lt;type&gt; puede ser:</p>
<table>
<thead>
<tr class="header">
<th>SOCKET_TYPE_TCP</th>
<th>Comunicación TCP IPv4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SOCKET_TYPE_UDP</td>
<td>Comunicación UDP IPv4</td>
</tr>
<tr class="even">
<td>SOCKET_TYPE_TCP_IPV6</td>
<td>Comunicación TCP IPv6</td>
</tr>
<tr class="odd">
<td>SOCKET_TYPE_UDP_IPV6</td>
<td>Comunicación UDP IPv6</td>
</tr>
<tr class="even">
<td>SOCKET_TYPE_BLUETOOTH</td>
<td>Comunicación Bluetooth</td>
</tr>
</tbody>
</table>
<p>function <strong>NetSocket_Delete</strong> (socket) : bool</p>
<p>Elimina y libera recursos asociados por la instancia de objeto NetSocket &lt;socket&gt;.</p>
<p>function <strong>NetSocket_Connect</strong> (socket, host, port, sync = false) : int</p>
<p>Establece conexión a un destino &lt;host&gt; a través del puerto &lt;port&gt;. El parámetro &lt;host&gt; es una cadena de texto que representará una IP o un nombre de dominio a resolver. Mediante el parámetro &lt;sync&gt; indicamos si queremos que la función sea bloqueante (síncrona) o no. Si es síncrona, hasta que no se resuelva la conexión no se saldrá de la función, mientras que si es asíncrona, se saldrá de inmediato de la función y una vez se resuelva la conexión se invocará el evento <em>NET_Event_Connect</em>.</p>
<p>function <strong>NetSocket_Listen</strong> (socket, host, port, times) : int</p>
<p>Establece una escucha a través de un socket, indicando desde qué anfitrión y puerto se desea escuchar. El parámetro &lt;times&gt; permite indicar el número de conexiones que se permiten aceptar, siendo -1 un número de conexiones indefinidas.</p>
<p>function <strong>NetSocket_Recv</strong> (socket, len, id = 0) : int</p>
<p>Lee de un socket una cantidad de bytes &lt;len&gt;. El parámetro &lt;id&gt; sirve para identificar esa lectura con el evento <em>NET_Event_Recv</em> recibido. Esta función es asíncrona.</p>
<p>function <strong>NetSocket_Send</strong> (socket, buffer, off = 0, len = -1) : int</p>
<p>Escribe en un socket una cantidad de bytes &lt;len&gt; indicada a través del objeto &lt;buffer&gt;. Se puede especificar un desplazamiento sobre el offset &lt;off&gt; y cuando &lt;len&gt; es -1 se usará el tamaño del buffer. Esta función es síncrona.</p>
<p>function <strong>NetSocket_SetNoDelay</strong> (socket, v)</p>
<p>Habilita o deshabilita el algoritmo de Nagle en las comunicaciones. Este algoritmo intenta evitar la congestión de paquetes pequeños en las comunicaciones TCP.</p>
<p>function <strong>NetSocket_SetNonBlocking</strong> (socket, v)</p>
<p>Habilita o deshabilita el bloqueo en ciertas operaciones que son bloqueantes como en la conexión, envío y recepción de datos.</p>
<p>function <strong>NetSocket_SetRecvID</strong> (socket, id)</p>
<p>Permite asignar un ID a todos los paquetes enviados a través de este socket. De esta forma, todos los paquetes enviados serán recibidos con el &lt;id&gt; indicado en el remoto.</p>
<p>function <strong>NetSocket_SetRecvMode</strong> (socket, mode)</p>
<p>Establece el modo de recepción de paquetes. Existen estos modos:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>RECVMODE_NORMAL</th>
<th>En cuanto se reciben los bytes indicados en un Recv, se lanza un evento Net_Event_Recv.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RECVMODE_DYNAMIC</td>
<td>Todos los paquetes enviados están compuestos por 4 bytes (un entero) con el tamaño de datos y a continuación los datos. Recibida toda esta información se lanza el evento Net_Event_Recv.</td>
</tr>
</tbody>
</table>
<p>function <strong>NetSocket_SyncRecv</strong> (socket, buffer, offset = 0, len = -1, timeout = 0) : int</p>
<p>Lee datos desde un socket de forma síncrona. Estos datos se leen y se almacenan en un objeto &lt;buffer&gt; al que le podemos indicar su byte inicial de escritura &lt;offset&gt;. Podemos especificar los bytes a leer, y en el caso de que &lt;len&gt; sea -1, leeremos tantos bytes como tamaño tenga el buffer. Podemos establecer un tiempo &lt;timeout&gt; en el que si no hemos leído los bytes que indicamos, termina la operación (si ponemos un cero, indicamos que no queremos considerar este tiempo).</p>
<p>function <strong>NetSocket_SyncSend</strong> (socket, buffer, offset = 0, len = -1) : int</p>
<p>Escribe datos a un socket de forma síncrona. Esta función es similar a <em>NetSocket_SyncRecv</em>, solo que en este caso sirve para escribir.</p>
<p>function <strong>NetSocket_GetErrorMessage</strong> (socket) : string</p>
<p>Retorna un mensaje de error en el caso de que se haya producido en una operación previa. Esta función permite obtener más información sobre el error acontecido.</p>
<p>function <strong>NetSocket_GetIPs</strong> (host, ipV6 = false) : list</p>
<p>Dado el nombre de un host, obtendrá las direcciones IPv4 o IPv6 asociadas, dependiendo del valor del parámetro &lt;ipV6&gt;.</p>
<p><strong>Eventos:</strong></p>
<p>function <strong>Net_Event_Connect</strong> (error)</p>
<p>function <strong>Net_Event_Listen</strong> (socket, host, port)</p>
<p>function <strong>Net_Event_Recv</strong> (id, buffer, error)</p>
<h2 id="regex">RegEx</h2>
<p>Funciones para la manipulación de expresiones regulares complejas. Las expresiones regulares son cadenas de caracteres que establecen un patrón de búsqueda y/o sustitución dentro de otras cadenas.</p>
<p>function <strong>Regex_New</strong> (pattern, flags = 0) : pointer</p>
<p>Crea un objeto Regex que representará el patrón de búsqueda pasado como argumento en &lt;pattern&gt;.</p>
<p>Podemos establecer los siguientes flags:</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>REGEX_ICASE</th>
<th>Las expresiones regulares coinciden sin importar mayúsculas/minúsculas.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REGEX_NOSUBS</td>
<td>No reportar las posiciones de las coincidencias.</td>
</tr>
<tr class="even">
<td>REGEX_OPTIMIZE</td>
<td>Se prefiere la eficiencia coincidente sobre la eficiencia en la construcción de objetos regex.</td>
</tr>
<tr class="odd">
<td>REGEX_COLLATE</td>
<td>Los rangos de caracteres, como “[a-b]”, se ven afectados por la configuración regional.</td>
</tr>
<tr class="even">
<td>REGEX_BASIC</td>
<td>Gramática POSIX básica.</td>
</tr>
<tr class="odd">
<td>REGEX_EXTENDED</td>
<td>Gramática POSIX extendida.</td>
</tr>
<tr class="even">
<td>REGEX_AWK</td>
<td>Gramática POSIX Awk.</td>
</tr>
<tr class="odd">
<td>REGEX_GREP</td>
<td>Gramática POSIX Grep.</td>
</tr>
<tr class="even">
<td>REGEX_EGREP</td>
<td>Gramática POSIX Egrep.</td>
</tr>
<tr class="odd">
<td>REGEX_ECMASCRIPT</td>
<td>Por defecto.</td>
</tr>
</tbody>
</table>
<p>function <strong>Regex_Delete</strong> (regex)</p>
<p>Elimina y libera de memoria un objeto de tipo RegEx creado previamente usando la función <em>Regex_New</em>.</p>
<p>function <strong>Regex_Match</strong> (regex, str, flags) : list</p>
<p>Localiza todas aquellas coincidencias de la expresión regular dentro de la cadena &lt;str&gt; y las devuelve en una lista. Las coincidencias deben ser exactas. Esta lista estará formada por binomios en los que un elemento será la cadena coincidente y el otro será la posición/índice de la misma dentro de &lt;str&gt;.</p>
<p>Los flags podrán ser:</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>REGEX_MATCH_DEFAULT</th>
<th>Por defecto.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REGEX_MATCH_NOTBOL</td>
<td>El primer carácter no se considera un comienzo de línea (“^” no coincide).</td>
</tr>
<tr class="even">
<td>REGEX_MATCH_NOTEOL</td>
<td>El último carácter no se considera un final de línea (“$” no coincide).</td>
</tr>
<tr class="odd">
<td>REGEX_MATCH_NOTBOW</td>
<td>La secuencia de escape “\b” no coincide como principio de palabra.</td>
</tr>
<tr class="even">
<td>REGEX_MATCH_NOTEOW</td>
<td>La secuencia de escape “\b” no coincide como un final de palabra.</td>
</tr>
<tr class="odd">
<td>REGEX_MATCH_ANY</td>
<td>Cualquier coincidencia es aceptable si es posible más de una coincidencia.</td>
</tr>
<tr class="even">
<td>REGEX_MATCH_NOTNULL</td>
<td>Las secuencias vacías no coinciden.</td>
</tr>
<tr class="odd">
<td>REGEX_MATCH_CONTINUOUS</td>
<td>La expresión debe coincidir con una subsecuencia que comienza en el primer carácter. Las subsecuencias deben comenzar en el primer carácter que coincida.</td>
</tr>
<tr class="even">
<td>REGEX_MATCH_PREVAVAIL</td>
<td>Uno o más caracteres existen antes del primero (se ignoran REGEX_MATCH_NOTBOL y REGEX_MATCH_NOTBOW)</td>
</tr>
</tbody>
</table>
<p>function <strong>Regex_Replace</strong> (regex, fstr, rstr, flags) : string</p>
<p>Localiza los patrones dentro de la cadena &lt;fstr&gt; y los sustituye por los indicados en la cadena &lt;rstr&gt;.</p>
<p>Los flags podrán ser los mismos que <em>Regex_Match</em> (véanse).</p>
<p>Y además también se permite combinar con estos:</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>REGEX_FORMAT_DEF</th>
<th>Por defecto. Utiliza las reglas de formato estándar para reemplazar las coincidencias (las utilizadas por el método de reemplazo de ECMAScript).</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>REGEX_FORMAT_SED</td>
<td>Utiliza las mismas reglas que la utilidad sed en POSIX para reemplazar las coincidencias.</td>
</tr>
<tr class="even">
<td>REGEX_FORMAT_NOCOPY</td>
<td>Las secciones en la secuencia de destino que no coinciden con la expresión regular no se copian al reemplazar coincidencias.</td>
</tr>
<tr class="odd">
<td>REGEX_FORMAT_FIRSTONLY</td>
<td>Solo se reemplaza la primera aparición de una expresión regular.</td>
</tr>
</tbody>
</table>
<p>function <strong>Regex_Search</strong> (regex, str, flags) : list</p>
<p>Localiza todas aquellas coincidencias de la expresión regular dentro de la cadena &lt;str&gt; y las devuelve en una lista. Esta lista estará formada por binomios en los que un elemento será la cadena coincidente y el otro será la posición/índice de la misma dentro de &lt;str&gt;.</p>
<p>Los flags podrán ser los mismos que <em>en Regex_Match</em> (véanse).</p>
<h2 id="timer">Timer</h2>
<p>Funciones para la creación, destrucción y manejo de temporizadores. Estos pueden funcionar con una precisión de milisegundos o nanosegundos.</p>
<p>function <strong>Timer_New</strong> (name, ctx, function, freq, hiRes = false) : pointer</p>
<p>Crea una instancia de objeto temporizador con nombre &lt;name&gt;. Esta instancia invocará en el contexto &lt;ctx&gt; la función con nombre &lt;function&gt;. Esta llamada se hará cada &lt;freq&gt; milisegundos o nanosegundos. Para indicar si queremos que sean nanosegundos pasaremos verdadero al argumento &lt;hiRes&gt;.</p>
<p>Los temporizadores se crean parados. Para activarlos se debe usar <em>Timer_Start</em>.</p>
<p>function <strong>Timer_Delete</strong> (timer)</p>
<p>Libera de memoria y elimina del sistema la instancia del objeto temporizador &lt;timer&gt;.</p>
<p>function <strong>Timer_Get</strong> (name) : pointer</p>
<p>Obtiene el acceso a la instancia del objeto temporizador creado con nombre &lt;name&gt;.</p>
<p>function <strong>Timer_GetFrequency</strong> (timer) : double</p>
<p>Retorna la frecuencia de repetición del temporizador &lt;timer&gt; en milisegundos o nanosegundos, según se haya creado normal o de alta resolución.</p>
<p>function <strong>Timer_GetUserData</strong> (timer) : pointer</p>
<p>Devuelve los datos de usuario asociados a la instancia de objeto temporizador &lt;timer&gt;.</p>
<p>function <strong>Timer_IsStopped</strong> (timer) : bool</p>
<p>Indica si el temporizador &lt;timer&gt; está parado o en funcionamiento. Véanse también <em>Timer_Start</em> y <em>Timer_Stop</em>.</p>
<p>function <strong>Timer_Reset</strong> (timer)</p>
<p>Vuelve a poner a cero el contador interno que invoca la función en el contexto asociados en el temporizador &lt;timer&gt;.</p>
<p>function <strong>Timer_SetCallback</strong> (timer, ctx, function)</p>
<p>Permite asignar el nombre de la función &lt;function&gt; que se invocará en el contexto &lt;ctx&gt; según la frecuencia programada en el temporizador &lt;timer&gt;. Véase <em>Timer_SetFrequency</em>.</p>
<p>function <strong>Timer_SetFrequency</strong> (timer, freq)</p>
<p>Asigna la frecuencia &lt;freq&gt; en el temporizador &lt;timer&gt; con la que se invocará la función dentro del contexto establecido. Véase <em>Timer_SetCallback</em>.</p>
<p>function <strong>Timer_SetUserData</strong> (timer, data, checkCtx = true)</p>
<p>Permite asociar datos de usuario a un temporizador &lt;timer&gt;. Estos datos &lt;data&gt; pueden ser una instancia a una clase u otro tipo de datos (string, buffer, números, etc.). Si los datos que pasamos no son de una instancia de clase, lo indicaremos con &lt;checkCtx&gt; con valor falso.</p>
<p>function <strong>Timer_Start</strong> (timer)</p>
<p>Reanuda un temporizador &lt;timer&gt; en caso de estar parado. Véase <em>Timer_Stop</em>.</p>
<p>function <strong>Timer_Stop</strong> (timer)</p>
<p>Detiene un temporizador &lt;timer&gt; en caso de estar en marcha. Véase <em>Timer_Start</em>.</p>
<h2 id="systime">SysTime</h2>
<p>Conjunto de funciones para la manipulación de FECHA y HORA.</p>
<p>function <strong>SysTime_New</strong> () : pointer</p>
<p>Crea una instancia de objeto SysTime.</p>
<p>function <strong>SysTime_Delete</strong> (st)</p>
<p>Elimina y libera recursos utilizados por la instancia de objeto SysTime &lt;st&gt;.</p>
<p>function <strong>SysTime_Compare</strong> (st1, st2) : int</p>
<p>Compara dos instancias de objeto SysTime. Según el valor devuelto por la función podemos saber:</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>&lt;st1&gt; es una fecha/hora posterior a &lt;st2&gt;.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-1</td>
<td>&lt;st1&gt; es una fecha/hora anterior a &lt;st2&gt;.</td>
</tr>
<tr class="even">
<td>0</td>
<td>&lt;st1&gt; y &lt;st2&gt; son la misma fecha/hora.</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>function <strong>SysTime_Format</strong> (st, fmt, values)</p>
<p>Permite establecer la fecha/hora de una instancia de objeto SysTime &lt;st&gt; utilizando un formato dado en una cadena de caracteres &lt;fmt&gt; y que requiere de los valores &lt;values&gt; también indicados en una cadena de caracteres.</p>
<p>El formato podrá indicar:</p>
<table>
<thead>
<tr class="header">
<th>DD</th>
<th>Día del mes, del 1 al 31</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MM</td>
<td>Número del mes, del 1 al 12</td>
</tr>
<tr class="even">
<td>YYYY</td>
<td>Número del año en 4 dígitos</td>
</tr>
<tr class="odd">
<td>YY</td>
<td>Número del año en 2 dígitos. A este número se le sumará 1900</td>
</tr>
<tr class="even">
<td>hh</td>
<td>Hora, del 0 al 23</td>
</tr>
<tr class="odd">
<td>mm</td>
<td>Minutos, del 0 al 59</td>
</tr>
<tr class="even">
<td>ss</td>
<td>Segundos, del 0 al 59</td>
</tr>
<tr class="odd">
<td>ms</td>
<td>Milisegundos, del 0 al 999</td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<pre><code>SysTime_Format(_st, &quot;YYYY/MM/DD hh:mm:ss&quot;, &quot;1999/10/23 08:35:12&quot;);</code></pre>
<p>function <strong>SysTime_Get</strong> (st) : list</p>
<p>Dada una instancia de objeto SysTime &lt;st&gt;, nos devuelve una lista con los componentes, en este orden:</p>
<table>
<thead>
<tr class="header">
<th>Año</th>
<th>Año (a partir del 1900)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mes</td>
<td>Mes en formato del 1 al 12</td>
</tr>
<tr class="even">
<td>Día</td>
<td>Día en formato del 1 al 31</td>
</tr>
<tr class="odd">
<td>Hora</td>
<td>Hora en formato del 0 al 23</td>
</tr>
<tr class="even">
<td>Minuto</td>
<td>Minuto en formato del 0 al 59</td>
</tr>
<tr class="odd">
<td>Segundo</td>
<td>Segundo en formato del 0 al 59</td>
</tr>
<tr class="even">
<td>Milisegundo</td>
<td>Milisegundo en formato del 0 al 999</td>
</tr>
<tr class="odd">
<td>Día de la semana</td>
<td>Número del 1 al 7</td>
</tr>
</tbody>
</table>
<p>function <strong>SysTime_Set</strong> (st, year, month, day, hour, minute, second, ms)</p>
<p>Permite inicializar la fecha y hora en la instancia &lt;st&gt; usando los valores de año &lt;year&gt;, mes &lt;month&gt;, día &lt;day&gt;, hora &lt;hour&gt;, minuto &lt;minute&gt;, segundo &lt;second&gt; y milisegundo &lt;ms&gt;.</p>
<p>function <strong>SysTime_SetMilliseconds</strong> (st, ms)</p>
<p>Dado un número de milisegundos absolutos &lt;ms&gt; se actualizará la instancia del objeto SysTime &lt;st&gt;. Este número de milisegundos toma como referencia la fecha inicial: 1 de enero de 1900.</p>
<p>function <strong>SysTime_ToMilliseconds</strong> (st) : long</p>
<p>Devuelve el número de milisegundos absolutos de una determinada fecha y hora. El número de milisegundos se calcula a partir de la fecha inicial: 1 de enero de 1900.</p>
<p>En caso de que &lt;st&gt; valga NULL, devolverá el tiempo absoluto en milisegundos de la fecha y hora actuales.</p>
<p>function <strong>SysTime_ToString</strong> (st, fmt) : string</p>
<p>Devuelve la cadena de caracteres que representa la fecha y hora de la instancia de objeto SysTime indicada en &lt;st&gt;. El formato &lt;ftm&gt; es una cadena de caracteres donde se puede indicar cualquier texto y modificadores. Estos modificadores pueden ser:</p>
<table>
<thead>
<tr class="header">
<th>ddd</th>
<th>Tres primeras letras del nombre del día de la semana en inglés.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DD</td>
<td>Día de la semana del 1 al 31.</td>
</tr>
<tr class="even">
<td>mmm</td>
<td>Tres primeras letras del nombre del mes en inglés.</td>
</tr>
<tr class="odd">
<td>MM</td>
<td>Número de mes del 1 al 12.</td>
</tr>
<tr class="even">
<td>YYYY</td>
<td>Año en 4 dígitos.</td>
</tr>
<tr class="odd">
<td>YY</td>
<td>Últimos dos dígitos del año.</td>
</tr>
<tr class="even">
<td>hh</td>
<td>Hora en formato 00 a 24.</td>
</tr>
<tr class="odd">
<td>mm</td>
<td>Minutos en formato 00 a 59.</td>
</tr>
<tr class="even">
<td>ss</td>
<td>Segundos en formato 00 a 59.</td>
</tr>
<tr class="odd">
<td>ms</td>
<td>Milisegundos en formato 000 a 999.</td>
</tr>
</tbody>
</table>
<p>Ejemplo:</p>
<p>SysTime_Update(_st);<br />
_str = SysTime_ToString(_st, “Fecha: YYYY/MM/DD Hora: hh:mm:ss”);</p>
<p>function <strong>SysTime_Update</strong> (st)</p>
<p>Se actualiza con la fecha y hora del reloj del sistema.</p>
<h2 id="zip">ZIP</h2>
<p>Funciones para operar con archivos de tipo ZIP. Los archivos ZIP contienen archivos y carpetas en su interior en un formato comprimido.</p>
<p>function <strong>ZIP_Open</strong> (path, pwd = 0) : pointer</p>
<p>Abre un archivo ZIP que se encuentra en la ruta &lt;path&gt; y devuelve un controlador. Se puede indicar una contraseña &lt;pwd&gt; en el caso de que esté cifrado. Si &lt;pwd&gt; vale 0 (valor por defecto) se considerará que el ZIP no está cifrado.</p>
<p>function <strong>ZIP_Close</strong> (zip)</p>
<p>Dado un controlador a un archivo &lt;zip&gt;, lo cierra.</p>
<p>function <strong>ZIP_FindFirstFile</strong> (zip, folder, pattern) : list</p>
<p>Obtiene los distintos archivos existentes dentro de una carpeta ubicada en un ZIP. Con esta función comenzaremos una búsqueda usando el controlador &lt;zip&gt;, la carpeta donde queremos buscar &lt;folder&gt; y el patrón de búsqueda &lt;pattern&gt;. La función retornará una lista con los siguientes elementos:</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>FHANDLE</th>
<th>Controlador para seguir encontrando nuevas entradas. Se usa en <em>ZIP_FindNextFile</em> y <em>ZIP_FindCloseFIle.</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FILENAME</td>
<td>Nombre de la entrada.</td>
</tr>
<tr class="even">
<td>SIZE</td>
<td>Tamaño de la entrada en bytes.</td>
</tr>
<tr class="odd">
<td>SIZE COMPRESSED</td>
<td>Tamaño comprimido de la entrada en bytes.</td>
</tr>
<tr class="even">
<td>TIME CREATED</td>
<td>Fecha de creación en milisegundos.</td>
</tr>
<tr class="odd">
<td>TIME MODIFIED</td>
<td>Fecha de modificación en milisegundos.</td>
</tr>
</tbody>
</table>
<p>Si FHANDLE es NULL, es que no se ha encontrado ninguna entrada.</p>
<p>function <strong>ZIP_FindNextFile</strong> (fhandle) : list</p>
<p>Dado un controlador &lt;fhandle&gt; de búsqueda de entradas en un ZIP, obtendremos la siguiente entrada que coincida con el patrón de búsqueda establecido en <em>ZIP_FindFirstFile</em>. El valor retornado será igual al de <em>ZIP_FindFirstFile</em>, salvo que el primer componente de la lista es un booleano que indica si es la última entrada encontrada.</p>
<p>function <strong>ZIP_FindCloseFile</strong> (fhandle)</p>
<p>Finaliza y libera recursos asociados con la búsqueda de entradas comenzada con la función <em>ZIP_FindFirstFile</em>.</p>
<p>function <strong>ZIP_GetFile</strong> (zip, path, mode) : pointer</p>
<p>Permite abrir un archivo dentro de un ZIP. Usarermos el controlador &lt;zip&gt; para obtener el objeto File asociado al destino establecido en &lt;path&gt;. Este archivo se abrirá como de lectura o escritura en función del modo indicado en &lt;mode&gt;. Véase <em>File_Open</em>.</p>
<h2 id="file">File</h2>
<p>Funciones para la manipulación de archivos a bajo nivel.</p>
<p>function <strong>File_Open</strong> (path, mode) : pointer</p>
<p>Obtiene el controlador al archivo con ruta indicada en la cadena &lt;path&gt;. Sin embargo, es posible indicar en el parámetro &lt;path&gt; bien una instancia a un Buffer o a un String. En tal caso, solo los modos FILE_MODE_READMEM y FILE_MODE_WRITEMEM estarán disponibles. Los modos que se pueden indicar en el parámetro &lt;mode&gt; son:</p>
<table>
<thead>
<tr class="header">
<th>FILE_MODE_READMEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FILE_MODE_WRITEMEM</td>
</tr>
<tr class="even">
<td>FILE_MODE_READ</td>
</tr>
<tr class="odd">
<td>FILE_MODE_WRITE</td>
</tr>
<tr class="even">
<td>FILE_MODE_APPEND</td>
</tr>
<tr class="odd">
<td>FILE_MODE_READTEXT</td>
</tr>
<tr class="even">
<td>FILE_MODE_WRITETEXT</td>
</tr>
<tr class="odd">
<td>FILE_MODE_APPENDTEXT</td>
</tr>
<tr class="even">
<td>FILE_MODE_READTEXT_UTF8</td>
</tr>
<tr class="odd">
<td>FILE_MODE_WRITETEXT_UTF8</td>
</tr>
<tr class="even">
<td>FILE_MODE_APPENDTEXT_UTF8</td>
</tr>
<tr class="odd">
<td>FILE_MODE_READTEXT_UNICODE</td>
</tr>
<tr class="even">
<td>FILE_MODE_WRITETEX_UNICODE</td>
</tr>
<tr class="odd">
<td>FILE_MODE_APPENDTEXT_UNICODE</td>
</tr>
<tr class="even">
<td>FILE_MODE_READTEXT_UTF16LE</td>
</tr>
<tr class="odd">
<td>FILE_MODE_WRITETEXT_UTF16LE</td>
</tr>
<tr class="even">
<td>FILE_MODE_APPENDTEXT_UTF16LE</td>
</tr>
</tbody>
</table>
<p>function <strong>File_Close</strong> (handle)</p>
<p>Cierra el controlador de archivo &lt;handle&gt;.</p>
<p>function <strong>File_Flush</strong> (handle)</p>
<p>Fuerza el volcado de datos en un archivo abierto en modo escritura. Las operaciones de escritura no tienen por qué actualizar el archivo cada vez que se usan. Mediante esta función, forzamos a que todos aquellos datos por guardar se vuelquen en el archivo.</p>
<p>function <strong>File_GetPos</strong> (handle) : ulong</p>
<p>Obtiene la posición donde se está leyendo y/o escribiendo en el archivo referenciado por el controlador &lt;handle&gt;. Esta posición se mide en bytes y está dentro del rango del tamaño del archivo.</p>
<p>function <strong>File_IsEOF</strong> (handle) : bool</p>
<p>Indica si el archivo referenciado por &lt;handle&gt; ha alcanzado el final del mismo.</p>
<p>function <strong>File_Read</strong> (handle, buffer, offset = 0, len = -1) : int</p>
<p>Lectura de &lt;len&gt; bytes del archivo referenciado por &lt;handle&gt;. Los datos leídos se almacenarán en la instancia de objeto Buffer &lt;buffer&gt; a partir de su posición &lt;offset&gt;. En caso de no especificar &lt;offset&gt; se asumirá el principio del buffer. Del mismo modo, si no se especifica el número de bytes a leer &lt;len&gt; se leerán tantos bytes como tamaño del buffer. En caso de que el tamaño del archivo sea menor que el tamaño del buffer, solo se rellenará la parte del buffer correspondiente. La función retornará el número de bytes leídos.</p>
<p>function <strong>File_ReadByte</strong> (handle) : byte</p>
<p>Lee un entero de un byte (8 bits) del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadShort</strong> (handle) : short</p>
<p>Lee un entero de dos bytes (16 bits) del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadInt</strong> (handle) : int</p>
<p>Lee un entero de cuatro bytes (32 bits) del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadLong</strong> (handle) : int</p>
<p>Lee un entero de ocho bytes (64 bits) del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadFloat</strong> (handle) : float</p>
<p>Lee un número flotante de cuatro bytes del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadDouble</strong> (handle) : double</p>
<p>Lee un número flotante de ocho bytes del archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_ReadString</strong> (handle) : string</p>
<p>Lee una cadena de caracteres del archivo referenciado por el controlador &lt;handle&gt;. Es importante señalar que se espera que la cadena sea ASCIIZ, o sea, que finalice con un carácter NULO (valor cero).</p>
<p>function <strong>File_ReadText</strong> (handle, maxLen = 256, delRet = true) : string</p>
<p>Lee una cadena de texto del archivo referenciado por el controlador &lt;handle&gt;. Se leerá hasta que la cadena tenga &lt;maxLen&gt; bytes o hasta que encuentre un retorno de carro. En caso de encontrar un retorno de carro, si &lt;delRet&gt; es verdadero, este no se agregará a la cadena de texto devuelta por la función.</p>
<p>function <strong>File_Seek</strong> (handle, offset, mode) : ulong</p>
<p>Permite mover la posición de lectura y/o escritura dentro del archivo referenciado por &lt;handle&gt;. La nueva posición la determinaremos mediante el parámetro &lt;offset&gt;, que dependiendo del modo &lt;mode&gt; ubicará esta posición:</p>
<table>
<thead>
<tr class="header">
<th>FILE_SEEK_SET</th>
<th>Desde el principio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FILE_SEEK_CUR</td>
<td>Desde la posición en la que está</td>
</tr>
<tr class="even">
<td>FILE_SEEK_END</td>
<td>Desde el final hacia atrás</td>
</tr>
</tbody>
</table>
<p>function <strong>File_SetPos</strong> (handle, pos)</p>
<p>Dado un controlador de archivo &lt;handle&gt;, asignaremos la posición de lectura y/o escritura &lt;pos&gt; en base al comienzo del archivo. Sería como hacer un <em>File_Seek(handle, pos, FILE_SEEK_SET).</em></p>
<p>function <strong>File_Size</strong> (handle) : ulong</p>
<p>Devuelve el tamaño en bytes de un archivo a partir del controlador &lt;handle&gt;.</p>
<p>function <strong>File_Write</strong> (handle, buffer, offset = 0, len = -1) : int</p>
<p>Escribe &lt;len&gt; bytes en el archivo referenciado por &lt;handle&gt;. Los datos escritos se obtienen de la instancia de objeto Buffer &lt;buffer&gt; a partir de su posición &lt;offset&gt;. En caso de no especificar &lt;offset&gt; se asumirá el principio del buffer. Del mismo modo, si no se especifica el número de bytes &lt;len&gt; se escribirán tantos bytes como tamaño del buffer. La función retornará el número de bytes escritos.</p>
<p>function <strong>File_WriteByte</strong> (handle, value) : int</p>
<p>Escribe un entero de un byte (8 bits) al archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteShort</strong> (handle, value) : int</p>
<p>Escribe un entero de dos bytes (16 bits) al archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteInt</strong> (handle, value) : int</p>
<p>Escribe un entero de cuatro bytes (32 bits) al archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteLong</strong> (handle, value) : int</p>
<p>Escribe un entero de ocho bytes (64 bits) al archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteFloat</strong> (handle, value) : int</p>
<p>Escribe un número flotante de cuatro bytes al archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteChars</strong> (handle, str) : int</p>
<p>Escribe todos los caracteres existentes en la cadena &lt;str&gt;, a excepción del carácter NULO (valor cero) final, en el archivo referenciado por el controlador &lt;handle&gt;.</p>
<p>function <strong>File_WriteString</strong> (handle, str) : int</p>
<p>Se guarda la cadena de caracteres &lt;str&gt; en el archivo referenciado por &lt;handle&gt;. Los bytes guardados se devuelven por la función y coincidirán con el número de caracteres de la cadena más el carácter NULO (valor cero) final.</p>
<p>function <strong>File_WriteText</strong> (handle, str) : int</p>
<p>Es la forma de guardar texto teniendo en cuenta que el archivo donde escribimos se ha abierto en modo texto. Esta forma de guardar cadenas de caracteres tiene en cuenta la forma de codificar los saltos de línea. Además de guardar la cadena de caracteres se agrega un salto de línea adicional.</p>
<p>function <strong>File_IsOpened</strong> (path) : bool</p>
<p>Dada una ruta a un archivo &lt;path&gt;, podemos saber si se trata de un archivo abierto para lectura/escritura, o sea, que ya está siendo utilizado.</p>
<p>function <strong>File_Exists</strong> (path) : bool</p>
<p>Permite averiguar si un archivo de una ruta &lt;path&gt; existe. En caso afirmativo, la función devolverá verdadero.</p>
<p>function <strong>File_GetAttributes</strong> (path) : uint</p>
<p>Obtiene los flags que indican ciertos atributos del archivo referenciado por la ruta &lt;path&gt;. Estos flags son los siguientes:</p>
<table>
<thead>
<tr class="header">
<th>FFI_ATTRIBUTE_DIRECTORY</th>
<th>El archivo hace referencia a un directorio.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FFI_ATTRIBUTE_ARCHIVE</td>
<td>El archivo no es un directorio.</td>
</tr>
<tr class="even">
<td>FFI_ATTRIBUTE_SYSTEM</td>
<td>El archivo es de sistema.</td>
</tr>
<tr class="odd">
<td>FFI_ATTRIBUTE_HIDDEN</td>
<td>El archivo está oculto.</td>
</tr>
<tr class="even">
<td>FFI_ATTRIBUTE_READONLY</td>
<td>El archivo es de solo lectura.</td>
</tr>
</tbody>
</table>
<p>function <strong>File_SetAttributes</strong> (path, flags) : bool</p>
<p>Permite establecer los atributos asociados a un archivo con ruta &lt;path&gt;. Para ver los atributos permitidos &lt;flags&gt;. Véase <em>File_GetAttributes.</em></p>
<p>function <strong>File_GetDate</strong> (path) : pointer</p>
<p>Obtiene la fecha/hora de un archivo ubicando en la ruta &lt;path&gt; en formato SysTime. Por tanto se devuelve una instancia de objeto que cuando dejemos de utilizar tenemos que destruir con la función <em>SysTime_Delete</em> (véase).</p>
<h2 id="texture">Texture</h2>
<p>Las texturas son áreas de memoria que definen una imagen. Estas áreas de memoria tienen un formato que define todos y cada uno de los texels (los pixeles de la textura).</p>
<p>Por ejemplo, un formato podría ser A8R8G8B8, o sea, cada texel usaría 4 bytes:</p>
<table>
<thead>
<tr class="header">
<th>ALPHA</th>
<th>RED</th>
<th>GREEN</th>
<th>BLUE</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>Si nuestra textura ocupase un área de 100 x 100 texels, su tamaño sería de 40.000 bytes.</p>
<p>Existen diferentes formatos de texel, aunque los más comunes son los que utilizan componentes RGB o ARGB.</p>
<p>En algunas funciones para trabajar con texturas se habla de su área, lo cual hace referencia a una posición (x, y) y un tamaño (w, h):</p>
<p>A continuación se enumeran las distintas funciones existentes en el API:</p>
<p>function <strong>Texture_Load</strong> (path, useCache = true) : pointer</p>
<p>Carga una textura a partir del archivo gráfico que se encuentra en la ruta &lt;path&gt;. Este archivo podrá tener una de las siguientes extensiones: BMP, TGA, PCX, IFL, JPG, PNG, TIF, GIF, MKI, MAG. En función de la extensión el archivo se procesará de un modo u otro. La función retornará un controlador de textura; en caso de error por falta de memoria o por archivo corrupto, se devolverá NULL. Por defecto, si una textura con ruta &lt;path&gt; ya se ha cargado previamente, no se volverá a cargar para no emplear más memoria. En ese sentido, las texturas se cachean y, si lo que queremos es tener distintas instancias en memoria de la misma textura, tendremos que usar &lt;useCache&gt; a falso.</p>
<p>function <strong>Texture_LoadFromFile</strong> (name, format, file) : pointer</p>
<p>Nos permite cargar texturas directamente desde un controlador de archivo (véase <em>File_Open</em>). Indicaremos un nombre &lt;name&gt; para identificar a esa textura dentro del sistema e indicaremos el formato del archivo &lt;format&gt; para saber qué tipo de cargador usar: TF_PNG, TF_JPG, TF_TGA, TF_PCX, TF_GIF, TF_BMP, TF_MKI, TF_MAG.</p>
<p>Ejemplo:</p>
<pre><code>_tex = Texture_LoadFromFile(&quot;mytexture&quot;, TF_PCX, _file); </code></pre>
<pre><code></code></pre>
<p>function <strong>Texture_CreateFromBuffer</strong> (ref, w, h, format, buffer) : pointer</p>
<p>Si &lt;ref&gt; es un controlador de textura, reescribirá su contenido en base al formato del buffer. Si &lt;ref&gt; es una cadena de caracteres, se creará una textura nueva con ese nombre. El buffer contendrá los datos según el formato &lt;format&gt; y un tamaño con ancho &lt;w&gt; y alto &lt;h&gt;. Los formatos disponibles serán: TF_RGBA_8888, TF_ARGB_8888, TF_RGBA_8888, TF_BGRA_4444, TF_ARGB_4444, TF_RGBA_4444, TF_JPG_DHT, TF_JPG, TF_PNG, TF_TGA, TF_BMP, TF_GIF, TF_PCX, TF_MKI, TF_MAG, TF_SC2, TF_PAL_44, TF_PAL_2222, TF_GRB_232, TF_PAL_8, TF_PAL_16, TF_YJK, TF_YJE, TF_ZX_SCR.</p>
<p>function <strong>Texture_Delete</strong> (tex)</p>
<p>Elimina una textura del sistema. Si la textura está cacheada, puede que se haya cargado más veces, y por tanto los recursos realmente se liberarán cuando se elimine la última referencia existente.</p>
<p>Ejemplo:</p>
<pre><code>_tex = Texture_Load(&quot;imagen.png&quot;);
_tex = Texture_Load(&quot;imagen.png&quot;);
// aquí no se eliminará la textura todavía
Texture_Delete(_tex); 
// aquí sí se liberarán todos los recursos usados por la textura
Texture_Delete(_tex); </code></pre>
<p>function <strong>Texture_Copy</strong> (tex1, x1, y1, w1, h1, tex2, x2, y2, w2, h2) : bool</p>
<p>Copia un área de la textura &lt;tex1&gt; con posición (x1,y1) y tamaño (w1,h1) a la textura &lt;tex2&gt; en el área con posición (x2,y2) y tamaño (w2,h2). Esta función se encarga de reescalar en el destino si es necesario, aplicando una interpolación estándar. La operación de copia requerirá que el formato de ambas texturas sea compatible entre sí, esto es, que ambas texturas tengan el mismo formato y que no sean comprimidos.</p>
<p>function <strong>Texture_FillColor</strong> (tex, x, y, w, h, color)</p>
<p>Rellena el área de una textura &lt;tex&gt; con posición (x,y) y tamaño (w,h) con el color ARGB indicado como argumento.</p>
<p>Ejemplo:</p>
<pre><code>Texture_FillColor(_tex, 15, 20, 200, 200, ARGB(255,255,0,0);</code></pre>
<p>function <strong>Texture_FSDither</strong> (tex, palette)</p>
<p>Aplica el algoritmo de Floyd-Steinberg a la textura &lt;tex&gt; usando como heurístico la paleta de colores &lt;palette&gt; en formato lista de colores.</p>
<p>function <strong>Texture_GetAniLoops</strong> (tex) : int</p>
<p>Obtiene el número de veces que se ha hecho el ciclo completo de animación en una textura con varios fotogramas. Esta función solo se aplica en texturas animadas, como por ejemplo las que se cargan a través de los archivos con extensión IFL.</p>
<p>function <strong>Texture_GetColor</strong> (tex, x, y) : uint</p>
<p>Devuelve el código de color del texel en la posición (x,y) de la textura &lt;tex&gt;. La posición no podrá ser menor que (0,0) ni mayor que (<em>Texture_GetW</em>(tex)-1, <em>Texture_GetH</em>(tex)-1).</p>
<p>Si la textura es de formato RGB o ARGB, el código de color es compatible con las funciones <em>Color</em>.</p>
<p>Para poder usar esta función es necesario hacer previamente un <em>Texture_Lock</em> y dar permisos de acceso a la textura. Una vez finalizado los accesos, actualizaremos los cambios y liberaremos el acceso con la función <em>Texture_Unlock</em>. Véase también la función <em>Texture_SetColor</em>.</p>
<p>function <strong>Texture_GetFormat</strong> (tex) : int</p>
<p>Obtiene el formato de la textura referenciada por &lt;tex&gt;.</p>
<p>function <strong>Texture_GetW</strong> (tex) : int</p>
<p>Obtiene el ancho en memoria de vídeo de la textura referenciada por &lt;tex&gt;.</p>
<p>function <strong>Texture_GetWidth</strong> (tex) : int</p>
<p>Obtiene el ancho de la textura referenciada por &lt;tex&gt;. Este no tiene por qué ser igual al usado en la memoria de vídeo: podría ocurrir que, por motivos de optimización o por restricciones de tamaño, la textura se hubiese creado con un tamaño distinto al establecido.</p>
<p>function <strong>Texture_GetH</strong> (tex) : int</p>
<p>Obtiene el alto en memoria de vídeo de la textura referenciada por &lt;tex&gt;.</p>
<p>function <strong>Texture_GetHeight</strong> (tex) : int</p>
<p>Obtiene el alto de la textura referenciada por &lt;tex&gt;. Este no tiene por qué ser igual al usado en la memoria de vídeo. Podría ocurrir que, por motivos de optimización o por restricciones de tamaño, la textura se hubiese creado con un tamaño distinto al establecido.</p>
<p>function <strong>Texture_GetName</strong> (tex) : string</p>
<p>Retorna el nombre identificativo asociado a una textura. En el caso de ser una textura cargada desde un archivo, el nombre hará referencia a la ruta de dicho archivo.</p>
<p>function <strong>Texture_GetPalette</strong> (tex, maxColors) : list</p>
<p>Aplica un análisis en la textura y hace un recuento de colores distintos. La función permite obtener una paleta de colores con un máximo de entradas &lt;maxColors&gt;. Esta paleta contendrá ese máximo de colores con mayores coincidencias con el total de los hallados.</p>
<p>function <strong>Texture_HSLColor</strong> (tex, x, y, w, h, fh, fs, fl)</p>
<p>Aplica en cada uno de los texels del área de una textura &lt;tex&gt; con posición (x,y) y tamaño (w, h) el factor Hue &lt;fh&gt;, Saturation &lt;fs&gt; y Lightness &lt;fl&gt; indicados como argumentos. Para cada texel, se obtiene el HSL de cada RGB, se multiplican los factores, se convierte de nuevo a RGB y se actualiza. Esta forma de modificar los colores de la textura permite aplicar fácilmente degradados a grises y correcciones de luminosidad, entre otros efectos.</p>
<p>function <strong>Texture_Lock</strong> (tex, mode = RLF_READWRITE) : bool</p>
<p>Permite indicar a la textura &lt;tex&gt; que vamos a realizar operaciones Get/Set sobre ella. Véase <em>Texture_GetColor/Texture_SetColor/Texture_Unlock</em>.</p>
<p>Los modos disponibles son:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>RLF_READ</th>
<th>Queremos acceder solo para leer. Al hacer un Unlock, no será necesario el coste de actualizar los cambios en la textura.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RLF_WRITE</td>
<td>Queremos acceder solo para escribir.</td>
</tr>
<tr class="even">
<td>RLF_READWRITE</td>
<td>Queremos acceder para leer y escribir.</td>
</tr>
<tr class="odd">
<td>RLF_SAFE</td>
<td>Es un modificador que permite verificar si estamos accediendo a posiciones fuera de rango en la textura.</td>
</tr>
</tbody>
</table>
<p>function <strong>Texture_ReplaceColor</strong> (tex, x, y, w, h, c1, c2)</p>
<p>Sustituye todas las evidencias encontradas del color &lt;c1&gt; por el color &lt;c2&gt; dentro del área con posición (x,y) y tamaño (w,h&gt; de la textura &lt;tex&gt;.</p>
<p>function <strong>Texture_Save</strong> (tex, path) : bool</p>
<p>Dada una textura, guarda su contenido en un archivo con ruta &lt;path&gt;. El formato de guardado dependerá de la extensión utilizada en &lt;path&gt;. Devolverá verdadero o falso si la operación ha terminado con éxito.</p>
<p>function <strong>Texture_SetColor</strong> (tex, x, y, color)</p>
<p>Dada una posición dentro de una textura &lt;tex&gt;, permite asignar o sustituir su color por el nuevo color determinado como argumento. Para poder usar esta función es necesario bloquear el acceso a la textura (véase <em>Texture_Lock</em>). La operación contraria a esta es <em>Texture_GetColor</em>.</p>
<p>function <strong>Texture_SetColorPattern</strong> (tex, x, y, data, numBits, fgColor, bgColor)</p>
<p>Escribe varios texels a partir de la posición (x,y) de la textura. Esto lo hará en función de &lt;numBits&gt;, que podrá valer 8, 16 o 32. En ese sentido &lt;data&gt; será un valor donde cada bit representa si queremos modificar el texel con el color &lt;fgColor&gt; (si el bit vale 1) o con el color &lt;bgColor&gt; (si el bit vale 0). El primer bit será el MSB (byte más significativo) de &lt;data&gt;.</p>
<p>function <strong>Texture_Transform</strong> (tex, op) : pointer</p>
<p>Permite aplicar una transformación sobre todo el contenido de la textura &lt;tex&gt;. Indicaremos la operación a realizar &lt;op&gt; entre las disponibles, que son: TT_ROTATE_LEFT, TT_ROTATE_RIGHT, TT_HFLIP, TT_VFLIP.</p>
<p>function <strong>Texture_Unlock</strong> (tex)</p>
<p>Finaliza el acceso a una textura iniciado previamente por <em>Texture_Lock</em>.</p>
<h2 id="serial">Serial</h2>
<p>Transmisión de información serie entre dispositivos.</p>
<p>function <strong>Serial_Open</strong> (dev, baudRate, byteSize, stopBits, parity) : pointer</p>
<p>Permite abrir una vía de comunicación serie hacia/desde un dispositivo en el sistema con nombre &lt;dev&gt;. Se establecerán una velocidad &lt;baudRate&gt;, un tamaño de bits para el byte (suele ser 8), una cantidad de bits de parada &lt;stopBits&gt; y bits de paridad &lt;parity&gt;. En caso de que la comunicación no se haya podido establecer, la función retornará NULL.</p>
<p>Por ejemplo:</p>
<pre><code>_serial = Serial_Open(&quot;/dev/tty1&quot;, 9600, 8, 1, 0)</code></pre>
<p>function <strong>Serial_Close</strong> (com) : pointer</p>
<p>Cierra y libera recursos de una conexión serie abierta con <em>Serial_Open</em>.</p>
<p>function <strong>Serial_Flush</strong> (com)</p>
<p>Fuerza el envío al dispositivo de datos pendientes que pudieran estar almacenados en un buffer de escritura. El parámetro &lt;com&gt; es un puntero a un objeto de conexión serie abierto.</p>
<p>function <strong>Serial_IsAvailable</strong> (com) : bool</p>
<p>Indica si hay datos para leer en la conexión.</p>
<p>function <strong>Serial_Print</strong> (com, text) : uint</p>
<p>Escribe a través de la conexión &lt;com&gt;, byte a byte, los caracteres extraídos de la cadena de texto &lt;text&gt;.</p>
<p>function <strong>Serial_Send</strong> (com, buffer, offset = 0, len = -1) : uint</p>
<p>Escribe a través de la conexión &lt;com&gt; un objeto buffer con datos usando un offset dentro del buffer y una cantidad de bytes a enviar. Por defecto el &lt;offset&gt; es cero (principio del buffer), y el tamaño &lt;len&gt; de bytes a enviar, si es negativo, indicará que se quiere escribir el tamaño completo del buffer.</p>
<p>function <strong>Serial_Recv</strong> (com, buffer, offset = 0, len = -1) : uint</p>
<p>Lee, y guarda en un objeto buffer, los datos recibidos a través de la conexión &lt;com&gt;. Si se intenta leer y no hay datos disponibles, la función se quedará bloqueada hasta que haya más datos o salte el temporizador. Esta función es homóloga a <em>Serial_Send</em>, pero para leer.</p>
<p>function <strong>Serial_RecvUntil</strong> (com, buffer, offset = 0, len = -1, byte = 0) : uint</p>
<p>Lee, y guarda en un objeto buffer, datos hasta recibir el valor de un &lt;byte&gt; que especifiquemos o hasta que se lea la cantidad de bytes establecida en &lt;len&gt;. En caso de que &lt;len&gt; sea un valor negativo, la cantidad de datos a leer será el tamaño completo del buffer.</p>
<h2 id="miscelánea">Miscelánea</h2>
<p>Funciones de diferente índole.</p>
<p>function <strong>Path_Split</strong> (path) : list</p>
<p>Dada una cadena de caracteres &lt;path&gt; que indica una ruta a un archivo o carpeta, devuelve una lista con cuatro componentes:</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>UNIDAD</th>
<th>Hace referencia a la unidad de disco donde se encuentra la ruta. Puede ser cadena vacía si la unidad no se ha especificado o bien el nombre de la unidad seguida de ‘:’ en el caso de que sí se haya hecho.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DIRECTORIO</td>
<td>En caso de haberse especificado un directorio, aquí encontraremos la subcadena que hace referencia al mismo, incluyendo todos los caracteres ‘/’ o ‘\’ existentes.</td>
</tr>
<tr class="even">
<td>NOMBRE DE ARCHIVO</td>
<td>Contiene la cadena que hace referencia exclusivamente al nombre del archivo, sin incluir su extensión. Podrá ser cadena vacía si no se ha establecido en &lt;path&gt;.</td>
</tr>
<tr class="odd">
<td>EXTENSION</td>
<td>Contiene la cadena que hace referencia a la extensión del archivo. Esta cadena incluirá el carácter ‘.’ en caso de haberse especificado extensión en &lt;path&gt;.</td>
</tr>
</tbody>
</table>
<p>function <strong>List_ApplyFunction</strong> (list, function)</p>
<p>Dada una lista con contextos &lt;list&gt;, se recorrerá elemento a elemento de principio a fin para invocar la función con nombre &lt;function&gt;. Si el contexto no tiene esa función, se ignorará la llamada.</p>
<p>function <strong>Revert</strong> (value) : value</p>
<p>Si &lt;value&gt; es una cadena, devolverá una cadena con el orden de los caracteres invertido. O sea, el primero será el último, el segundo el penúltimo, etc. En el caso de que &lt;value&gt; sea una lista, devolverá la lista en orden invertido.</p>
<p>Ejemplo:</p>
<pre><code>_ret = revert([4, 5, 11]);</code></pre>
<p>Tras la llamada, &lt;_ret&gt; valdrá [11, 5, 4].</p>
<pre><code>_ret = revert(&quot;ejemplo&quot;);</code></pre>
<p>Tras la llamada, &lt;_ret&gt; valdrá “olpmeje”.</p>
<p>function <strong>QSort</strong> (list, ctx, function) : list</p>
<p>Permite ordenar una lista siguiendo el algoritmo de ordenación QSORT. Para comparar los elementos de la lista se utilizará la llamada a una función definida por el usuario. Esta función ha de tener el prototipo siguiente:</p>
<pre><code>function Name (item1, item2);</code></pre>
<p>Ejemplo:</p>
<pre><code>_ret = qsort([5, 7, 1, 3], this, &quot;SortNumbers&quot;);

…

function SortNumbers (_num1, _num2)
{
    if (_num1 &lt; _num2) return -1;
    else if (_num1 &gt; _num2) return 1;
    return 0;
}</code></pre>
<p>En este caso, se ordenaría la lista de menor a mayor. Por tanto &lt;_ret&gt; tras la llamada valdría [1, 3, 5, 7].</p>
<p>function <strong>IndexOf</strong> (value, obj) : int</p>
<p>Se buscará &lt;obj&gt; en &lt;value&gt; y devolverá el índice donde se encuentra. En este caso, &lt;value&gt; podrá ser una cadena de caracteres o una lista. Si &lt;obj&gt; no se encuentra, la función devolverá -1.</p>
<p>function <strong>IndexValid</strong> (value, ix) : bool</p>
<p>Determina si el índice &lt;ix&gt; es accesible en &lt;value&gt;, que podrá ser o una lista o una cadena de caracteres. En ambos casos, se espera que &lt;ix&gt; será un número entre 0 y el tamaño de la lista o cadena - 1.</p>
<p>function <strong>GetFPS</strong> (state = 1) : int</p>
<p>Obtiene el número de fotogramas por segundo según el estado donde queramos consultar. Para ello usaremos el argumento &lt;state&gt; que podrá valer:</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>DRAW - Estado en el que se procesan los gráficos</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>MOVE - Estado en el que se actualiza la lógica</td>
</tr>
<tr class="even">
<td>2</td>
<td>IDLE - Hace referencia al cómputo de todo el fotograma</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>function <strong>GetFTime</strong> () : float</p>
<p>Obtiene el factor de ajuste temporal. Con este factor, podemos calcular incrementos dependientes del coste computacional para procesar un fotograma. Por tanto, si usamos este factor, podemos ejecutar el mismo código en diferentes máquinas (con diferente capacidad de procesamiento) y conseguir que los incrementos funcionen del mismo modo en el mismo espacio de tiempo.</p>
<p>function <strong>GetTime</strong> () : uint</p>
<p>Obtiene el número de milisegundos acumulado desde que se inició el ordenador.</p>
<p>function <strong>GetHiResTime</strong> () : float</p>
<p>Obtiene el número de nanosegundos acumulado desde que se inició el ordenador.</p>
<p>function <strong>GetLocalTime</strong> () : long</p>
<p>Devuelve la hora actual expresada en milisegundos.</p>
<p>function <strong>GetTimeInfo</strong> (ms) : list</p>
<p>Dado el tiempo en milisegundos &lt;ms&gt; permite obtener una lista donde los componentes son: [HORAS, MINUTOS, SEGUNDOS, MILISEGUNDOS].</p>
<h1 id="constantes-de-teclado">Constantes de teclado</h1>
<table>
<thead>
<tr class="header">
<th>KEY_BACK</th>
<th>KEY_ESCAPE</th>
<th>KEY_1</th>
<th>KEY_2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>KEY_3</td>
<td>KEY_4</td>
<td>KEY_5</td>
<td>KEY_6</td>
</tr>
<tr class="even">
<td>KEY_7</td>
<td>KEY_8</td>
<td>KEY_9</td>
<td>KEY_0</td>
</tr>
<tr class="odd">
<td>KEY_MINUS</td>
<td>KEY_EQUALS</td>
<td>KEY_BACKSPACE</td>
<td>KEY_TAB</td>
</tr>
<tr class="even">
<td>KEY_Q</td>
<td>KEY_W</td>
<td>KEY_E</td>
<td>KEY_R</td>
</tr>
<tr class="odd">
<td>KEY_T</td>
<td>KEY_Y</td>
<td>KEY_U</td>
<td>KEY_I</td>
</tr>
<tr class="even">
<td>KEY_O</td>
<td>KEY_P</td>
<td>KEY_LBRACKET</td>
<td>KEY_RBRACKET</td>
</tr>
<tr class="odd">
<td>KEY_RETURN</td>
<td>KEY_ENTER</td>
<td>KEY_LCONTROL</td>
<td>KEY_A</td>
</tr>
<tr class="even">
<td>KEY_S</td>
<td>KEY_D</td>
<td>KEY_F</td>
<td>KEY_G</td>
</tr>
<tr class="odd">
<td>KEY_H</td>
<td>KEY_J</td>
<td>KEY_K</td>
<td>KEY_L</td>
</tr>
<tr class="even">
<td>KEY_SEMICOLON</td>
<td>KEY_APOSTROPHE</td>
<td>KEY_GRAVE</td>
<td>KEY_LSHIFT</td>
</tr>
<tr class="odd">
<td>KEY_BACKSLASH</td>
<td>KEY_Z</td>
<td>KEY_X</td>
<td>KEY_C</td>
</tr>
<tr class="even">
<td>KEY_V</td>
<td>KEY_B</td>
<td>KEY_N</td>
<td>KEY_M</td>
</tr>
<tr class="odd">
<td>KEY_COMMA</td>
<td>KEY_PERIOD</td>
<td>KEY_SLASH</td>
<td>KEY_RSHIFT</td>
</tr>
<tr class="even">
<td>KEY_MULTIPLY</td>
<td>KEY_LMENU</td>
<td>KEY_SPACE</td>
<td>KEY_CAPITAL</td>
</tr>
<tr class="odd">
<td>KEY_F1</td>
<td>KEY_F2</td>
<td>KEY_F3</td>
<td>KEY_F4</td>
</tr>
<tr class="even">
<td>KEY_F5</td>
<td>KEY_F6</td>
<td>KEY_F7</td>
<td>KEY_F8</td>
</tr>
<tr class="odd">
<td>KEY_F9</td>
<td>KEY_F10</td>
<td>KEY_NUMLOCK</td>
<td>KEY_SCROLL</td>
</tr>
<tr class="even">
<td>KEY_NUMPAD7</td>
<td>KEY_NUMPAD8</td>
<td>KEY_NUMPAD9</td>
<td>KEY_SUBTRACT</td>
</tr>
<tr class="odd">
<td>KEY_NUMPAD4</td>
<td>KEY_NUMPAD5</td>
<td>KEY_NUMPAD6</td>
<td>KEY_ADD</td>
</tr>
<tr class="even">
<td>KEY_NUMPAD1</td>
<td>KEY_NUMPAD2</td>
<td>KEY_NUMPAD3</td>
<td>KEY_NUMPAD0</td>
</tr>
<tr class="odd">
<td>KEY_DECIMAL</td>
<td>KEY_OEM_102</td>
<td>KEY_F11</td>
<td>KEY_F12</td>
</tr>
<tr class="even">
<td>KEY_F13</td>
<td>KEY_F14</td>
<td>KEY_F15</td>
<td>KEY_KANA</td>
</tr>
<tr class="odd">
<td>KEY_ABNT_C1</td>
<td>KEY_CONVERT</td>
<td>KEY_NOCONVERT</td>
<td>KEY_YEN</td>
</tr>
<tr class="even">
<td>KEY_ABNT_C2</td>
<td>KEY_NUMPADEQUALS</td>
<td>KEY_PREVTRACK</td>
<td>KEY_AT</td>
</tr>
<tr class="odd">
<td>KEY_COLON</td>
<td>KEY_UNDERLINE</td>
<td>KEY_KANJI</td>
<td>KEY_STOP</td>
</tr>
<tr class="even">
<td>KEY_AX</td>
<td>KEY_UNLABELED</td>
<td>KEY_NEXTTRACK</td>
<td>KEY_NUMPADENTER</td>
</tr>
<tr class="odd">
<td>KEY_RCONTROL</td>
<td>KEY_MUTE</td>
<td>KEY_CALCULATOR</td>
<td>KEY_PLAYPAUSE</td>
</tr>
<tr class="even">
<td>KEY_MEDIASTOP</td>
<td>KEY_VOLUMEDOWN</td>
<td>KEY_VOLUMEUP</td>
<td>KEY_WEBHOME</td>
</tr>
<tr class="odd">
<td>KEY_NUMPADCOMMA</td>
<td>KEY_DIVIDE</td>
<td>KEY_PAUSE</td>
<td>KEY_HOME</td>
</tr>
<tr class="even">
<td>KEY_UP</td>
<td>KEY_PRIOR</td>
<td>KEY_LEFT</td>
<td>KEY_RIGHT</td>
</tr>
<tr class="odd">
<td>KEY_END</td>
<td>KEY_DOWN</td>
<td>KEY_NEXT</td>
<td>KEY_INSERT</td>
</tr>
<tr class="even">
<td>KEY_DELETE</td>
<td>KEY_LWIN</td>
<td>KEY_RWIN</td>
<td>KEY_APPS</td>
</tr>
<tr class="odd">
<td>KEY_RMENU</td>
<td>KEY_POWER</td>
<td>KEY_SLEEP</td>
<td>KEY_WAKE</td>
</tr>
<tr class="even">
<td>KEY_PRINT</td>
<td>KEY_SYSRQ</td>
<td>KEY_WEBSEARCH</td>
<td>KEY_WEBFAVORITES</td>
</tr>
<tr class="odd">
<td>KEY_WEBREFRESH</td>
<td>KEY_WEBSTOP</td>
<td>KEY_WEBFORWARD</td>
<td>KEY_WEBBACK</td>
</tr>
<tr class="even">
<td>KEY_MYCOMPUTER</td>
<td>KEY_MAIL</td>
<td>KEY_MEDIASELECT</td>
<td>KEY_LALT</td>
</tr>
<tr class="odd">
<td>KEY_RALT</td>
<td>KEY_CAPSLOCK</td>
<td>KEY_NUMPADSTAR</td>
<td>KEY_NUMPADMINUS</td>
</tr>
<tr class="even">
<td>KEY_NUMPADPLUS</td>
<td>KEY_NUMPADPERIOD</td>
<td>KEY_NUMPADSLASH</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="ejemplos-148">Ejemplos</h1>
<p>Para editar los ejemplos aconsejamos usar el editor de textos por defecto en los MSXVR:</p>
<p>C:&gt;edit ejemplo1.pi</p>
<p>Para ejecutar los ejemplos, o bien podemos desde el editor pulsando a la vez CTRL+R o bien desde el VR-DOS ejecutando el script:</p>
<p>C:&gt;ejemplo1</p>
<h2 id="hola-mundo-en-vr-dos">Hola mundo en VR-DOS</h2>
<pre><code>class Ejemplo1 implements DOS_Program
{
    virtual Start()
    {
        _console = GetDOS().GetConsole();
        _console.PrintLn(&quot;Hola mundo!!&quot;);
        _console.Input(&quot;&quot;, null, 1);
        End(0);
    }
}</code></pre>
<p>En este sencillo ejemplo, mostraremos un texto en la consola del VR-DOS y esperaremos a que el usuario pulse una tecla para finalizar el programa.</p>
<h2 id="hola-mundo-en-vr-view">Hola mundo en VR-VIEW</h2>
<pre><code>class Ejemplo2 implements VIEW_Program
{
    virtual Start()
    {
        _wnd = CreateWindow();
        _menu = _wnd.CreateMenu();
        _section = _menu.AddSection(&quot;File&quot;);
        _section.AddItem(&quot;Exit&quot;, this, &quot;End&quot;);
        _label = _wnd.CreateLabel(10, 10, 200, 200);
        _label.SetText(&quot;Hola mundo!!&quot;);</code></pre>
<pre><code>    }   </code></pre>
<pre><code>    function End()
    {
        End(0);
    }
}</code></pre>
<p>Este ejemplo es similar al anterior, pero en este caso crearemos una etiqueta en la ventana. Para tener opción de salir del programa, crearemos un menú con una única opción de salir.</p>
<h2 id="hola-mundo-en-vr-basic">Hola mundo en VR-BASIC</h2>
<pre><code>class Ejemplo3 implements BASIC_Program
{
    virtual Start()
    {
        Screen (0);
        Color (15, 1, 1);
        Cls ();
        KeyOff ();
        Print(&quot;Hola mundo!&quot;);
    }
}</code></pre>
<p>Este ejemplo muestra como crear una versión del “Hola mundo!” pero utilizando la interfaz BASIC_Program. Primero se inicializa a modo de pantalla Screen 0 (40x24 caracteres), luego configura el color de texto en blanco, fondo de pantalla y borde en negro. Después desactiva la información en pantalla de las teclas de función para finalmente imprimir el texto.</p>
<p>Si quieres cerrar el ejemplo, pulsa CTRL+C o CTRL+STOP.</p>
<h2 id="detectar-un-cartucho-opl4-en-alguna-de-las-ranuras">Detectar un cartucho OPL4 en alguna de las ranuras</h2>
<pre><code>class Ejemplo4 implements DOS_Program
{
    virtual Start()
    {
        _console = GetDOS().GetConsole();
        _gr = GetEngine().GetGeekReader();
        _data = _gr.Inp(0xC4);
        if (_data != 0xFF)
        {
            _console.PrintOK(&quot;OPL4 encontrado&quot;);
        }
        else
        {
            _console.PrintError(&quot;OPL4 no existe&quot;);
        }
        End(0);
    }
}</code></pre>
<p>En este ejemplo detectamos si existe algún cartucho OPL4 insertado en alguna de las ranuras del ordenador. Por defecto INP lee de cualquiera de las ranuras. Si el valor leído es distinto de 255 (0xFF en notación hexadecimal), es que el cartucho responde.</p>
<h2 id="detectar-un-cartucho-fmpacmsxmusic-en-alguna-de-las-ranuras">Detectar un cartucho FMPAC/MSX‑MUSIC en alguna de las ranuras</h2>
<pre><code>class Ejemplo5 implements DOS_Program
{
    virtual Start()
    {
        _found = false;
        _console = GetDOS().GetConsole();
        _gr = GetEngine().GetGeekReader();
        _buffer = Buffer_New(8);
        for (i=0; i&lt;4; i++)
        {
            _gr.ReadMemory(i, 0x4018, _buffer, 0, 8);
            _idStr = Buffer_GetString(_buffer);
            if (String_FindStr(_idStr, &quot;OPLL&quot;))
            {
                _console.PrintOk(&quot;ID:&quot; + _idStr + &quot; Encontrado en la ranura:&quot; + string(i+1));
                _found = true;
                break;
            }
        }
        Buffer_Delete(_buffer);
        if (!_found)
        {
            _console.PrintError(&quot;FMPAC no encontrado!&quot;);
        }
    }
}</code></pre>
<p>En este ejemplo vamos a comprobar si existe algún cartucho FMPAC insertado en alguna de las ranuras. Esto se consigue leyendo datos de cada ranura, concretamente de la dirección hexadecimal 0x4018. Generalmente esta marca va a poder ser APRLOPLL o PAC2OPLL. La primera se encuentra en los FMPAC internos, por tanto en principio jamás veremos ese identificador. En el caso del cartucho externo, sí encontraremos la segunda. Para acertar siempre, miraremos que exista siempre la cadena “OPLL” en el identificador.</p>
<p>En caso de no existir ningún cartucho en una ranura, cualquier byte que leamos siempre será 255 (0xFF en notación hexadecimal).</p>
<h2 id="pelotas-rebotonas-en-vr-gl">Pelotas Rebotonas en VR-GL</h2>
<pre><code>class Ejemplo6 implements GL_Program
{
    virtual Start()
    {
        SetBgColor(RGB(0,0,0));
        for (i=0; i&lt;5; i++)
        {
            _ball = NewSprite(&quot;spr&quot; + string(i));
            _size = rand(5, 10);
            _ball.AddEmptyFrame(_size, _size);
            _ball.SetColor(RGB(255,255,255));
            _ball.SetPos(rand(10, 100), rand(10, 100));
            _controller = _ball.CreateController();
            _controller.SetSpeed(rand(-4, 4), rand(-4, 4));
            _controller.SetCustom(this, &quot;OnBallMove&quot;);
        }
    }

    function OnBallMove(_controller)
    {
        _ball = _controller.GetTarget();        </code></pre>
<pre><code>        _ball.IncPos(_controller.GetSpeedX(), _controller.GetSpeedY()); 

        if (_ball.GetX() &lt; 0 || _ball.GetX() &gt;= GetResX())
            _controller.SetSpeedX(-_controller.GetSpeedX());
        if (_ball.GetY() &lt; 0 || _ball.GetY() &gt;= GetResY())
            _controller.SetSpeedY(-_controller.GetSpeedY());
    }
} </code></pre>
<p>En este ejemplo, crearemos 5 sprites con tamaños y posiciones aleatorias. Como no usaremos texturas, agregaremos un fotograma vacío y usaremos el color blanco como color por defecto. A cada sprite se le asociará un controlador con el que poder aplicar la lógica de cada pelota. Esta lógica consiste en mover la pelota en una dirección y detectar si tocamos los límites de la pantalla. En el caso de que toquemos alguno de los límites, cambiaremos el sentido (signo) de la dirección.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Drag &amp; drop hace referencia a la acción de arrastrar y soltar.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>MSX es el nombre de un estándar de microordenador doméstico de 8 bits comercializado durante los años 80 y principios de los 90. Fue definido por Kazuhiko Nishi y presentado el 27 de junio de 1983 en Japón.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Tabla extraída de la Wikipedia de la página web msx.org. Para más detalles, consulte en internet o en la documentación de los distintos fabricantes.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>MSX-DOS es un sistema operativo de disco descontinuado desarrollado por Microsoft para el estándar de computadora doméstica de 8 bits MSX, y es un cruce entre MS-DOS 1.25 y CP/M-80 2.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>CP/M (Programa de control para microcomputadoras) es un sistema operativo monousuario y monotarea desarrollado por Gary Kildall para el microprocesador Intel 8080.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
